
<!-- saved from url=(0051)http://www.lydsy.com/JudgeOnline/export_ac_code.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<link rel="stylesheet" href="./bzoj_source_files/hoj.css" type="text/css">
</head>
<body>
<center>
<div style="width:90%; text-align:left">
<img src="./bzoj_source_files/logo.png">
</div>
<table width="96%"> 
	<tbody><tr align="center" class="hd" valign="top">
				<th><a href="http://www.lydsy.com/JudgeOnline/faqs.php">F.A.Qs</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/">Home</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/bbs.php">Discuss</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/problemset.php">ProblemSet</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/status.php">Status</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/ranklist.php">Ranklist</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/contest.php">Contest</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/modifypage.php"><b>ModifyUser</b></a>&nbsp;&nbsp;<a href="http://www.lydsy.com/JudgeOnline/userinfo.php?user=cnjzxy">
				<font color="red">cnjzxy</font></a></th><th><a href="http://www.lydsy.com/JudgeOnline/logout.php">Logout</a></th>		<th><a href="http://www.lydsy.com/JudgeOnline/donation.php"><font color="red">捐赠本站</font></a></th>
	</tr>
</tbody></table>
</center>
<center>
<div class="notice">
	<div>
		<b>Notice:</b>由于本OJ建立在Linux平台 下，而许多试题数据是在Windows下制作，请注意输入输出语句的选择，及变量类型的选择等问题，避免无谓的RE出现。	</div>
</div>
</center>

<title>Export All AC Source</title>
<h2>Problem1000</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int main()
{
	int a,b;
	scanf("%d%d",&amp;a,&amp;b);
	printf("%d\n",a+b);
	return 0;
}<pre><h2>Problem1000</h2><pre>import java.util.*;

public class Main
{
	public static void main(String[] args)
	{
		 Scanner cin=new Scanner(System.in);
		
		int a=cin.nextInt(),b=cin.nextInt();
		
		System.out.println(a+b);
		
		cin.close();
	}

}<pre><h2>Problem1000</h2><pre>a=raw_input()
x,y=a.split(' ')
x,y=int(x),int(y)
print x+y<pre><h2>Problem1000</h2><pre>#include&lt;cstdio&gt;

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int main()
{
    printf("%d\n",read()+read());
    return 0;
}
<pre><h2>Problem1000</h2><pre>function scanf():integer;
  var a:integer;
  begin
    read(a);
    exit(a);
end;
begin
  write(scanf()+scanf());
end.<pre><h2>Problem1000</h2><pre>#include&lt;stdio.h&gt;

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int main()
{
    printf("%d\n",read()+read());
    return 0;
}
<pre><h2>Problem1001</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int maxint=2147483647;
const int maxn=2000010;
struct node
{
	int ch,len;
	node *next;
}*g[maxn];

int n,m,z,size,que1[maxn],que2[maxn],pl[maxn],dist[maxn];

inline void add(int x,int y)
{
	x++,y++;
	scanf("%d",&amp;z);
	
	node *p;
	p=new node;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=g[x];
	g[x]=p;
	
	p=new node;
	p-&gt;ch=x;
	p-&gt;len=z;
	p-&gt;next=g[y];
	g[y]=p;
	//printf("%d %d\n",x-1,y-1);
}

inline void swap(int x,int y)
{
	int temp=que1[x];
	que1[x]=que1[y];
	que1[y]=temp;
	
	temp=que2[x];
	que2[x]=que2[y];
	que2[y]=temp;
	
	pl[que2[x]]=x;
	pl[que2[y]]=y;
}

void heapfy(int x)
{
	int xx=x,minn=que1[x];
	
	if(x*2&lt;=size&amp;&amp;que1[x*2]&lt;minn)xx=x*2,minn=que1[xx];
	
	if(x*2+1&lt;=size&amp;&amp;que1[x*2+1]&lt;minn)xx=x*2+1,minn=que1[xx];
	
	if(x!=xx)
	{
		swap(x,xx);
		heapfy(xx);
	}
}

void up(int x)
{
	if(x&gt;1)
		if(que1[x]&lt;que1[x&gt;&gt;1])
		{
			swap(x,x&gt;&gt;1);
			up(x&gt;&gt;1);
		}
}
inline void insert(int x,int y)
{
	que1[++size]=x;
	que2[size]=y;
	pl[y]=size; 
	
	up(size);
}

inline int dij()
{
	for(int i=1;i&lt;=(n-1)*(m-1)*2+2;i++)dist[i]=maxint;
	pl[1]=1;
	que1[1]=0;
	que2[1]=1;
	size=1;
	
	while(size)
	{
		int x=que2[1];
		dist[x]=que1[1];
		swap(1,size--);
		heapfy(1);
		if(dist[(n-1)*(m-1)*2+2]!=maxint)return dist[(n-1)*(m-1)*2+2];
		
		node *p=g[x];
		while(p!=NULL)
		{
			if(dist[p-&gt;ch]==maxint)
			{
				int temp=dist[x]+p-&gt;len;
				if(pl[p-&gt;ch])
				{
					if(temp&lt;que1[pl[p-&gt;ch]])
					{
						que1[pl[p-&gt;ch]]=temp;
						up(pl[p-&gt;ch]);
					}
				}
				else
					insert(temp,p-&gt;ch);
			}
			p=p-&gt;next;
		}
	}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	if(n==1)
		for(int j=1;j&lt;m;j++)add(0,(n-1)*(m-1)*2+1);
	else
	{
		for(int j=1;j&lt;m;j++)add(j*2,(n-1)*(m-1)*2+1);
		for(int i=2;i&lt;n;i++)
	  		for(int j=1;j&lt;m;j++)
	    		add((i-2)*(m-1)*2+j*2-1,(i-1)*(m-1)*2+j*2);
		for(int j=1;j&lt;m;j++)add(0,(n-2)*(m-1)*2+j*2-1);
	}
	
	for(int i=1;i&lt;n;i++)
	  if(m==1)
	    add(0,(n-1)*(m-1)*2+1);
	  else
	  {
	  	add(0,(i-1)*(m-1)*2+1);
		
		for(int j=2;j&lt;m;j++)
			add((i-1)*(m-1)*2+j*2-2,(i-1)*(m-1)*2+j*2-1);
			
		add(i*(m-1)*2,(n-1)*(m-1)*2+1);
	  }
	
	for(int i=1;i&lt;n;i++)
	  for(int j=1;j&lt;m;j++)
	    add((i-1)*(m-1)*2+j*2-1,(i-1)*(m-1)*2+j*2);
	
	printf("%d\n",dij());
	
	return 0;
} <pre><h2>Problem1001</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m;
int cnt,siz;
int g[2000010];
bool v[2000010];
int num[2000010],pl[2000010],key[2000010];

struct edge
{
    int t,c,next;
}e[6000010];
inline int read()
{
    int c=getchar(),temp=0;

    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline void add_edge(int x,int y)
{
    int z=read();
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=z;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline void up(int p)
{
    while(p&gt;&gt;1)
    {
        int x=p&gt;&gt;1;
        if(key[p]&gt;=key[x])return;
        Swap(key[x],key[p]);
        Swap(num[x],num[p]);
        Swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void down(int p)
{
    while((p&lt;&lt;1)&lt;=siz)
    {
        int x=p&lt;&lt;1;
        if(x&lt;siz&amp;&amp;key[x|1]&lt;key[x])x|=1;
        if(key[p]&lt;=key[x])return;
        Swap(key[x],key[p]);
        Swap(num[x],num[p]);
        Swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void ins(int p,long long v)
{
    key[++siz]=v;
    num[siz]=p;
    pl[p]=siz;
    up(siz);
}
inline void del(int p)
{
    key[p]=key[siz];
    num[p]=num[siz];
    pl[num[p]]=p;
    siz--;
    down(p);
}

inline long long dijkstra(int x)
{
    siz=1;
    key[1]=0;
    num[1]=x;
    pl[x]=1;

    while(siz)
    {
        int x=num[1];
        long long dist=key[1];
        if(x==1)return dist;
        v[x]=true;
        del(1);

        for(int i=g[x];i;i=e[i].next)
            if(!v[e[i].t])
                if(!pl[e[i].t])
                    ins(e[i].t,dist+e[i].c);
                else
                    if(dist+e[i].c&lt;key[pl[e[i].t]])
                    {
                        key[pl[e[i].t]]=dist+e[i].c;
                        up(pl[e[i].t]);
                    }
    }
}

int main()
{
    n=read();m=read();

    if(n==1)
        for(int j=1;j&lt;m;j++)
            add_edge(1,(n-1)*(m-1)*2+2);
    else
    {
        for(int j=1;j&lt;m;j++)
            add_edge(j&lt;&lt;1|1,(n-1)*(m-1)*2+2);
        for(int i=2;i&lt;n;i++)
            for(int j=1;j&lt;m;j++)
                add_edge((i-2)*(m-1)*2+j*2,(i-1)*(m-1)*2+j*2+1);
        for(int j=1;j&lt;m;j++)
            add_edge(1,(n-2)*(m-1)*2+j*2);
    }

    for(int i=1;i&lt;n;i++)
        if(m==1)
            add_edge(1,(n-1)*(m-1)*2+2);
        else
        {
            add_edge(1,(i-1)*(m-1)*2+2);

            for(int j=2;j&lt;m;j++)
                add_edge((i-1)*(m-1)*2+j*2-1,(i-1)*(m-1)*2+j*2);

            add_edge(i*(m-1)*2+1,(n-1)*(m-1)*2+2);
        }

    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;m;j++)
            add_edge((i-1)*(m-1)*2+j*2,(i-1)*(m-1)*2+j*2+1);

    printf("%d\n",dijkstra((n-1)*(m-1)*2+2));

    return 0;
}
<pre><h2>Problem1001</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m;
int cnt,siz;
int calc[1010];
int g[2000010];
bool v[2000010];
int num[2000010],pl[2000010],key[2000010];

struct edge
{
    int t,c,next;
}e[6000010];
inline int read()
{
    int c=getchar(),temp=0;

    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline void add_edge(int x,int y)
{
    int z=read();
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=z;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline void up(int p)
{
    while(p&gt;&gt;1)
    {
        int x=p&gt;&gt;1;
        if(key[p]&gt;=key[x])return;
        Swap(key[x],key[p]);
        Swap(num[x],num[p]);
        Swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void down(int p)
{
    while((p&lt;&lt;1)&lt;=siz)
    {
        int x=p&lt;&lt;1;
        if(x&lt;siz&amp;&amp;key[x|1]&lt;key[x])x|=1;
        if(key[p]&lt;=key[x])return;
        Swap(key[x],key[p]);
        Swap(num[x],num[p]);
        Swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void ins(int p,long long v)
{
    key[++siz]=v;
    num[siz]=p;
    pl[p]=siz;
    up(siz);
}
inline void del(int p)
{
    key[p]=key[siz];
    num[p]=num[siz];
    pl[num[p]]=p;
    siz--;
    down(p);
}

inline long long dijkstra(int x)
{
    siz=1;
    key[1]=0;
    num[1]=x;
    pl[x]=1;

    while(siz)
    {
        int x=num[1];
        long long dist=key[1];
        if(x==1)return dist;
        v[x]=true;
        del(1);

        for(int i=g[x];i;i=e[i].next)
            if(!v[e[i].t])
                if(!pl[e[i].t])
                    ins(e[i].t,dist+e[i].c);
                else
                    if(dist+e[i].c&lt;key[pl[e[i].t]])
                    {
                        key[pl[e[i].t]]=dist+e[i].c;
                        up(pl[e[i].t]);
                    }
    }
}

int main()
{
    n=read();m=read();

    for(int i=1;i&lt;=n;i++)
        calc[i]=calc[i-1]+m-1+m-1;

    if(n==1)
        for(int j=1;j&lt;m;j++)
            add_edge(1,calc[n-1]+2);
    else
    {
        for(int j=1;j&lt;m;j++)
            add_edge(j&lt;&lt;1|1,calc[n-1]+2);
        for(int i=2;i&lt;n;i++)
            for(int j=1;j&lt;m;j++)
                add_edge(calc[i-2]+(j&lt;&lt;1),calc[i-1]+(j&lt;&lt;1)+1);
        for(int j=1;j&lt;m;j++)
            add_edge(1,calc[n-2]+(j&lt;&lt;1));
    }

    for(int i=1;i&lt;n;i++)
        if(m==1)
            add_edge(1,calc[n-1]+2);
        else
        {
            add_edge(1,calc[i-1]+2);

            for(int j=2;j&lt;m;j++)
                add_edge(calc[i-1]+(j&lt;&lt;1)-1,calc[i-1]+(j&lt;&lt;1));

            add_edge(calc[i]+1,calc[n-1]+2);
        }

    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;m;j++)
            add_edge(calc[i-1]+(j&lt;&lt;1),calc[i-1]+(j&lt;&lt;1)+1);

    printf("%d\n",dijkstra(calc[n-1]+2));

    return 0;
}
<pre><h2>Problem1002</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;
 
int n;

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

struct bignum
{
    int a[10000],len;
    
    bignum()
	{
		len=0;
		memset(a,0,sizeof(a));
	}
	
    bignum(int b)
    { 
        len=0;
		memset(a,0,sizeof(a)); 
        while(b)a[++len]=b%10000,b/=10000; 
        if(len==0)len=1; 
    }
	
    friend bignum operator*(bignum a,int b)
    {
        for(int i=1;i&lt;=a.len;i++)a.a[i]*=b;
        for(int i=1;i&lt;=a.len;i++)a.a[i+1]+=a.a[i]/10000,a.a[i]%=10000;
        if(a.a[a.len+1])a.len++;
        return a;
    }
    
    friend bignum operator+(bignum a,bignum b)
    {
        bignum c;
        c.len=max(a.len,b.len);
        
		for(int i=1;i&lt;=c.len;i++)
        {
            c.a[i]+=a.a[i]+b.a[i];
            c.a[i+1]+=c.a[i]/10000;
            c.a[i]%=10000;
        }
    
        c.len++;
        while (!c.a[c.len])c.len--;
        
		return c;
    }
    
    friend bignum operator-(bignum a,bignum b)
    {
        bignum c;
        c.len=max(a.len,b.len);
        
		for(int i=1;i&lt;=c.len;i++)
        {
            c.a[i]+=a.a[i]-b.a[i];
            if(c.a[i]&lt;0)c.a[i]+=10000,c.a[i+1]--;
        }
        
        while(!c.a[c.len])c.len--;
        
		return c;
    }

    void print()
    {
        printf("%d",a[len]);
        for(int i=len-1;i;i--)printf("%04d",a[i]);
        printf("\n");
    }
}f[110];

int main()
{
	scanf("%d",&amp;n);
    
	f[1]=1,f[2]=5;
    if (n&lt;=2)
		f[n].print();
    else 
    { 
        for(int i=3;i&lt;=n;i++)f[i]=f[i-1]*3-f[i-2]+2; 
		f[n].print();
    }
    
    return 0; 
}<pre><h2>Problem1003</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int inf=1000000000;

struct size
{
	int g,s,t;
}una[1000];

int n,m,kk,e,d,ch[25],ch1[25][25],ch2[25][25];
int f[110],cover[110][110];
bool v[25];

inline bool cmp(size a,size b)
{
	return a.s&lt;b.s;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline int spfa()
{
	int dist[25],que[25],h=0,t=1;
	bool inque[25];
	
	for(int i=2;i&lt;=m;i++)dist[i]=inf,inque[i]=false;
	
	dist[1]=0;
	que[1]=1;
	inque[1]=true;
	
	while(h!=t)
	{
		h=h%m+1;
		int fa=que[h];
		inque[fa]=false;
		
		for(int i=1;i&lt;=ch[fa];i++)
		{
			int child=ch1[fa][i];
			
			if((dist[fa]+ch2[fa][i]&lt;dist[child])&amp;&amp;(v[child]))
			{
				dist[child]=dist[fa]+ch2[fa][i];
				
				if(!inque[child])
				{
					t=t%m+1;
					inque[child]=true;
					que[t]=child;
				}
			}
		}
	}
	return dist[m];
}
int main()
{
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;kk,&amp;e);
	
	for(;e;e--)
	{
		int x,y,z;
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		ch1[x][++ch[x]]=y;
		ch2[x][ch[x]]=z;
		
		ch1[y][++ch[y]]=x;
		ch2[y][ch[y]]=z;
	}
	
	scanf("%d",&amp;d);
	
	for(int i=0;i&lt;d;i++)scanf("%d%d%d",&amp;una[i].g,&amp;una[i].s,&amp;una[i].t);
	
	sort(una,una+d,cmp);
	
	for(int i=1;i&lt;=n;i++)
	{
		int k=0;
		
		for(int j=1;j&lt;=m;j++)v[j]=true;
		
		while(una[k].s&lt;i&amp;&amp;k&lt;d)
		{
			if(una[k].t&gt;=i)v[una[k].g]=false;
			k++;
		}
		
		for(int j=i;j&lt;=n;j++)
		{
			while(una[k].s==j&amp;&amp;k&lt;d)v[una[k++].g]=false;
			
			cover[i][j]=spfa();
		}
	}
	
	for(int i=1;i&lt;=n;i++)
	{
		f[i]=inf;
		if(cover[1][i]!=inf)f[i]=cover[1][i]*i;
		for(int j=1;j&lt;i;j++)
		  if(cover[j+1][i]!=inf)
		  	f[i]=min(f[i],f[j]+cover[j+1][i]*(i-j)+kk);
	}
	
	printf("%d\n",f[n]);
	
	return 0;
}<pre><h2>Problem1005</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int size=168;

const int data[size+1]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,
79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,
313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,
443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,
587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,
719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857
,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};

int n,len,a,sum,j,k;
int t[10001],ans[size+1];

inline void calc(int n,int m)
{
    int p,j;
    for(int i=m+1;i&lt;=n;i++)
    {
        p=i;
        j=1;
        while(p&gt;1)
        {
            while(p%data[j]==0)
            {
                ans[j]++;
                p/=data[j];
            }
            j++;
        }
    }

    for(int i=1;i&lt;=n-m;i++)
    {
        p=i;
        j=1;
        while(p&gt;1)
        {
            while(p%data[j]==0)
            {
                ans[j]--;
                p/=data[j];
            }
            j++;
        }
    }
}

int main()
{
    scanf("%d",&amp;n);
    len=n-2;

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;a);
        if(a==0||len-(a-1)&lt;0)
        {
            printf("0");
            return 0;
        }
        if(a==-1)
        {
            sum++;
            continue;
        }
        a--;
        calc(len,a);
        len-=a;
    }
    if(len)
    {
        j=1;
        while(sum&gt;1)
        {
            while(sum%data[j]==0)
            {
                ans[j]+=len;
                sum/=data[j];
            }
            j++;
        }
    }

    t[1]=1;
    k=1;
    for(int i=1;i&lt;=size;i++)
        while(ans[i])
        {
            ans[i]--;
            for (j=1;j&lt;=k;j++)
                t[j]*=data[i];
            for(j=1;j&lt;=k;j++)
                if(t[j]&gt;9)
                {
                    t[j+1]+=t[j]/10;
                    t[j]%=10;
                }
            while(t[k+1])
            {
                k++;
                t[k+1]+=t[k]/10;
                t[k]%=10;
            }
        }

    for(int i=k;i&gt;0;i--)
        printf("%d",t[i]);

    return 0;
}
<pre><h2>Problem1007</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

struct size
{
	double a,b;
	int num;
}line[50010],line1[50010];

int n,stack[50010],ans[50010];

inline bool cmp1(size x,size y)
{
	return x.a&lt;y.a||(x.a==y.a&amp;&amp;x.b&gt;y.b);
}

inline bool bo(int a,int b,int c)
{
	return (line1[a].b-line1[c].b)*(line1[b].a-line1[a].a)
			&lt;=(line1[a].b-line1[b].b)*(line1[c].a-line1[a].a);	
}

int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
	  line[i].num=i,scanf("%lf%lf",&amp;line[i].a,&amp;line[i].b);
	  
	sort(line+1,line+n+1,cmp1);
	
	
	int k=1;
	line1[1]=line[1];
	for(int i=2;i&lt;=n;i++)
	  if(line[i].a!=line[i-1].a)
	    line1[++k]=line[i];
	
	int size=0;
	
	for(int i=1;i&lt;=k;i++)
	{
		while(size&gt;1&amp;&amp;bo(stack[size-1],stack[size],i))size--;
		if(size&lt;=1)
			stack[++size]=i;
		else
		  if(!bo(stack[size-1],stack[size],i))
		  	stack[++size]=i;
	}
	for(int i=1;i&lt;=size;i++)ans[i]=line1[stack[i]].num;
	sort(ans+1,ans+size+1);
	
	for(int i=1;i&lt;=size;i++)printf("%d ",ans[i]);
	printf("\n");
	
	return 0;
} <pre><h2>Problem1007</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

struct size
{
	double a,b;
	int num;
}line[50010],line1[50010];

int n,stack[50010],ans[50010];

inline bool cmp1(size x,size y)
{
	return x.a&lt;y.a||(x.a==y.a&amp;&amp;x.b&gt;y.b);
}

inline bool bo(int a,int b,int c)
{
	return (line1[a].b-line1[c].b)*(line1[b].a-line1[a].a)
			&lt;=(line1[a].b-line1[b].b)*(line1[c].a-line1[a].a);	
}

int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
	  line[i].num=i,scanf("%lf%lf",&amp;line[i].a,&amp;line[i].b);
	  
	sort(line+1,line+n+1,cmp1);
	
	
	int k=1;
	line1[1]=line[1];
	for(int i=2;i&lt;=n;i++)
	  if(line[i].a!=line[i-1].a)
	    line1[++k]=line[i];
	
	int size=0;
	
	for(int i=1;i&lt;=k;i++)
	{
		while(size&gt;1&amp;&amp;bo(stack[size-1],stack[size],i))size--;
		stack[++size]=i;
	}
	for(int i=1;i&lt;=size;i++)ans[i]=line1[stack[i]].num;
	sort(ans+1,ans+size+1);
	
	for(int i=1;i&lt;=size;i++)printf("%d ",ans[i]);
	printf("\n");
	
	return 0;
} <pre><h2>Problem1008</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;

using namespace std;

const long long p=100003;

long long n,m;

long long pow(long long a,long long t,long long p)
{
	if(!t)return 1;
	long long temp=pow(a,t&gt;&gt;1,p);
	temp=temp*temp%p;
	if(t&amp;1)temp=temp*a%p;
	return temp;
}

int main()
{
	cin&gt;&gt;m&gt;&gt;n;
	
	long long ans=pow(m,n,p);
	
	long long ans1=m*pow(m-1,n-1,p)%p;
	
	ans=(ans-ans1)%p;
	
	while(ans&lt;0)ans+=p;
	
	cout&lt;&lt;ans&lt;&lt;endl;
	
	return 0;
}<pre><h2>Problem1010</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;

using namespace std;

long long sum[50050],dp[50050],f[50050];
int n,c,l,que[50050];

inline long long calc1(int k,int j)
{
	return dp[k]+(f[k]+c)*(f[k]+c)-dp[j]-(f[j]+c)*(f[j]+c);
}

inline long long calc2(int k,int j)
{
	return 2*(f[k]-f[j]);
}
int main()
{
	scanf("%d%d",&amp;n,&amp;l);
	c=l+1;
	f[0]=sum[0]=0;
	
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;sum[i];
		sum[i]+=sum[i-1];
		f[i]=i+sum[i];
	}
	
	int h=1,t=1;
	que[1]=dp[0]=0;
	
	for(int i=1;i&lt;=n;i++)
	{
		while(h&lt;t&amp;&amp;calc1(que[h+1],que[h])&lt;=f[i]*calc2(que[h+1],que[h]))h++;
		dp[i]=dp[que[h]]+(f[i]-f[que[h]]-c)*(f[i]-f[que[h]]-c);
		while(h&lt;t&amp;&amp;calc1(que[t],que[t-1])*calc2(i,que[t])&gt;=calc2(que[t],que[t-1])*calc1(i,que[t]))t--;                
        que[++t]=i;
	}
	
	cout&lt;&lt;dp[n]&lt;&lt;endl;
	
	return 0;
}<pre><h2>Problem1012</h2><pre>#include&lt;cstdio&gt;

using namespace std;

struct size
{
	int l,r,max;
}tree[600000];

int pl[200010],m,d,x;
char c,c1;

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

void build(int p,int l,int r)
{
	tree[p].l=l;
	tree[p].r=r;
	if(l!=r)
	{
		int mid=(l+r)/2;
		build(p*2,l,mid);
		build(p*2+1,mid+1,r);
	}
	else
	  pl[l]=p;
} 

void insert(int p,int x)
{
	if(p)
	  if(x&gt;tree[p].max)
	  {
	  	tree[p].max=x;
		insert(p/2,x);
	  }
}

int query(int p,int l,int r)
{
	if(l&lt;=tree[p].l&amp;&amp;tree[p].r&lt;=r)
	  return tree[p].max;
	else
	{
		int mid=(tree[p].l+tree[p].r)/2;
		if(r&lt;=mid)
		  return query(p*2,l,r);
		else
		  if(l&gt;mid)
		    return query(p*2+1,l,r);
		  else
		    return max(query(p*2,l,mid),query(p*2+1,mid+1,r));
	}
}

int main()
{
	scanf("%d%d",&amp;m,&amp;d);
	
	int t=0,l=0;
	build(1,1,m);
	c=getchar();
	
	for(;m;m--)
	{
		c=getchar();
		c1=getchar();
		scanf("%d",&amp;x);
		c1=getchar();
		if(c=='A')
		  insert(pl[++l],(x+t)%d);
		else
		  printf("%d\n",t=query(1,l-x+1,l));
	}
	
	return 0;
}<pre><h2>Problem1013</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const double eps=1e-8;
int n;
double a[20][20],p[20][20];

inline void swap(int i1,int i2,int j)
{
	int temp=a[i1][j];
	a[i1][j]=a[i2][j];
	a[i2][j]=temp;
}

inline void init()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n+1;i++)
	  for(int j=1;j&lt;=n;j++)
	    scanf("%lf",&amp;p[i][j]);
}

inline void solve()
{
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=n;j++)a[i][j]=(p[i+1][j]-p[i][j])*2;
		
		a[i][n+1]=0;
		for(int j=1;j&lt;=n;j++)
		  a[i][n+1]+=p[i+1][j]*p[i+1][j]-p[i][j]*p[i][j];
	}
	
	for(int i=1;i&lt;=n;i++)
	{
		int k=i;
		while(fabs(a[k][i])&lt;=eps)k++;
		if(i!=k)
		  for(int j=1;j&lt;=n+1;j++)swap(i,k,j);
		  
		for(int j=n+1;j&gt;=i;j--)a[i][j]/=a[i][i];
		
		for(int j=1;j&lt;=n;j++)
		  if(i!=j)
		  	for(k=n+1;k&gt;=i;k--)
		  	  a[j][k]-=a[j][i]*a[i][k];
	}
	
	printf("%.3f",a[1][n+1]);
	for(int i=2;i&lt;=n;i++)
	  printf(" %.3f",a[i][n+1]);
}
int main()
{
	init();
	
	solve();
	
	return 0;
} <pre><h2>Problem1015</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,x,y,t,num;
int fa[400010],del[400010],ans[400010];
bool v[400010];

struct size
{
	int ch;
	size *next;
}*g[400010];

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=g[x];
	g[x]=p;
}

int find(int x)
{
	return fa[x]=x==fa[x]?x:find(fa[x]);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(x,y);
		add_edge(y,x);
	}
	memset(v,true,sizeof(v));
	
	scanf("%d",&amp;t);
	for(int i=1;i&lt;=t;i++)
	{
		scanf("%d",del+i);
		v[del[i]]=false;
	}
	
	for(int i=0;i&lt;n;i++)fa[i]=i;
	num=n-t;
	
	for(int i=0;i&lt;n;i++)
		if(v[i])
		{
			size *p=g[i];
			while(p!=NULL)
			{
				if(v[p-&gt;ch]&amp;&amp;find(i)!=find(p-&gt;ch))
				{
					num--;
					fa[find(i)]=fa[find(p-&gt;ch)];
				}
				p=p-&gt;next;
			}
		}
	
	for(int i=t;i;i--)
	{
		ans[i]=num++;
		v[del[i]]=true;
		size *p=g[del[i]];
		while(p!=NULL)
		{
			if(v[p-&gt;ch]&amp;&amp;find(del[i])!=find(p-&gt;ch))
			{
				num--;
				fa[find(del[i])]=fa[find(p-&gt;ch)];
			}
			p=p-&gt;next;
		}
	}
	
	printf("%d\n",num);
	for(int i=1;i&lt;=t;i++)printf("%d\n",ans[i]);
	
	return 0;
}<pre><h2>Problem1016</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,sum;
int fa[110],f1[110],f2[110];
int ans1[1010];
struct edge
{
  int x,y,c;
  inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
  {
    return a.c&lt;b.c;
  }
}e[1010];

inline int read()
{
  int c=getchar(),temp=0;
  while(c&lt;48||c&gt;57)c=getchar();
  while(c&gt;=48&amp;&amp;c&lt;=57)
    {
      temp=temp*10+c-48;
      c=getchar();
    }
  return temp;
}
inline int Min(int a,int b)
{
  return a&lt;b?a:b;
}

inline int find(int x)
{
  return fa[x]=x==fa[x]?x:find(fa[x]);
}
inline int find1(int x)
{
  return f1[x]=x==f1[x]?x:find1(f1[x]);
}

int main()
{
  n=read();m=read();
  for(int i=1;i&lt;=n;i++)
    fa[i]=i;
  for(int i=1;i&lt;=m;i++)
    {
      e[i].x=read();e[i].y=read();e[i].c=read();
    }
  sort(e+1,e+m+1);

  for(int i=1;i&lt;=m;i)
    {
      int l=i,r=i,cnt=0;
      for(int j=1;j&lt;=n;j++)
	f2[j]=fa[j];
      while(r&lt;m&amp;&amp;e[r+1].c==e[r].c)r++;

      for(int j=l;j&lt;=r;j++)
	if(find(e[j].x)!=find(e[j].y))
	  {
	    fa[find(e[j].x)]=find(e[j].y);
	    cnt++;
	  }
      sum+=cnt;

      int S=1&lt;&lt;(r-l+1);
      for(int j=0;j&lt;S;j++)
	{
	  int temp=j,cnt1=0;
	  while(temp)
	    {
	      cnt1++;
	      temp-=(temp&amp;-temp);
	    }
	  if(cnt1!=cnt)continue;

	  bool flag=true;
	  for(int k=1;k&lt;=n;k++)
	    f1[k]=f2[k];
	  for(int k1=1,k2=0;k1&lt;S;)
	    {
	      if(j&amp;k1)
		{
		  if(find1(e[i+k2].x)==find1(e[i+k2].y))
		  {
		    flag=false;
		    break;
		  }
		  f1[find1(e[i+k2].x)]=find1(e[i+k2].y);
		}
	      k1&lt;&lt;=1;
	      k2++;
	    }
	  if(flag)ans1[i]++;
	}
      i=r+1;
    }

  if(sum!=n-1)
    {
      printf("0\n");
      return 0;
    }
  int ans=1;
  for(int i=1;i&lt;=m;i++)
    if(ans1[i]!=0)
      ans=ans*ans1[i]%31011;
  printf("%d\n",ans);

  return 0;
}
<pre><h2>Problem1018</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n;
int lr[3][100010],ud[100010];
int calc[64][64]={{0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2},{0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7},{0,0,2,2,0,0,2,2,0,0,2,2,2,2,2,2,0,0,2,2,0,0,2,2,0,0,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2},{0,1,2,3,4,5,6,7,0,1,2,3,6,7,6,7,0,1,2,3,4,5,6,7,0,1,2,3,6,7,6,7,0,3,2,3,4,7,6,7,0,3,2,3,6,7,6,7,0,3,2,3,4,7,6,7,0,3,2,3,6,7,6,7},{0,0,2,2,0,0,2,2,1,1,3,3,1,1,3,3,0,0,2,2,0,0,2,2,1,1,3,3,1,1,3,3,4,4,6,6,4,4,6,6,5,5,7,7,5,5,7,7,4,4,6,6,4,4,6,6,5,5,7,7,5,5,7,7},{0,1,2,3,4,5,6,7,1,1,3,3,5,5,7,7,0,1,2,3,4,5,6,7,1,1,3,3,5,5,7,7,4,5,6,7,4,5,6,7,5,5,7,7,5,5,7,7,4,5,6,7,4,5,6,7,5,5,7,7,5,5,7,7},{0,0,2,2,0,0,2,2,1,1,3,3,3,3,3,3,0,0,2,2,0,0,2,2,1,1,3,3,3,3,3,3,4,6,6,6,4,6,6,6,5,7,7,7,7,7,7,7,4,6,6,6,4,6,6,6,5,7,7,7,7,7,7,7},{0,1,2,3,4,5,6,7,1,1,3,3,7,7,7,7,0,1,2,3,4,5,6,7,1,1,3,3,7,7,7,7,4,7,6,7,4,7,6,7,5,7,7,7,7,7,7,7,4,7,6,7,4,7,6,7,5,7,7,7,7,7,7,7},{0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42},{0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47},{0,8,2,10,32,40,34,42,0,8,2,10,34,42,34,42,0,8,2,10,32,40,34,42,0,8,2,10,34,42,34,42,0,10,2,10,32,42,34,42,0,10,2,10,34,42,34,42,0,10,2,10,32,42,34,42,0,10,2,10,34,42,34,42},{0,9,2,11,36,45,38,47,0,9,2,11,38,47,38,47,0,9,2,11,36,45,38,47,0,9,2,11,38,47,38,47,0,11,2,11,36,47,38,47,0,11,2,11,38,47,38,47,0,11,2,11,36,47,38,47,0,11,2,11,38,47,38,47},{0,8,2,10,32,40,34,42,1,9,3,11,33,41,35,43,16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,4,12,6,14,36,44,38,46,5,13,7,15,37,45,39,47,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63},{0,9,2,11,36,45,38,47,1,9,3,11,37,45,39,47,16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,4,13,6,15,36,45,38,47,5,13,7,15,37,45,39,47,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63},{0,8,2,10,32,40,34,42,1,9,3,11,35,43,35,43,16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,4,14,6,14,36,46,38,46,5,15,7,15,39,47,39,47,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63},{0,9,2,11,36,45,38,47,1,9,3,11,39,47,39,47,16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,4,15,6,15,36,47,38,47,5,15,7,15,39,47,39,47,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63},{16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18},{16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23},{16,16,18,18,16,16,18,18,16,16,18,18,18,18,18,18,16,16,18,18,16,16,18,18,16,16,18,18,18,18,18,18,16,18,18,18,16,18,18,18,16,18,18,18,18,18,18,18,16,18,18,18,16,18,18,18,16,18,18,18,18,18,18,18},{16,17,18,19,20,21,22,23,16,17,18,19,22,23,22,23,16,17,18,19,20,21,22,23,16,17,18,19,22,23,22,23,16,19,18,19,20,23,22,23,16,19,18,19,22,23,22,23,16,19,18,19,20,23,22,23,16,19,18,19,22,23,22,23},{16,16,18,18,16,16,18,18,17,17,19,19,17,17,19,19,16,16,18,18,16,16,18,18,17,17,19,19,17,17,19,19,20,20,22,22,20,20,22,22,21,21,23,23,21,21,23,23,20,20,22,22,20,20,22,22,21,21,23,23,21,21,23,23},{16,17,18,19,20,21,22,23,17,17,19,19,21,21,23,23,16,17,18,19,20,21,22,23,17,17,19,19,21,21,23,23,20,21,22,23,20,21,22,23,21,21,23,23,21,21,23,23,20,21,22,23,20,21,22,23,21,21,23,23,21,21,23,23},{16,16,18,18,16,16,18,18,17,17,19,19,19,19,19,19,16,16,18,18,16,16,18,18,17,17,19,19,19,19,19,19,20,22,22,22,20,22,22,22,21,23,23,23,23,23,23,23,20,22,22,22,20,22,22,22,21,23,23,23,23,23,23,23},{16,17,18,19,20,21,22,23,17,17,19,19,23,23,23,23,16,17,18,19,20,21,22,23,17,17,19,19,23,23,23,23,20,23,22,23,20,23,22,23,21,23,23,23,23,23,23,23,20,23,22,23,20,23,22,23,21,23,23,23,23,23,23,23},{16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58},{16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63},{16,24,18,26,48,56,50,58,16,24,18,26,50,58,50,58,16,24,18,26,48,56,50,58,16,24,18,26,50,58,50,58,16,26,18,26,48,58,50,58,16,26,18,26,50,58,50,58,16,26,18,26,48,58,50,58,16,26,18,26,50,58,50,58},{16,25,18,27,52,61,54,63,16,25,18,27,54,63,54,63,16,25,18,27,52,61,54,63,16,25,18,27,54,63,54,63,16,27,18,27,52,63,54,63,16,27,18,27,54,63,54,63,16,27,18,27,52,63,54,63,16,27,18,27,54,63,54,63},{16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63},{16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63},{16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63},{16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63},{0,0,2,2,0,0,2,2,8,8,10,10,8,8,10,10,0,0,2,2,0,0,2,2,8,8,10,10,8,8,10,10,32,32,34,34,32,32,34,34,40,40,42,42,40,40,42,42,32,32,34,34,32,32,34,34,40,40,42,42,40,40,42,42},{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},{0,0,2,2,0,0,2,2,8,8,10,10,10,10,10,10,0,0,2,2,0,0,2,2,8,8,10,10,10,10,10,10,32,34,34,34,32,34,34,34,40,42,42,42,42,42,42,42,32,34,34,34,32,34,34,34,40,42,42,42,42,42,42,42},{0,1,2,3,4,5,6,7,8,9,10,11,14,15,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,32,35,34,35,36,39,38,39,40,43,42,43,46,47,46,47,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63},{0,0,2,2,0,0,2,2,9,9,11,11,9,9,11,11,0,0,2,2,0,0,2,2,9,9,11,11,9,9,11,11,36,36,38,38,36,36,38,38,45,45,47,47,45,45,47,47,36,36,38,38,36,36,38,38,45,45,47,47,45,45,47,47},{0,1,2,3,4,5,6,7,9,9,11,11,13,13,15,15,16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,36,37,38,39,36,37,38,39,45,45,47,47,45,45,47,47,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63},{0,0,2,2,0,0,2,2,9,9,11,11,11,11,11,11,0,0,2,2,0,0,2,2,9,9,11,11,11,11,11,11,36,38,38,38,36,38,38,38,45,47,47,47,47,47,47,47,36,38,38,38,36,38,38,38,45,47,47,47,47,47,47,47},{0,1,2,3,4,5,6,7,9,9,11,11,15,15,15,15,16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,36,39,38,39,36,39,38,39,45,47,47,47,47,47,47,47,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63},{0,8,2,10,32,40,34,42,8,8,10,10,40,40,42,42,0,8,2,10,32,40,34,42,8,8,10,10,40,40,42,42,32,40,34,42,32,40,34,42,40,40,42,42,40,40,42,42,32,40,34,42,32,40,34,42,40,40,42,42,40,40,42,42},{0,9,2,11,36,45,38,47,8,9,10,11,44,45,46,47,16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,32,41,34,43,36,45,38,47,40,41,42,43,44,45,46,47,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63},{0,8,2,10,32,40,34,42,8,8,10,10,42,42,42,42,0,8,2,10,32,40,34,42,8,8,10,10,42,42,42,42,32,42,34,42,32,42,34,42,40,42,42,42,42,42,42,42,32,42,34,42,32,42,34,42,40,42,42,42,42,42,42,42},{0,9,2,11,36,45,38,47,8,9,10,11,46,47,46,47,16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,32,43,34,43,36,47,38,47,40,43,42,43,46,47,46,47,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63},{0,8,2,10,32,40,34,42,9,9,11,11,41,41,43,43,16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,36,44,38,46,36,44,38,46,45,45,47,47,45,45,47,47,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63},{0,9,2,11,36,45,38,47,9,9,11,11,45,45,47,47,16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,36,45,38,47,36,45,38,47,45,45,47,47,45,45,47,47,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63},{0,8,2,10,32,40,34,42,9,9,11,11,43,43,43,43,16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,36,46,38,46,36,46,38,46,45,47,47,47,47,47,47,47,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63},{0,9,2,11,36,45,38,47,9,9,11,11,47,47,47,47,16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,36,47,38,47,36,47,38,47,45,47,47,47,47,47,47,47,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63},{16,16,18,18,16,16,18,18,24,24,26,26,24,24,26,26,16,16,18,18,16,16,18,18,24,24,26,26,24,24,26,26,48,48,50,50,48,48,50,50,56,56,58,58,56,56,58,58,48,48,50,50,48,48,50,50,56,56,58,58,56,56,58,58},{16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},{16,16,18,18,16,16,18,18,24,24,26,26,26,26,26,26,16,16,18,18,16,16,18,18,24,24,26,26,26,26,26,26,48,50,50,50,48,50,50,50,56,58,58,58,58,58,58,58,48,50,50,50,48,50,50,50,56,58,58,58,58,58,58,58},{16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63},{16,16,18,18,16,16,18,18,25,25,27,27,25,25,27,27,16,16,18,18,16,16,18,18,25,25,27,27,25,25,27,27,52,52,54,54,52,52,54,54,61,61,63,63,61,61,63,63,52,52,54,54,52,52,54,54,61,61,63,63,61,61,63,63},{16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63},{16,16,18,18,16,16,18,18,25,25,27,27,27,27,27,27,16,16,18,18,16,16,18,18,25,25,27,27,27,27,27,27,52,54,54,54,52,54,54,54,61,63,63,63,63,63,63,63,52,54,54,54,52,54,54,54,61,63,63,63,63,63,63,63},{16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63},{16,24,18,26,48,56,50,58,24,24,26,26,56,56,58,58,16,24,18,26,48,56,50,58,24,24,26,26,56,56,58,58,48,56,50,58,48,56,50,58,56,56,58,58,56,56,58,58,48,56,50,58,48,56,50,58,56,56,58,58,56,56,58,58},{16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63},{16,24,18,26,48,56,50,58,24,24,26,26,58,58,58,58,16,24,18,26,48,56,50,58,24,24,26,26,58,58,58,58,48,58,50,58,48,58,50,58,56,58,58,58,58,58,58,58,48,58,50,58,48,58,50,58,56,58,58,58,58,58,58,58},{16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63},{16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63},{16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63},{16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63},{16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63}};
int con1[16]={0,1,2,7,16,25,18,63,32,33,42,63,52,63,63,63};
int con2[64]={0,1,2,7,4,7,7,7,8,25,42,63,12,63,63,63,16,25,18,63,52,63,63,63,25,25,63,63,63,63,63,63,32,33,42,63,52,63,63,63,42,63,42,63,63,63,63,63,52,63,63,63,52,63,63,63,63,63,63,63,63,63,63,63};
int P[4]={32,8,4,1};
char ch[10];

struct seg_tree
{
    int l,r,val;
}seg[400010];

inline int read()
{
    int temp=0;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r)return;
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
}
inline void modify(int p,int pos)
{
    if(seg[p].l==seg[p].r)
    {
        int temp=lr[1][pos];
        temp&lt;&lt;=1;
        temp|=ud[pos];
        temp&lt;&lt;=1;
        temp|=ud[pos+1];
        temp&lt;&lt;=1;
        temp|=lr[2][pos];
        seg[p].val=con1[temp];
        return;
    }
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(pos&lt;=mid)
        modify(p&lt;&lt;1,pos);
    else
        modify(p&lt;&lt;1|1,pos);
    seg[p].val=calc[seg[p&lt;&lt;1].val][seg[p&lt;&lt;1|1].val];
}
inline int query(int p,int l,int r)
{
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p].val;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        return query(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            return query(p&lt;&lt;1|1,l,r);
        else
            return calc[query(p&lt;&lt;1,l,mid)][query(p&lt;&lt;1|1,mid+1,r)];
}

inline void change(int x1,int y1,int x2,int y2,int v)
{
    if(x1==x2)
    {
        int temp=Min(y1,y2);
        lr[x1][temp]=v;
        modify(1,temp);
    }
    else
    {
        ud[y1]=v;
        if(y1&gt;1)modify(1,y1-1);
        if(y1&lt;n)modify(1,y1);
    }
}

inline bool ask(int x1,int y1,int x2,int y2)
{
    if(x1==x2&amp;&amp;y1==y2)return true;
    if(y1==y2)
    {
        if(y1==1)return query(1,1,n-1)&amp;16;
        if(y1==n)return query(1,1,n-1)&amp;2;
        if(query(1,1,y1-1)&amp;2)
            return true;
        else
            return query(1,y1,n-1)&amp;16;
    }
    if(y1&gt;y2){Swap(x1,x2);Swap(y1,y2);}

    int temp=query(1,y1,y2-1);
    int p=P[((x1-1)&lt;&lt;1)|(x2-1)];
    if(temp&amp;p)return true;

    if((temp&amp;16)==0&amp;&amp;y1&gt;1)
        if(query(1,1,y1-1)&amp;2)
            temp|=16;
    if(con2[temp]&amp;p)return true;

    if((temp&amp;2)==0&amp;&amp;y2&lt;n)
        if(query(1,y2,n-1)&amp;16)
            temp|=2;
    return con2[temp]&amp;p;
}

int main()
{
    n=read();
    build(1,1,n-1);

    for(scanf("%s",ch);ch[0]!='E';scanf("%s",ch))
    {
        int x1,y1,x2,y2;
        x1=read();y1=read();x2=read();y2=read();
        if(ch[0]=='O')change(x1,y1,x2,y2,1);
        if(ch[0]=='C')change(x1,y1,x2,y2,0);
        if(ch[0]=='A')
            if(ask(x1,y1,x2,y2))
                printf("Y\n");
            else
                printf("N\n");
    }

    return 0;
}
<pre><h2>Problem1018</h2><pre>#include&lt;cstdio&gt;

int n;
int lr[3][100010],ud[100010],pl[100010];
int calc[64][64]={{0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2},{0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7},{0,0,2,2,0,0,2,2,0,0,2,2,2,2,2,2,0,0,2,2,0,0,2,2,0,0,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2},{0,1,2,3,4,5,6,7,0,1,2,3,6,7,6,7,0,1,2,3,4,5,6,7,0,1,2,3,6,7,6,7,0,3,2,3,4,7,6,7,0,3,2,3,6,7,6,7,0,3,2,3,4,7,6,7,0,3,2,3,6,7,6,7},{0,0,2,2,0,0,2,2,1,1,3,3,1,1,3,3,0,0,2,2,0,0,2,2,1,1,3,3,1,1,3,3,4,4,6,6,4,4,6,6,5,5,7,7,5,5,7,7,4,4,6,6,4,4,6,6,5,5,7,7,5,5,7,7},{0,1,2,3,4,5,6,7,1,1,3,3,5,5,7,7,0,1,2,3,4,5,6,7,1,1,3,3,5,5,7,7,4,5,6,7,4,5,6,7,5,5,7,7,5,5,7,7,4,5,6,7,4,5,6,7,5,5,7,7,5,5,7,7},{0,0,2,2,0,0,2,2,1,1,3,3,3,3,3,3,0,0,2,2,0,0,2,2,1,1,3,3,3,3,3,3,4,6,6,6,4,6,6,6,5,7,7,7,7,7,7,7,4,6,6,6,4,6,6,6,5,7,7,7,7,7,7,7},{0,1,2,3,4,5,6,7,1,1,3,3,7,7,7,7,0,1,2,3,4,5,6,7,1,1,3,3,7,7,7,7,4,7,6,7,4,7,6,7,5,7,7,7,7,7,7,7,4,7,6,7,4,7,6,7,5,7,7,7,7,7,7,7},{0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42},{0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47},{0,8,2,10,32,40,34,42,0,8,2,10,34,42,34,42,0,8,2,10,32,40,34,42,0,8,2,10,34,42,34,42,0,10,2,10,32,42,34,42,0,10,2,10,34,42,34,42,0,10,2,10,32,42,34,42,0,10,2,10,34,42,34,42},{0,9,2,11,36,45,38,47,0,9,2,11,38,47,38,47,0,9,2,11,36,45,38,47,0,9,2,11,38,47,38,47,0,11,2,11,36,47,38,47,0,11,2,11,38,47,38,47,0,11,2,11,36,47,38,47,0,11,2,11,38,47,38,47},{0,8,2,10,32,40,34,42,1,9,3,11,33,41,35,43,16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,4,12,6,14,36,44,38,46,5,13,7,15,37,45,39,47,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63},{0,9,2,11,36,45,38,47,1,9,3,11,37,45,39,47,16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,4,13,6,15,36,45,38,47,5,13,7,15,37,45,39,47,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63},{0,8,2,10,32,40,34,42,1,9,3,11,35,43,35,43,16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,4,14,6,14,36,46,38,46,5,15,7,15,39,47,39,47,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63},{0,9,2,11,36,45,38,47,1,9,3,11,39,47,39,47,16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,4,15,6,15,36,47,38,47,5,15,7,15,39,47,39,47,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63},{16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18},{16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23},{16,16,18,18,16,16,18,18,16,16,18,18,18,18,18,18,16,16,18,18,16,16,18,18,16,16,18,18,18,18,18,18,16,18,18,18,16,18,18,18,16,18,18,18,18,18,18,18,16,18,18,18,16,18,18,18,16,18,18,18,18,18,18,18},{16,17,18,19,20,21,22,23,16,17,18,19,22,23,22,23,16,17,18,19,20,21,22,23,16,17,18,19,22,23,22,23,16,19,18,19,20,23,22,23,16,19,18,19,22,23,22,23,16,19,18,19,20,23,22,23,16,19,18,19,22,23,22,23},{16,16,18,18,16,16,18,18,17,17,19,19,17,17,19,19,16,16,18,18,16,16,18,18,17,17,19,19,17,17,19,19,20,20,22,22,20,20,22,22,21,21,23,23,21,21,23,23,20,20,22,22,20,20,22,22,21,21,23,23,21,21,23,23},{16,17,18,19,20,21,22,23,17,17,19,19,21,21,23,23,16,17,18,19,20,21,22,23,17,17,19,19,21,21,23,23,20,21,22,23,20,21,22,23,21,21,23,23,21,21,23,23,20,21,22,23,20,21,22,23,21,21,23,23,21,21,23,23},{16,16,18,18,16,16,18,18,17,17,19,19,19,19,19,19,16,16,18,18,16,16,18,18,17,17,19,19,19,19,19,19,20,22,22,22,20,22,22,22,21,23,23,23,23,23,23,23,20,22,22,22,20,22,22,22,21,23,23,23,23,23,23,23},{16,17,18,19,20,21,22,23,17,17,19,19,23,23,23,23,16,17,18,19,20,21,22,23,17,17,19,19,23,23,23,23,20,23,22,23,20,23,22,23,21,23,23,23,23,23,23,23,20,23,22,23,20,23,22,23,21,23,23,23,23,23,23,23},{16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58},{16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63},{16,24,18,26,48,56,50,58,16,24,18,26,50,58,50,58,16,24,18,26,48,56,50,58,16,24,18,26,50,58,50,58,16,26,18,26,48,58,50,58,16,26,18,26,50,58,50,58,16,26,18,26,48,58,50,58,16,26,18,26,50,58,50,58},{16,25,18,27,52,61,54,63,16,25,18,27,54,63,54,63,16,25,18,27,52,61,54,63,16,25,18,27,54,63,54,63,16,27,18,27,52,63,54,63,16,27,18,27,54,63,54,63,16,27,18,27,52,63,54,63,16,27,18,27,54,63,54,63},{16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63},{16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63},{16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63},{16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63},{0,0,2,2,0,0,2,2,8,8,10,10,8,8,10,10,0,0,2,2,0,0,2,2,8,8,10,10,8,8,10,10,32,32,34,34,32,32,34,34,40,40,42,42,40,40,42,42,32,32,34,34,32,32,34,34,40,40,42,42,40,40,42,42},{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},{0,0,2,2,0,0,2,2,8,8,10,10,10,10,10,10,0,0,2,2,0,0,2,2,8,8,10,10,10,10,10,10,32,34,34,34,32,34,34,34,40,42,42,42,42,42,42,42,32,34,34,34,32,34,34,34,40,42,42,42,42,42,42,42},{0,1,2,3,4,5,6,7,8,9,10,11,14,15,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,32,35,34,35,36,39,38,39,40,43,42,43,46,47,46,47,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63},{0,0,2,2,0,0,2,2,9,9,11,11,9,9,11,11,0,0,2,2,0,0,2,2,9,9,11,11,9,9,11,11,36,36,38,38,36,36,38,38,45,45,47,47,45,45,47,47,36,36,38,38,36,36,38,38,45,45,47,47,45,45,47,47},{0,1,2,3,4,5,6,7,9,9,11,11,13,13,15,15,16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,36,37,38,39,36,37,38,39,45,45,47,47,45,45,47,47,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63},{0,0,2,2,0,0,2,2,9,9,11,11,11,11,11,11,0,0,2,2,0,0,2,2,9,9,11,11,11,11,11,11,36,38,38,38,36,38,38,38,45,47,47,47,47,47,47,47,36,38,38,38,36,38,38,38,45,47,47,47,47,47,47,47},{0,1,2,3,4,5,6,7,9,9,11,11,15,15,15,15,16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,36,39,38,39,36,39,38,39,45,47,47,47,47,47,47,47,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63},{0,8,2,10,32,40,34,42,8,8,10,10,40,40,42,42,0,8,2,10,32,40,34,42,8,8,10,10,40,40,42,42,32,40,34,42,32,40,34,42,40,40,42,42,40,40,42,42,32,40,34,42,32,40,34,42,40,40,42,42,40,40,42,42},{0,9,2,11,36,45,38,47,8,9,10,11,44,45,46,47,16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,32,41,34,43,36,45,38,47,40,41,42,43,44,45,46,47,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63},{0,8,2,10,32,40,34,42,8,8,10,10,42,42,42,42,0,8,2,10,32,40,34,42,8,8,10,10,42,42,42,42,32,42,34,42,32,42,34,42,40,42,42,42,42,42,42,42,32,42,34,42,32,42,34,42,40,42,42,42,42,42,42,42},{0,9,2,11,36,45,38,47,8,9,10,11,46,47,46,47,16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,32,43,34,43,36,47,38,47,40,43,42,43,46,47,46,47,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63},{0,8,2,10,32,40,34,42,9,9,11,11,41,41,43,43,16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,36,44,38,46,36,44,38,46,45,45,47,47,45,45,47,47,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63},{0,9,2,11,36,45,38,47,9,9,11,11,45,45,47,47,16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,36,45,38,47,36,45,38,47,45,45,47,47,45,45,47,47,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63},{0,8,2,10,32,40,34,42,9,9,11,11,43,43,43,43,16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,36,46,38,46,36,46,38,46,45,47,47,47,47,47,47,47,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63},{0,9,2,11,36,45,38,47,9,9,11,11,47,47,47,47,16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,36,47,38,47,36,47,38,47,45,47,47,47,47,47,47,47,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63},{16,16,18,18,16,16,18,18,24,24,26,26,24,24,26,26,16,16,18,18,16,16,18,18,24,24,26,26,24,24,26,26,48,48,50,50,48,48,50,50,56,56,58,58,56,56,58,58,48,48,50,50,48,48,50,50,56,56,58,58,56,56,58,58},{16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},{16,16,18,18,16,16,18,18,24,24,26,26,26,26,26,26,16,16,18,18,16,16,18,18,24,24,26,26,26,26,26,26,48,50,50,50,48,50,50,50,56,58,58,58,58,58,58,58,48,50,50,50,48,50,50,50,56,58,58,58,58,58,58,58},{16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63},{16,16,18,18,16,16,18,18,25,25,27,27,25,25,27,27,16,16,18,18,16,16,18,18,25,25,27,27,25,25,27,27,52,52,54,54,52,52,54,54,61,61,63,63,61,61,63,63,52,52,54,54,52,52,54,54,61,61,63,63,61,61,63,63},{16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63},{16,16,18,18,16,16,18,18,25,25,27,27,27,27,27,27,16,16,18,18,16,16,18,18,25,25,27,27,27,27,27,27,52,54,54,54,52,54,54,54,61,63,63,63,63,63,63,63,52,54,54,54,52,54,54,54,61,63,63,63,63,63,63,63},{16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63},{16,24,18,26,48,56,50,58,24,24,26,26,56,56,58,58,16,24,18,26,48,56,50,58,24,24,26,26,56,56,58,58,48,56,50,58,48,56,50,58,56,56,58,58,56,56,58,58,48,56,50,58,48,56,50,58,56,56,58,58,56,56,58,58},{16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63},{16,24,18,26,48,56,50,58,24,24,26,26,58,58,58,58,16,24,18,26,48,56,50,58,24,24,26,26,58,58,58,58,48,58,50,58,48,58,50,58,56,58,58,58,58,58,58,58,48,58,50,58,48,58,50,58,56,58,58,58,58,58,58,58},{16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63},{16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63},{16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63},{16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63},{16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63}};
int con1[16]={0,1,2,7,16,25,18,63,32,33,42,63,52,63,63,63};
int con2[64]={0,1,2,7,4,7,7,7,8,25,42,63,12,63,63,63,16,25,18,63,52,63,63,63,25,25,63,63,63,63,63,63,32,33,42,63,52,63,63,63,42,63,42,63,63,63,63,63,52,63,63,63,52,63,63,63,63,63,63,63,63,63,63,63};
int P[4]={32,8,4,1};
char ch[10];

struct seg_tree
{
    int l,r,val;
}seg[400010];

inline int read()
{
    int temp=0;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r){pl[l]=p;return;}
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
}
inline void modify(int pos)
{
    int p=pl[pos];
    int temp=lr[1][pos];
    temp&lt;&lt;=1;
    temp|=ud[pos];
    temp&lt;&lt;=1;
    temp|=ud[pos+1];
    temp&lt;&lt;=1;
    temp|=lr[2][pos];
    seg[p].val=con1[temp];

    p&gt;&gt;=1;
    while(p)
    {
        seg[p].val=calc[seg[p&lt;&lt;1].val][seg[p&lt;&lt;1|1].val];
        p&gt;&gt;=1;
    }
}
inline int query(int p,int l,int r)
{
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p].val;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        return query(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            return query(p&lt;&lt;1|1,l,r);
        else
            return calc[query(p&lt;&lt;1,l,mid)][query(p&lt;&lt;1|1,mid+1,r)];
}

inline void change(int x1,int y1,int x2,int y2,int v)
{
    if(x1==x2)
    {
        int temp=Min(y1,y2);
        lr[x1][temp]=v;
        modify(temp);
    }
    else
    {
        ud[y1]=v;
        if(y1&gt;1)modify(y1-1);
        if(y1&lt;n)modify(y1);
    }
}
inline bool ask(int x1,int y1,int x2,int y2)
{
    if(x1==x2&amp;&amp;y1==y2)return true;
    if(y1==y2)
    {
        if(ud[y1])return true;
        if(y1==1)return query(1,1,n-1)&amp;16;
        if(y1==n)return query(1,1,n-1)&amp;2;
        if(query(1,1,y1-1)&amp;2)
            return true;
        else
            return query(1,y1,n-1)&amp;16;
    }
    if(y1&gt;y2){Swap(x1,x2);Swap(y1,y2);}

    int temp=query(1,y1,y2-1);
    int p=P[((x1-1)&lt;&lt;1)|(x2-1)];
    if(temp&amp;p)return true;

    if(con2[temp|16|2]&amp;p)
    {
        bool flag1=true,flag2=true;
        if((con2[temp|16]&amp;p)&amp;&amp;y1&gt;1)
            if(query(1,1,y1-1)&amp;2)
                return true;
            else
                flag1=false;
        if((con2[temp|2]&amp;p)&amp;&amp;y2&lt;n)
            if(query(1,y2,n-1)&amp;16)
                return true;
            else
                flag2=false;

        if(y1&gt;1&amp;&amp;y2&lt;n&amp;&amp;flag1&amp;&amp;flag2)
            return (query(1,1,y1-1)&amp;2)&amp;&amp;(query(1,y2,n-1)&amp;16);
        else
            return false;
    }
    else
        return false;
}

int main()
{
    n=read();
    build(1,1,n-1);
    scanf("%s",ch);
    while(ch[0]!='E')
    {
        int x1,y1,x2,y2;
        x1=read();y1=read();x2=read();y2=read();
        if(ch[0]=='O')change(x1,y1,x2,y2,1);
        if(ch[0]=='C')change(x1,y1,x2,y2,0);
        if(ch[0]=='A')
            if(ask(x1,y1,x2,y2))
                puts("Y");
            else
                puts("N");
        scanf("%s",ch);
    }

    return 0;
}
<pre><h2>Problem1018</h2><pre>#include&lt;cstdio&gt;
 
int n;
int lr[3][100010],ud[100010],pl[100010];
int calc[64][64]={{0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2},{0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7},{0,0,2,2,0,0,2,2,0,0,2,2,2,2,2,2,0,0,2,2,0,0,2,2,0,0,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2},{0,1,2,3,4,5,6,7,0,1,2,3,6,7,6,7,0,1,2,3,4,5,6,7,0,1,2,3,6,7,6,7,0,3,2,3,4,7,6,7,0,3,2,3,6,7,6,7,0,3,2,3,4,7,6,7,0,3,2,3,6,7,6,7},{0,0,2,2,0,0,2,2,1,1,3,3,1,1,3,3,0,0,2,2,0,0,2,2,1,1,3,3,1,1,3,3,4,4,6,6,4,4,6,6,5,5,7,7,5,5,7,7,4,4,6,6,4,4,6,6,5,5,7,7,5,5,7,7},{0,1,2,3,4,5,6,7,1,1,3,3,5,5,7,7,0,1,2,3,4,5,6,7,1,1,3,3,5,5,7,7,4,5,6,7,4,5,6,7,5,5,7,7,5,5,7,7,4,5,6,7,4,5,6,7,5,5,7,7,5,5,7,7},{0,0,2,2,0,0,2,2,1,1,3,3,3,3,3,3,0,0,2,2,0,0,2,2,1,1,3,3,3,3,3,3,4,6,6,6,4,6,6,6,5,7,7,7,7,7,7,7,4,6,6,6,4,6,6,6,5,7,7,7,7,7,7,7},{0,1,2,3,4,5,6,7,1,1,3,3,7,7,7,7,0,1,2,3,4,5,6,7,1,1,3,3,7,7,7,7,4,7,6,7,4,7,6,7,5,7,7,7,7,7,7,7,4,7,6,7,4,7,6,7,5,7,7,7,7,7,7,7},{0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42,0,8,2,10,32,40,34,42},{0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47,0,9,2,11,36,45,38,47},{0,8,2,10,32,40,34,42,0,8,2,10,34,42,34,42,0,8,2,10,32,40,34,42,0,8,2,10,34,42,34,42,0,10,2,10,32,42,34,42,0,10,2,10,34,42,34,42,0,10,2,10,32,42,34,42,0,10,2,10,34,42,34,42},{0,9,2,11,36,45,38,47,0,9,2,11,38,47,38,47,0,9,2,11,36,45,38,47,0,9,2,11,38,47,38,47,0,11,2,11,36,47,38,47,0,11,2,11,38,47,38,47,0,11,2,11,36,47,38,47,0,11,2,11,38,47,38,47},{0,8,2,10,32,40,34,42,1,9,3,11,33,41,35,43,16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,4,12,6,14,36,44,38,46,5,13,7,15,37,45,39,47,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63},{0,9,2,11,36,45,38,47,1,9,3,11,37,45,39,47,16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,4,13,6,15,36,45,38,47,5,13,7,15,37,45,39,47,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63},{0,8,2,10,32,40,34,42,1,9,3,11,35,43,35,43,16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,4,14,6,14,36,46,38,46,5,15,7,15,39,47,39,47,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63},{0,9,2,11,36,45,38,47,1,9,3,11,39,47,39,47,16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,4,15,6,15,36,47,38,47,5,15,7,15,39,47,39,47,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63},{16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18,16,16,18,18},{16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23,16,17,18,19,20,21,22,23},{16,16,18,18,16,16,18,18,16,16,18,18,18,18,18,18,16,16,18,18,16,16,18,18,16,16,18,18,18,18,18,18,16,18,18,18,16,18,18,18,16,18,18,18,18,18,18,18,16,18,18,18,16,18,18,18,16,18,18,18,18,18,18,18},{16,17,18,19,20,21,22,23,16,17,18,19,22,23,22,23,16,17,18,19,20,21,22,23,16,17,18,19,22,23,22,23,16,19,18,19,20,23,22,23,16,19,18,19,22,23,22,23,16,19,18,19,20,23,22,23,16,19,18,19,22,23,22,23},{16,16,18,18,16,16,18,18,17,17,19,19,17,17,19,19,16,16,18,18,16,16,18,18,17,17,19,19,17,17,19,19,20,20,22,22,20,20,22,22,21,21,23,23,21,21,23,23,20,20,22,22,20,20,22,22,21,21,23,23,21,21,23,23},{16,17,18,19,20,21,22,23,17,17,19,19,21,21,23,23,16,17,18,19,20,21,22,23,17,17,19,19,21,21,23,23,20,21,22,23,20,21,22,23,21,21,23,23,21,21,23,23,20,21,22,23,20,21,22,23,21,21,23,23,21,21,23,23},{16,16,18,18,16,16,18,18,17,17,19,19,19,19,19,19,16,16,18,18,16,16,18,18,17,17,19,19,19,19,19,19,20,22,22,22,20,22,22,22,21,23,23,23,23,23,23,23,20,22,22,22,20,22,22,22,21,23,23,23,23,23,23,23},{16,17,18,19,20,21,22,23,17,17,19,19,23,23,23,23,16,17,18,19,20,21,22,23,17,17,19,19,23,23,23,23,20,23,22,23,20,23,22,23,21,23,23,23,23,23,23,23,20,23,22,23,20,23,22,23,21,23,23,23,23,23,23,23},{16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58,16,24,18,26,48,56,50,58},{16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63,16,25,18,27,52,61,54,63},{16,24,18,26,48,56,50,58,16,24,18,26,50,58,50,58,16,24,18,26,48,56,50,58,16,24,18,26,50,58,50,58,16,26,18,26,48,58,50,58,16,26,18,26,50,58,50,58,16,26,18,26,48,58,50,58,16,26,18,26,50,58,50,58},{16,25,18,27,52,61,54,63,16,25,18,27,54,63,54,63,16,25,18,27,52,61,54,63,16,25,18,27,54,63,54,63,16,27,18,27,52,63,54,63,16,27,18,27,54,63,54,63,16,27,18,27,52,63,54,63,16,27,18,27,54,63,54,63},{16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,16,24,18,26,48,56,50,58,17,25,19,27,49,57,51,59,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63,20,28,22,30,52,60,54,62,21,29,23,31,53,61,55,63},{16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,16,25,18,27,52,61,54,63,17,25,19,27,53,61,55,63,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63,20,29,22,31,52,61,54,63,21,29,23,31,53,61,55,63},{16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,16,24,18,26,48,56,50,58,17,25,19,27,51,59,51,59,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63,20,30,22,30,52,62,54,62,21,31,23,31,55,63,55,63},{16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,16,25,18,27,52,61,54,63,17,25,19,27,55,63,55,63,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63,20,31,22,31,52,63,54,63,21,31,23,31,55,63,55,63},{0,0,2,2,0,0,2,2,8,8,10,10,8,8,10,10,0,0,2,2,0,0,2,2,8,8,10,10,8,8,10,10,32,32,34,34,32,32,34,34,40,40,42,42,40,40,42,42,32,32,34,34,32,32,34,34,40,40,42,42,40,40,42,42},{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},{0,0,2,2,0,0,2,2,8,8,10,10,10,10,10,10,0,0,2,2,0,0,2,2,8,8,10,10,10,10,10,10,32,34,34,34,32,34,34,34,40,42,42,42,42,42,42,42,32,34,34,34,32,34,34,34,40,42,42,42,42,42,42,42},{0,1,2,3,4,5,6,7,8,9,10,11,14,15,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,32,35,34,35,36,39,38,39,40,43,42,43,46,47,46,47,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63},{0,0,2,2,0,0,2,2,9,9,11,11,9,9,11,11,0,0,2,2,0,0,2,2,9,9,11,11,9,9,11,11,36,36,38,38,36,36,38,38,45,45,47,47,45,45,47,47,36,36,38,38,36,36,38,38,45,45,47,47,45,45,47,47},{0,1,2,3,4,5,6,7,9,9,11,11,13,13,15,15,16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,36,37,38,39,36,37,38,39,45,45,47,47,45,45,47,47,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63},{0,0,2,2,0,0,2,2,9,9,11,11,11,11,11,11,0,0,2,2,0,0,2,2,9,9,11,11,11,11,11,11,36,38,38,38,36,38,38,38,45,47,47,47,47,47,47,47,36,38,38,38,36,38,38,38,45,47,47,47,47,47,47,47},{0,1,2,3,4,5,6,7,9,9,11,11,15,15,15,15,16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,36,39,38,39,36,39,38,39,45,47,47,47,47,47,47,47,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63},{0,8,2,10,32,40,34,42,8,8,10,10,40,40,42,42,0,8,2,10,32,40,34,42,8,8,10,10,40,40,42,42,32,40,34,42,32,40,34,42,40,40,42,42,40,40,42,42,32,40,34,42,32,40,34,42,40,40,42,42,40,40,42,42},{0,9,2,11,36,45,38,47,8,9,10,11,44,45,46,47,16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,32,41,34,43,36,45,38,47,40,41,42,43,44,45,46,47,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63},{0,8,2,10,32,40,34,42,8,8,10,10,42,42,42,42,0,8,2,10,32,40,34,42,8,8,10,10,42,42,42,42,32,42,34,42,32,42,34,42,40,42,42,42,42,42,42,42,32,42,34,42,32,42,34,42,40,42,42,42,42,42,42,42},{0,9,2,11,36,45,38,47,8,9,10,11,46,47,46,47,16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,32,43,34,43,36,47,38,47,40,43,42,43,46,47,46,47,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63},{0,8,2,10,32,40,34,42,9,9,11,11,41,41,43,43,16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,36,44,38,46,36,44,38,46,45,45,47,47,45,45,47,47,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63},{0,9,2,11,36,45,38,47,9,9,11,11,45,45,47,47,16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,36,45,38,47,36,45,38,47,45,45,47,47,45,45,47,47,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63},{0,8,2,10,32,40,34,42,9,9,11,11,43,43,43,43,16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,36,46,38,46,36,46,38,46,45,47,47,47,47,47,47,47,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63},{0,9,2,11,36,45,38,47,9,9,11,11,47,47,47,47,16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,36,47,38,47,36,47,38,47,45,47,47,47,47,47,47,47,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63},{16,16,18,18,16,16,18,18,24,24,26,26,24,24,26,26,16,16,18,18,16,16,18,18,24,24,26,26,24,24,26,26,48,48,50,50,48,48,50,50,56,56,58,58,56,56,58,58,48,48,50,50,48,48,50,50,56,56,58,58,56,56,58,58},{16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},{16,16,18,18,16,16,18,18,24,24,26,26,26,26,26,26,16,16,18,18,16,16,18,18,24,24,26,26,26,26,26,26,48,50,50,50,48,50,50,50,56,58,58,58,58,58,58,58,48,50,50,50,48,50,50,50,56,58,58,58,58,58,58,58},{16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,16,17,18,19,20,21,22,23,24,25,26,27,30,31,30,31,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63,48,51,50,51,52,55,54,55,56,59,58,59,62,63,62,63},{16,16,18,18,16,16,18,18,25,25,27,27,25,25,27,27,16,16,18,18,16,16,18,18,25,25,27,27,25,25,27,27,52,52,54,54,52,52,54,54,61,61,63,63,61,61,63,63,52,52,54,54,52,52,54,54,61,61,63,63,61,61,63,63},{16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,16,17,18,19,20,21,22,23,25,25,27,27,29,29,31,31,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63,52,53,54,55,52,53,54,55,61,61,63,63,61,61,63,63},{16,16,18,18,16,16,18,18,25,25,27,27,27,27,27,27,16,16,18,18,16,16,18,18,25,25,27,27,27,27,27,27,52,54,54,54,52,54,54,54,61,63,63,63,63,63,63,63,52,54,54,54,52,54,54,54,61,63,63,63,63,63,63,63},{16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,16,17,18,19,20,21,22,23,25,25,27,27,31,31,31,31,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63,52,55,54,55,52,55,54,55,61,63,63,63,63,63,63,63},{16,24,18,26,48,56,50,58,24,24,26,26,56,56,58,58,16,24,18,26,48,56,50,58,24,24,26,26,56,56,58,58,48,56,50,58,48,56,50,58,56,56,58,58,56,56,58,58,48,56,50,58,48,56,50,58,56,56,58,58,56,56,58,58},{16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,16,25,18,27,52,61,54,63,24,25,26,27,60,61,62,63,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63,48,57,50,59,52,61,54,63,56,57,58,59,60,61,62,63},{16,24,18,26,48,56,50,58,24,24,26,26,58,58,58,58,16,24,18,26,48,56,50,58,24,24,26,26,58,58,58,58,48,58,50,58,48,58,50,58,56,58,58,58,58,58,58,58,48,58,50,58,48,58,50,58,56,58,58,58,58,58,58,58},{16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,16,25,18,27,52,61,54,63,24,25,26,27,62,63,62,63,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63,48,59,50,59,52,63,54,63,56,59,58,59,62,63,62,63},{16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,16,24,18,26,48,56,50,58,25,25,27,27,57,57,59,59,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63,52,60,54,62,52,60,54,62,61,61,63,63,61,61,63,63},{16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,16,25,18,27,52,61,54,63,25,25,27,27,61,61,63,63,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63,52,61,54,63,52,61,54,63,61,61,63,63,61,61,63,63},{16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,16,24,18,26,48,56,50,58,25,25,27,27,59,59,59,59,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63,52,62,54,62,52,62,54,62,61,63,63,63,63,63,63,63},{16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,16,25,18,27,52,61,54,63,25,25,27,27,63,63,63,63,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63,52,63,54,63,52,63,54,63,61,63,63,63,63,63,63,63}};
int con1[16]={0,1,2,7,16,25,18,63,32,33,42,63,52,63,63,63};
int con2[64]={0,1,2,7,4,7,7,7,8,25,42,63,12,63,63,63,16,25,18,63,52,63,63,63,25,25,63,63,63,63,63,63,32,33,42,63,52,63,63,63,42,63,42,63,63,63,63,63,52,63,63,63,52,63,63,63,63,63,63,63,63,63,63,63};
int P[4]={32,8,4,1};
char ch[10];
 
struct seg_tree
{
    int l,r,val;
}seg[400010];
 
inline int read()
{
    int temp=0;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}
 
inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r){pl[l]=p;return;}
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
}
inline void modify(int pos)
{
    int p=pl[pos];
    int temp=lr[1][pos];
    temp&lt;&lt;=1;
    temp|=ud[pos];
    temp&lt;&lt;=1;
    temp|=ud[pos+1];
    temp&lt;&lt;=1;
    temp|=lr[2][pos];
    seg[p].val=con1[temp];
 
    p&gt;&gt;=1;
    while(p)
    {
        seg[p].val=calc[seg[p&lt;&lt;1].val][seg[p&lt;&lt;1|1].val];
        p&gt;&gt;=1;
    }
}
inline int query(int p,int l,int r)
{
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p].val;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        return query(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            return query(p&lt;&lt;1|1,l,r);
        else
            return calc[query(p&lt;&lt;1,l,mid)][query(p&lt;&lt;1|1,mid+1,r)];
}
 
inline void change(int x1,int y1,int x2,int y2,int v)
{
    if(x1==x2)
    {
        int temp=Min(y1,y2);
        lr[x1][temp]=v;
        modify(temp);
    }
    else
    {
        ud[y1]=v;
        if(y1&gt;1)modify(y1-1);
        if(y1&lt;n)modify(y1);
    }
}
inline bool ask(int x1,int y1,int x2,int y2)
{
    if(x1==x2&amp;&amp;y1==y2)return true;
    if(y1==y2)
    {
        if(ud[y1])return true;
        if(y1==1)return query(1,1,n-1)&amp;16;
        if(y1==n)return query(1,1,n-1)&amp;2;
        if(query(1,1,y1-1)&amp;2)
            return true;
        else
            return query(1,y1,n-1)&amp;16;
    }
    if(y1&gt;y2){Swap(x1,x2);Swap(y1,y2);}
 
    int temp=query(1,y1,y2-1);
    int p=P[((x1-1)&lt;&lt;1)|(x2-1)];
    if(temp&amp;p)return true;
 
    if(con2[temp|16|2]&amp;p)
    {
        bool flag1=true,flag2=true;
        if((con2[temp|16]&amp;p)&amp;&amp;y1&gt;1)
            if(query(1,1,y1-1)&amp;2)
                return true;
            else
                flag1=false;
        if((con2[temp|2]&amp;p)&amp;&amp;y2&lt;n)
            if(query(1,y2,n-1)&amp;16)
                return true;
            else
                flag2=false;
 
        if(y1&gt;1&amp;&amp;y2&lt;n&amp;&amp;flag1&amp;&amp;flag2)
            return (query(1,1,y1-1)&amp;2)&amp;&amp;(query(1,y2,n-1)&amp;16);
        else
            return false;
    }
    else
        return false;
}
 
int main()
{
    n=read();
    build(1,1,n-1);
    scanf("%s",ch);
    while(ch[0]!='E')
    {
        int x1,y1,x2,y2;
        x1=read();y1=read();x2=read();y2=read();
        if(ch[0]=='O')change(x1,y1,x2,y2,1);
        if(ch[0]=='C')change(x1,y1,x2,y2,0);
        if(ch[0]=='A')
            if(ask(x1,y1,x2,y2))
                puts("Y");
            else
                puts("N");
        scanf("%s",ch);
    }
 
    return 0;
}<pre><h2>Problem1019</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

int n;
short Q[3][35];
short opt[6][2];
long long f[35];

long long solve(int n)
{
    short lm,x,y;
    long long ans;
    ans=0;
    for(short i=1;i&lt;=n;++i)
		Q[0][i]=n-i+1; 
	
	Q[0][0]=n;
    Q[1][0]=0;
	Q[2][0]=0;
    
	lm=-1;
    while(1)
	{
		++ans;
      	for(short i=0;i&lt;6;++i)
	  	{
        	x=opt[i][0];
			y=opt[i][1];
        	if(x!=lm&amp;&amp;Q[x][0]!=0&amp;&amp;(Q[y][0]==0||Q[x][Q[x][0]]&lt;Q[y][Q[y][0]]))
			{
          		lm=y;
          		Q[y][++Q[y][0]]=Q[x][Q[x][0]--];
          		break;
        	}
      	}
      	
		if(Q[1][0]==n||Q[2][0]==n)
			break;
    }
    
	return ans;
}

int main()
{
	char ch;
	long long A,B;
	
	scanf("%d",&amp;n);
	
	for(short i=0;i&lt;6;++i)
	{
    	ch=getchar();
    	while(ch&lt;'A'||ch&gt;'C')ch=getchar();
    	
    	opt[i][0]=ch-65;
    	opt[i][1]=getchar()-65;
	}
	
	if(n&lt;=5)
		printf("%lld\n",solve(n));
  	else
	{
    	for(short i=3;i&lt;=5;++i)
			f[i]=solve(i);
		
		A=(f[5]-f[4])/(f[4]-f[3]);
		
		B=f[4]-A*f[3];
    	
		for(short i=6;i&lt;=n;++i)
			f[i]=A*f[i-1]+B;
    	
		printf("%lld\n",f[n]);
	}
	
	return 0;
}<pre><h2>Problem1019</h2><pre>#include&lt;cstdio&gt;

int n;
short Q[3][35];
short opt[6][2];
long long f[35];

long long solve(int n)
{
    short lm,x,y;
    long long ans;
    ans=0;
    for(short i=1;i&lt;=n;++i)
		Q[0][i]=n-i+1; 
	
	Q[0][0]=n;
    Q[1][0]=0;
	Q[2][0]=0;
    
	lm=-1;
    while(1)
	{
		++ans;
      	for(short i=0;i&lt;6;++i)
	  	{
        	x=opt[i][0];
			y=opt[i][1];
        	if(x!=lm&amp;&amp;Q[x][0]!=0&amp;&amp;(Q[y][0]==0||Q[x][Q[x][0]]&lt;Q[y][Q[y][0]]))
			{
          		lm=y;
          		Q[y][++Q[y][0]]=Q[x][Q[x][0]--];
          		break;
        	}
      	}
      	
		if(Q[1][0]==n||Q[2][0]==n)
			break;
    }
    
	return ans;
}

int main()
{
	char ch;
	long long A,B;
	
	scanf("%d",&amp;n);
	
	for(short i=0;i&lt;6;++i)
	{
    	ch=getchar();
    	while(ch&lt;'A'||ch&gt;'C')ch=getchar();
    	
    	opt[i][0]=ch-65;
    	opt[i][1]=getchar()-65;
	}
	
	if(n&lt;=5)
		printf("%lld\n",solve(n));
  	else
	{
    	for(short i=3;i&lt;=5;++i)
			f[i]=solve(i);
		
		A=(f[5]-f[4])/(f[4]-f[3]);
		
		B=f[4]-A*f[3];
    	
		for(short i=6;i&lt;=n;++i)
			f[i]=A*f[i-1]+B;
    	
		printf("%lld\n",f[n]);
	}
	
	return 0;
}<pre><h2>Problem1022</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,t,x;

int main()
{
	scanf("%d",&amp;t);
	for(;t;t--)
	{
		bool flag=false;
		int sg=0;
		scanf("%d",&amp;n);
		for(;n;n--)
		{
			scanf("%d",&amp;x);
			sg^=x;
			flag|=(x!=1);
		}
		if((flag&amp;&amp;sg!=0)||(!flag&amp;&amp;sg==0))
			printf("John\n");
		else
			printf("Brother\n");
	}
	
	return 0;
}<pre><h2>Problem1024</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

double search(double x,double y,int c)
{
	if(x&gt;y)
		swap(x,y);
	
	if(c==1)
		return y/x;
	
	double ans=1e20,r=1.0/c;
	
	for(int i=1;i&lt;c;i++)
		ans=min(ans,min(max(search(x*r*i,y,i),search(x-x*r*i,y,c-i)),max(search(x,y*r*i,i),search(x,y-y*r*i,c-i))));
	
	return ans;
}

int main()
{
	int x,y,n;
	
	scanf("%d%d%d",&amp;x,&amp;y,&amp;n);
	
	printf("%0.6lf",search((double)x,(double)y,n));
	
	return 0;
}<pre><h2>Problem1026</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int a[15];
int f[15][15];
int aa,bb;

inline int abs(int x)
{
    return x&lt;0?-x:x;
}

int getlen(int x)
{
    int re=0;
    while(x)
		a[++re]=x%10,x/=10;
    return re;
}

int calc(int x)
{
    int re=0;
    for(int i=1;i&lt;x;i++)
    	for(int j=1;j&lt;10;j++)
			re+=f[i][j];
    for(int i=1;i&lt;a[x];i++)
		re+=f[x][i];
    for(int i=x-1;i;i--)
    {
        for(int j=0;j&lt;a[i];j++)
        	if(abs(a[i+1]-j)&gt;1)
				re+=f[i][j];
        if(abs(a[i+1]-a[i])&lt;2)break;
    }
    return re;
}

int main()
{
    for(int i=0;i&lt;=9;i++)f[1][i]=1;
    
    for(int i=2;i&lt;=12;i++)
    	for(int j=0;j&lt;=9;j++)
    		for(int k=0;k&lt;=9;k++)
    			if(abs(j-k)&gt;1)
					f[i][j]+=f[i-1][k];
	
    scanf("%d%d",&amp;aa,&amp;bb);
    
    printf("%d\n",calc(getlen(bb+1))-calc(getlen(aa)));
    
    return 0;
}
<pre><h2>Problem1029</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;

using namespace std;

struct size
{
   int t1,t2;
}a[150010];

int n,tot,sum;

priority_queue&lt;int&gt; que;

inline bool cmp(size a,size b)
{
	return a.t2&lt;b.t2;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;a[i].t1,&amp;a[i].t2);
	
	sort(a+1,a+1+n,cmp);
	
	for(int i=1;i&lt;=n;i++)
		if(a[i].t1+tot&gt;a[i].t2)
		{
			if(!sum)continue;
			
			if(que.top()&gt;a[i].t1)
			{
				tot=tot-que.top()+a[i].t1;
				que.pop();
				que.push(a[i].t1);
	    	}
	    }
		else 
		{
			que.push(a[i].t1);
			tot+=a[i].t1;
			sum++;
		}
   
	printf("%d\n",sum);
   
	return 0;
}<pre><h2>Problem1030</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

using namespace std;

const int P=10007;

int n,m,sz=1;
int fail[6010],q[6010];
int next[6010][26];
int f[2][6010][110];
char str[110];
bool v[6010];

inline void insert()
{
    int now=1;
    int len=strlen(str);
    for(int i=1;i&lt;=len;i++)
    {
        int j=str[i-1]-'A';
        if(!next[now][j])next[now][j]=++sz;
        now=next[now][j];
    }
    v[now]=true;
}

inline void build()
{
    int h=1,t=0;

    for(int i=0;i&lt;26;i++)
        if(next[1][i])
    {
        fail[next[1][i]]=1;
        q[++t]=next[1][i];
    }
    else
        next[1][i]=1;

    while(h&lt;=t)
    {
        int x=q[h++];

        for(int i=0;i&lt;26;i++)
        {
            if(next[x][i])
            {
                fail[next[x][i]]=next[fail[x]][i];
                v[next[x][i]]|=v[next[fail[x]][i]];
                q[++t]=next[x][i];
            }
            else
                next[x][i]=next[fail[x]][i];
        }
    }
}

inline void dp()
{
    f[0][1][0]=1;

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=sz;j++)
            for(int k=0;k&lt;26;k++)
                if(v[next[j][k]])
                    f[1][next[j][k]][i]=(f[1][next[j][k]][i]+f[0][j][i-1]+f[1][j][i-1])%P;
                else
                {
                    f[0][next[j][k]][i]=(f[0][next[j][k]][i]+f[0][j][i-1])%P;
                    f[1][next[j][k]][i]=(f[1][next[j][k]][i]+f[1][j][i-1])%P;
                }
}

int main()
{
    scanf("%d%d",&amp;m,&amp;n);
    for(int i=1;i&lt;=m;i++)
    {
        scanf("%s",str);
        insert();
    }
    build();
    
    dp();

    int ans=0;
    for(int i=1;i&lt;=sz;i++)
        ans=(ans+f[1][i][n])%P;

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

using namespace std;

char A[200010];
int n, ta[200010],tb[200010],sa[200010];
int *x=ta,*y=tb,m;

inline void Sort()
{
    static int w[200010];

    for(int i=0;i&lt;m;i++)
        w[i]=0;

    for(int i=0;i&lt;n;i++)
        w[x[y[i]]]++;

    for(int i=0;i&lt;m-1;i++)
        w[i+1]+=w[i];

    for(int i=n-1;i&gt;=0;i--)
        sa[--w[x[y[i]]]] = y[i];
}

inline bool cmp(int a,int b,int l)
{
    return (y[a]==y[b]&amp;&amp;y[a + l]==y[b + l]);
}

void DA()
{
    for(int i=0;i&lt;n;i++)
    {
        x[i]=A[i];
        y[i]=i;
    }
    Sort();

    int i,j,p;
    for (j=1,p=1;p&lt;n;j*=2,m=p)
    {
        for(p=0,i=n-j;i&lt;n;i++)
            y[p++]=i;

        for(int k=0;k&lt;n;k++)
            if(sa[k]&gt;=j)
                y[p++]=sa[k]-j;
        Sort();

        for(swap(x, y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
            x[sa[i]]=cmp(sa[i],sa[i-1],j)?p-1:p++;
    }
}

int main()
{
    gets(A);
    m=256;
    n=strlen(A);
    for(int i=0;i&lt;n;i++)
        A[n + i]=A[i];
    n+=n-1;
    A[n++]=0;

    DA();

    m=n/2;
    for(int i=0;i&lt;n;i++)
        if (sa[i]&lt;m)
            printf("%c",A[sa[i]+m-1]);
    printf("\n");

    return 0;
}
<pre><h2>Problem1034</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,ans;
int a[100010],b[100010];

inline void calc_max()
{
    int h1=1,t1=n,h2=1,t2=n;

    while(h1&lt;=t1)
    {
        if(a[h1]&gt;b[h2])
        {
            ans++;
            h1++;
            h2++;
            continue;
        }
        if(a[t1]&gt;b[t2])
        {
            ans++;
            t1--;
            t2--;
            continue;
        }

        ans--;
        if(a[h1]==b[t2])ans++;
        h1++;
        t2--;

    }
}

inline void calc_min()
{
    int h1=1,t1=n,h2=1,t2=n;

    while(h1&lt;=t1)
    {
        if(b[h1]&gt;a[h2])
        {
            ans--;
            h1++;
            h2++;
            continue;
        }
        if(b[t1]&gt;a[t2])
        {
            ans--;
            t1--;
            t2--;
            continue;
        }

        ans++;
        if(b[h1]==a[t2])ans--;
        h1++;
        t2--;
    }
}

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
        scanf("%d",a+i);
    for(int i=1;i&lt;=n;i++)
        scanf("%d",b+i);

    sort(a+1,a+n+1);
    sort(b+1,b+n+1);

    ans=n;
    calc_max();
    printf("%d ",ans);
    ans=n;
    calc_min();
    printf("%d\n",ans);

    return 0;
}<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const int inf=1e9;

int n,m,lim;
int dep[30010],fa[30010],value[30010];
int blockroot[30010],siz[30010];
int vsum[30010],vmax[30010];

struct size
{
	int ch;
	size *next;
}*tr[30010],*tr1[30010];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=tr[x];
	tr[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;next=tr[y];
	tr[y]=p;
}

inline void add_edge1(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=tr1[x];
	tr1[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;next=tr1[y];
	tr1[y]=p;
}

void dfs(int x,int f,int depth)
{
	dep[x]=depth;
	fa[x]=f;
	int cur=blockroot[x];
	
	for(size *p=tr[x];p!=NULL;p=p-&gt;next)
		if(p-&gt;ch!=f)
		{
			if(siz[cur]&lt;lim)
			{
				add_edge1(x,p-&gt;ch);
				++siz[cur];
				blockroot[p-&gt;ch]=cur;
			}
			dfs(p-&gt;ch,x,depth+1);
		}
}

void init(int x,int sum,int ma)
{	
	vsum[x]=sum+value[x];
	vmax[x]=max(ma,value[x]);
	
	for(size *p=tr1[x];p!=NULL;p=p-&gt;next)
		if(p-&gt;ch!=fa[x])
			init(p-&gt;ch,vsum[x],vmax[x]);
}

inline void change(int x,int y)
{
	value[x]=y;
	
	if(blockroot[x]!=x)
		init(x,vsum[fa[x]],vmax[fa[x]]);
	else
		init(x,0,-inf);
}

inline int querymax(int x,int y)
{
	int temp=-inf;
	
	while(x!=y)
	{
		if(blockroot[x]==blockroot[y])
		{
			if(dep[x]&lt;dep[y])
			{
				temp=max(temp,value[y]);
				y=fa[y];
			}
			else
			{
				temp=max(temp,value[x]);
				x=fa[x];
			}
		}
		else
		{
			if(dep[blockroot[x]]&lt;dep[blockroot[y]])
			{
				temp=max(temp,vmax[y]);
				y=fa[blockroot[y]];
			}
			else
			{
				temp=max(temp,vmax[x]);
				x=fa[blockroot[x]];
			}
		}
	}
	temp=max(temp,value[x]);
	
	return temp;
}

inline int querysum(int x,int y)
{
	int temp=0;
	
	while(x!=y)
	{
		if(blockroot[x]==blockroot[y])
		{
			if(dep[x]&lt;dep[y])
			{
				temp+=value[y];
				y=fa[y];
			}
			else
			{
				temp+=value[x];
				x=fa[x];
			}
		}
		else
		{
			if(dep[blockroot[x]]&lt;dep[blockroot[y]])
			{
				temp+=vsum[y];
				y=fa[blockroot[y]];
			}
			else
			{
				temp+=vsum[x];
				x=fa[blockroot[x]];
			}
		}
	}
	
	return temp+value[x];
}

int main()
{
	scanf("%d",&amp;n);
	
	lim=(int)sqrt(n);
	
	int x,y;
	
	for(int i=1;i&lt;n;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(x,y);
	}
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",value+i);
		blockroot[i]=i;
	}
	
	dfs(1,0,0);
	
	for(int i=1;i&lt;=n;i++)
		if(i==blockroot[i])
			init(i,0,-inf);
	
	scanf("%d",&amp;m);
	
	char str[20];
	
	for(;m;m--)
	{
		scanf("%s%d%d",str,&amp;x,&amp;y);
		if(str[1]=='H')
			change(x,y);
		else
			if(str[1]=='M')
				printf("%d\n",querymax(x,y));
			else
				printf("%d\n",querysum(x,y));
	}
	
	return 0;
}<pre><h2>Problem1038</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

#define INF 1e12
const double EPS=1e-7;

struct size
{
    double x,y;
}p[310],tp[310],s[310];

int n,m;

inline size operator +(size a,size b)
{
    a.x+=b.x;
    a.y+=b.y;
    return a;
}

inline size operator -(size a,size b)
{
    a.x-=b.x; a.y-=b.y;
    return a;
}

inline size operator *(size a,double k)
{
    a.x*=k; a.y*=k;
    return a;
}

inline size operator /(size a,double k)
{
    a.x/=k; a.y/=k;
    return a;
}

inline int dc(double x)
{
    if(x&gt;EPS) return 1;
    else if(x&lt;-EPS) return -1;
    return 0;
}

inline double cross(const size &amp;a,const size &amp;b,const size &amp;c)
{
    return (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);
}

inline double dot(const size &amp;a,const size &amp;b,const size &amp;c)
{
    return (b.x-a.x)*(c.x-a.x)+(b.y-a.y)*(c.y-a.y);
}

inline size getpoint(const size &amp;a,const size &amp;b,const size &amp;c,const size &amp;d)
{
    double k1=cross(a,d,c),k2=cross(b,c,d);
    return a+(b-a)*k1/(k1+k2);
}

inline bool onseg(const size &amp;a,const size &amp;b,const size &amp;c)
{
    if(dc(dot(a,b,c))&lt;=0) return true;
    return false;
}

int main()
{

    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;p[i].x);
    for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;p[i].y);

    tp[1].x=tp[5].x=-INF; tp[1].y=tp[5].y=-INF;
    tp[2].x=INF,tp[2].y=-INF;
    tp[3].x=INF,tp[3].y=INF;
    tp[4].x=-INF,tp[4].y=INF;
    int cp=4,tc;
    for(int i=1;i&lt;n;i++)
    {
        tc=0;
        for(int j=1;j&lt;=cp;j++)
        {
            if(dc(cross(p[i],p[i+1],tp[j]))&gt;=0) s[++tc]=tp[j];
            if(dc(cross(p[i],p[i+1],tp[j])*cross(p[i],p[i+1],tp[j+1]))&lt;0)
                s[++tc]=getpoint(p[i],p[i+1],tp[j],tp[j+1]);
        }
        s[tc+1]=s[1];
        for(int j=1;j&lt;=tc+1;j++) tp[j]=s[j];
        cp=tc;
    }
    m=cp;

    double ans=INF;
    size s1,t1,jd;
    for(int i=1;i&lt;=n;i++)
    {
        s1=p[i]; t1.x=s1.x,t1.y=520.1314;
        for(int j=1;j&lt;=m;j++)
        {
            jd=getpoint(s1,t1,s[j],s[j+1]);
            if(onseg(jd,s[j],s[j+1]))
                ans=min(ans,jd.y-p[i].y);
        }
    }
    for(int i=1;i&lt;=m;i++)
    {
        s1=s[i]; t1.x=s[i].x; t1.y=520.1314;
        for(int j=1;j&lt;n;j++)
        {
            jd=getpoint(s1,t1,p[j],p[j+1]);
            if(onseg(jd,p[j],p[j+1]))
                ans=min(ans,s[i].y-jd.y);
        }
    }

    printf("%.3lf\n",ans);

    return 0;
}
<pre><h2>Problem1043</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;

using namespace std;

const double PI=acos(-1);
const double PI2=2*PI;
const double eps=1e-13;

int n;
double ans=0.0;
struct Circle
{
    double r,x,y;
}c[1010];
struct Rad
{
    double l,r;
    inline Rad():l(0.0),r(0.0){}
    inline Rad(const double&amp;x,const double&amp;y):l(x),r(y){}
    inline friend bool operator&lt;(const Rad&amp;x,const Rad&amp;y)
    {
        return y.l&lt;x.l;
    }
};
priority_queue&lt;Rad&gt;q;
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline double sqr(const double&amp;x)
{
    return x*x;
}
inline double dabs(const double&amp;x)
{
    return x&lt;0.0?-x:x;
}
inline double dmax(const double&amp;x,const double&amp;y)
{
    return x&gt;y?x:y;
}
inline void Clear()
{
    while(!q.empty())q.pop();
}
inline bool Equal(const double&amp;x,const double&amp;y)
{
    return dabs(x-y)&lt;=eps;
}

inline int judge(const int&amp;x,const int&amp;y)
{
    double dist1=(double)sqrt(sqr(c[x].x-c[y].x)+sqr(c[x].y-c[y].y));
    double dist2=c[x].r+c[y].r;
    if(dist1&gt;=dist2)return 0;//waili
    dist2=dabs(c[x].r-c[y].r);
    if(dist1&lt;=dist2)//neihan
        if(c[y].r&gt;=c[x].r)
            return 2;
        else
            return 0;
    return 1;
}

inline void calc_arc(const int&amp;x,const int&amp;y)
{
    double A=c[x].r;
    double sqrB=sqr(c[x].x-c[y].x)+sqr(c[x].y-c[y].y);
    double B=(double)sqrt(sqrB);
    double C=c[y].r;

    double rad_c=acos((double)(A*A+sqrB-C*C)/2.0/A/B);

    double rad_m=acos((double)(c[y].x-c[x].x)/B);
    if(c[y].y&lt;c[x].y)rad_m=2*PI-rad_m;

    double rad_l=rad_m-rad_c,rad_r=rad_m+rad_c;
    if(rad_l&lt;0.0)
    {
        q.push(Rad(rad_l+PI2,PI2));
        rad_l=0.0;
    }
    if(rad_r&gt;PI2)
    {
        q.push(Rad(0.0,rad_r-PI2));
        rad_r=PI2;
    }
    q.push(Rad(rad_l,rad_r));
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
        scanf("%lf%lf%lf",&amp;c[i].r,&amp;c[i].x,&amp;c[i].y);

    for(int i=1;i&lt;=n;i++)
    {
        Clear();
        for(int j=i+1;j&lt;=n;j++)
        {
            int temp=judge(i,j);
            if(temp==0)continue;
            if(temp==2)
            {
                Clear();
                q.push(Rad(0.0,PI2));
                break;
            }
            calc_arc(i,j);
        }
        q.push(Rad(PI2,PI2));
        double last_pos=0.0,out=0.0;
        while(!q.empty()&amp;&amp;!Equal(last_pos,PI2))
        {
            if(q.top().l&gt;last_pos)out+=q.top().l-last_pos;
            last_pos=dmax(last_pos,q.top().r);
            q.pop();
        }
        ans+=(double)out*c[i].r;
    }
    printf("%.3lf\n",ans);
    return 0;
}
<pre><h2>Problem1045</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,now;
int a[1000010],p[1000010];
long long ans,tot;

inline int abs(int x)
{
	return x&lt;0?-x:x;
}

int main()
{
    scanf("%d",&amp;n);
    
    for(int i=0;i&lt;n;i++)
	{
		scanf("%d",a+i);
		tot+=a[i];
	}
	
    tot/=n;
    for(int i=1;i&lt;n;i++)
		p[i]=p[i-1]+tot-a[i];
    sort(p,p+n);
    
    now=p[n&gt;&gt;1];
    for (int i=0;i&lt;n;i++)
		ans+=abs(p[i]-now);
    printf("%lld\n",ans);
    
    return 0;
}<pre><h2>Problem1047</h2><pre>#include&lt;cstdio&gt;

using namespace std;
const int inf=2147483647;

int n,m,kk,h1,h2,ans=inf;
int num[1010][1010],a[1010][1010],a1[1010][1010],b[1010][1010],b1[1010][1010];
int ha[1010],hb[1010],ma[1010],ma1[1010],mi[1010],mi1[1010];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void calca(int x,int y,int num)
{
	while(a[y][a[y][0]]&lt;=num&amp;&amp;a[y][0]&gt;=ha[y])a[y][0]--;
	a[y][++a[y][0]]=num;
	a1[y][a[y][0]]=x;
	
	while(b[y][b[y][0]]&gt;=num&amp;&amp;b[y][0]&gt;=hb[y])b[y][0]--;
	b[y][++b[y][0]]=num;
	b1[y][b[y][0]]=x;
	
	while(a1[y][ha[y]]&lt;=x-kk)ha[y]++;
	while(b1[y][hb[y]]&lt;=x-kk)hb[y]++;
}

inline void calcb(int y)
{
	while(ma[ma[0]]&lt;=a[y][ha[y]]&amp;&amp;ma[0]&gt;=h1)ma[0]--;
	ma[++ma[0]]=a[y][ha[y]];
	ma1[ma[0]]=y;
	
	while(mi[mi[0]]&gt;=b[y][hb[y]]&amp;&amp;mi[0]&gt;=h2)mi[0]--;
	mi[++mi[0]]=b[y][hb[y]];
	mi1[mi[0]]=y;
	
	while(ma1[h1]&lt;=y-kk)h1++;
	while(mi1[h2]&lt;=y-kk)h2++;
}

inline void update(int &amp;ans)
{
	ans=min(ans,ma[h1]-mi[h2]);
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;kk);
	
	for(int i=1;i&lt;=n;i++)
	  for(int j=1;j&lt;=m;j++)
	    scanf("%d",&amp;num[i][j]);
	
	for(int i=1;i&lt;=m;i++)
		a[i][1]=b[i][1]=num[1][i],a[i][0]=b[i][0]=ha[i]=hb[i]=a1[i][1]=b1[i][1]=1;
	
	for(int i=1;i&lt;=n;i++)
	{
		calca(i,1,num[i][1]);
		
		if(i&gt;=kk)
		{
			ma[1]=a[1][ha[1]];
			
			h1=ma[0]=ma1[1]=h2=mi[0]=mi1[1]=1;
			
			mi[1]=b[1][hb[1]];
			
			if(kk&lt;=1)update(ans);
		}
		
		for(int j=2;j&lt;=m;j++)
		{
	  		calca(i,j,num[i][j]);
	  	
	  		if(i&gt;=kk)
			{
		  		calcb(j);
		  		if(j&gt;=kk)update(ans);
		  	}
		}
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1050</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,s,t;
int fa[510];

struct size
{
	int x,y,c;
}edge[5010];

inline bool cmp(size a,size b)
{
	return a.c&lt;b.c;
}

int find(int x)
{
	return fa[x]=x==fa[x]?x:find(fa[x]);
}

int gcd(int a,int b)
{
	return !b?a:gcd(b,a%b);
}

inline int rfind(int x)
{
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	
	for(int i=x;i&lt;=m;i++)
		if(find(edge[i].x)!=find(edge[i].y))
		{
			fa[find(edge[i].x)]=fa[find(edge[i].y)];
			if(find(s)==find(t))return i;
		}
		
	return 0;
}

inline int lfind(int x)
{
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	
	for(int i=x;i;i--)
		if(find(edge[i].x)!=find(edge[i].y))
		{
			fa[find(edge[i].x)]=fa[find(edge[i].y)];
			if(find(s)==find(t))return i;
		}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)scanf("%d%d%d",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].c);
	scanf("%d%d",&amp;s,&amp;t);
	
	sort(edge+1,edge+m+1,cmp);
	
	bool flag=false;
	int temp=1,temp1,temp2,a=1000000000,b=1;
	
	while(temp2=rfind(temp))
	{
		flag=true;
		temp1=lfind(temp2);
		if((double)edge[temp2].c/edge[temp1].c&lt;(double)a/b)
			a=edge[temp2].c,b=edge[temp1].c;
		temp=temp1+1;
	}
	
	if(flag)
	{
		temp=gcd(a,b);
		a/=temp;
		b/=temp;
		if(b==1)
			printf("%d\n",a);
		else
			printf("%d/%d\n",a,b);
	}
	else
		printf("IMPOSSIBLE\n");
	
	return 0;
}<pre><h2>Problem1051</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,idex,cnt,ans;
int dfn[10010],low[10010],stack[10010];
int belong[10010],num[10010];
bool instack[10010],bo[10010];

struct size1
{
	int s,t;
}edge[50010];

struct size
{
	int ch;
	size *next;
}*g[10010];

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=g[x];
	g[x]=p;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

void tarjan(int x)
{
	dfn[x]=low[x]=++idex;
	stack[++stack[0]]=x;
	instack[x]=true;
	
	for(size *p=g[x];p!=NULL;p=p-&gt;next)
		if(!dfn[p-&gt;ch])
		{
			tarjan(p-&gt;ch);
			low[x]=min(low[x],low[p-&gt;ch]);
		}
		else
			if(instack[p-&gt;ch])
				low[x]=min(low[x],dfn[p-&gt;ch]);
	
	if(low[x]==dfn[x])
	{
		cnt++;
		
		while(stack[stack[0]+1]!=x)
		{
			belong[stack[stack[0]]]=cnt;
			instack[stack[stack[0]--]]=false;
			num[cnt]++;
		}
	}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;edge[i].s,&amp;edge[i].t);
		add_edge(edge[i].s,edge[i].t);
	}
	
	memset(instack,false,sizeof(instack));
	for(int i=1;i&lt;=n;i++)
		if(!dfn[i])tarjan(i);
	
	memset(bo,true,sizeof(bo));

	for(int i=1;i&lt;=m;i++)
		if(belong[edge[i].s]!=belong[edge[i].t])
			bo[belong[edge[i].s]]=false;
	
	bool flag=true;
	
	for(int i=1;i&lt;=cnt;i++)
		if(bo[i]&amp;&amp;flag)
		{
			ans=num[i];
			flag=false;
		}
		else
			if(bo[i])
				ans=0;
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1051</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,idex,cnt,ans;
int dfn[10010],low[10010],stack[10010];
int belong[10010],num[10010];
bool instack[10010],bo[10010];

struct size1
{
	int s,t;
}edge[50010];

struct size
{
	int ch;
	size *next;
}*g[10010];

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=g[x];
	g[x]=p;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

void tarjan(int x)
{
	dfn[x]=low[x]=++idex;
	stack[++stack[0]]=x;
	instack[x]=true;
	
	for(size *p=g[x];p!=NULL;p=p-&gt;next)
		if(!dfn[p-&gt;ch])
		{
			tarjan(p-&gt;ch);
			low[x]=min(low[x],low[p-&gt;ch]);
		}
		else
			if(instack[p-&gt;ch])
				low[x]=min(low[x],low[p-&gt;ch]);
	
	if(low[x]==dfn[x])
	{
		cnt++;
		
		while(stack[stack[0]+1]!=x)
		{
			belong[stack[stack[0]]]=cnt;
			instack[stack[stack[0]--]]=false;
			num[cnt]++;
		}
	}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;edge[i].s,&amp;edge[i].t);
		add_edge(edge[i].s,edge[i].t);
	}
	
	memset(instack,false,sizeof(instack));
	for(int i=1;i&lt;=n;i++)
		if(!dfn[i])tarjan(i);
	
	memset(bo,true,sizeof(bo));

	for(int i=1;i&lt;=m;i++)
		if(belong[edge[i].s]!=belong[edge[i].t])
			bo[belong[edge[i].s]]=false;
	
	bool flag=true;
	
	for(int i=1;i&lt;=cnt;i++)
		if(bo[i]&amp;&amp;flag)
		{
			ans=num[i];
			flag=false;
		}
		else
			if(bo[i])
				ans=0;
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1052</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=2000000007;

int n;
struct P
{
    int x,y;
}p[20010],p1[20010],p2[20010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}
inline int max(int a,int b)
{
    return a&gt;b?a:b;
}
inline int abs(int x)
{
    return x&lt;0?-x:x;
}

inline bool check(int len)
{
    if(n==0)return true;
    int sd[4][4];
    sd[1][1]=inf;
    sd[1][2]=-inf;
    sd[2][1]=inf;
    sd[2][2]=-inf;
    for(int i=1;i&lt;=n;i++)
    {
        sd[1][1]=min(sd[1][1],p[i].x);
        sd[1][2]=max(sd[1][2],p[i].x);
        sd[2][1]=min(sd[2][1],p[i].y);
        sd[2][2]=max(sd[2][2],p[i].y);
    }
    for(int i=1;i&lt;=2;i++)
        for(int j=1;j&lt;=2;j++)
        {
            int m=0;
            for(int k=1;k&lt;=n;k++)
                if(abs(p[k].x-sd[1][i])&gt;len||abs(p[k].y-sd[2][j])&gt;len)
                    p1[++m]=p[k];
            if(m==0)return true;

            int sp[4][4];
            sp[1][1]=inf;
            sp[1][2]=-inf;
            sp[2][1]=inf;
            sp[2][2]=-inf;
            for(int k=1;k&lt;=m;k++)
            {
                sp[1][1]=min(sp[1][1],p1[k].x);
                sp[1][2]=max(sp[1][2],p1[k].x);
                sp[2][1]=min(sp[2][1],p1[k].y);
                sp[2][2]=max(sp[2][2],p1[k].y);
            }
            for(int ii=1;ii&lt;=2;ii++)
                for(int jj=1;jj&lt;=2;jj++)
                {
                    int s=0;
                    for(int kk=1;kk&lt;=m;kk++)
                        if(abs(p1[kk].x-sp[1][ii])&gt;len||abs(p1[kk].y-sp[2][jj])&gt;len)
                            p2[++s]=p1[kk];
                    if(s==0)return true;

                    int sq[4][4];
                    sq[1][1]=inf;
                    sq[1][2]=-inf;
                    sq[2][1]=inf;
                    sq[2][2]=-inf;
                    for(int kk=1;kk&lt;=s;kk++)
                    {
                        sq[1][1]=min(sq[1][1],p2[kk].x);
                        sq[1][2]=max(sq[1][2],p2[kk].x);
                        sq[2][1]=min(sq[2][1],p2[kk].y);
                        sq[2][2]=max(sq[2][2],p2[kk].y);
                    }
                    if(sq[2][2]-sq[2][1]&lt;=len&amp;&amp;sq[1][2]-sq[1][1]&lt;=len)
                        return true;
                }
        }
    return false;
}

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf("%d%d",&amp;p[i].x,&amp;p[i].y);

    int l=0,r=2000000000,ans;
    while(l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(check(mid))
        {
            ans=mid;
            r=mid-1;
        }
        else
            l=mid+1;
    }
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1053</h2><pre>#include&lt;cstdio&gt;

using namespace std;

long long prime[14]={0,2,3,5,7,11,13,17,19,23,29,31,37};
long long ans,num,n;

inline void dfs(int now,long long product,long long cs,long long lastcs,long long res)
{
    if(ans==res*(cs+1)&amp;&amp;product&lt;num)
        num=product;
    if(res*(cs+1)&gt;ans)
    {
        ans=res*(cs+1);
        num=product;
    }
    if(cs+1&lt;=lastcs&amp;&amp;product*prime[now]&lt;=n)
        dfs(now,product*prime[now],cs+1,lastcs,res);

    for(int i=now+1;i&lt;=12;i++)
        if(product*prime[i]&lt;=n)
            dfs(i,product*prime[i],1,cs,res*(cs+1));
}

int main()
{
    scanf("%lld",&amp;n);

    dfs(1,1,0,100,1);
    printf("%lld\n",num);

    return 0;
}
<pre><h2>Problem1054</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int s,t;
int x[5],y[5];
int que[70000],dist[70000];

inline int read()
{
	char c=getchar();
	while(c!='0'&amp;&amp;c!='1')
		c=getchar();
	return (int)(c-'0');
}

inline bool check1(int x,int y,int num)
{
	return num&amp;(1&lt;&lt;((4-x)*4+4-y));
}

inline bool check0(int x,int y,int num)
{
	if(x&gt;0&amp;&amp;x&lt;5)
		if(y&gt;0&amp;&amp;y&lt;5)
			if(!(num&amp;(1&lt;&lt;((4-x)*4+4-y))))
				return true;
	return false;
}

inline int swap(int xx,int yy,int mode,int num)
{
	int temp=num-(1&lt;&lt;((4-xx)*4+4-yy));
	temp+=(1&lt;&lt;((4-xx-x[mode])*4+4-yy-y[mode]));
	return temp;
}

inline void bfs()
{
	que[1]=s;
	int h=1,ta=1;
	dist[s]=0;
	
	while(!dist[t])
	{
		for(int i=1;i&lt;=4;i++)
			for(int j=1;j&lt;=4;j++)
				if(check1(i,j,que[h]))
					for(int k=1;k&lt;=4;k++)
						if(check0(i+x[k],j+y[k],que[h]))
						{
							int temp=swap(i,j,k,que[h]);
							if(!dist[temp])
							{
								que[++ta]=temp;
								dist[temp]=dist[que[h]]+1;
							}
						}
		h++;	
	}
}

int main()
{
	y[1]=x[2]=-1;
	y[3]=x[4]=1;
	
	for(int i=1;i&lt;=16;i++)
		s=(s&lt;&lt;1)|read();
	
	for(int i=1;i&lt;=16;i++)
		t=(t&lt;&lt;1)|read();
			
	if(s!=t)bfs();
	
	printf("%d\n",dist[t]);
	
	return 0;
}<pre><h2>Problem1059</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int t,n,ans,x;
bool v[210];
int ch[210],match[210];
int ch1[210][210];

bool hungary(int x)
{
	for(int i=1;i&lt;=ch[x];i++)
		if(v[ch1[x][i]])
		{
			v[ch1[x][i]]=false;
			if(!match[ch1[x][i]]||hungary(match[ch1[x][i]]))
			{
				match[ch1[x][i]]=x;
				return true;
			}
		}
	return false;
}

int main()
{
	scanf("%d",&amp;t);
	for(;t;t--)
	{
		scanf("%d",&amp;n);
		
		memset(match,0,sizeof(match));
		memset(ch,0,sizeof(ch));
		
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
			{
				scanf("%d",&amp;x);
				if(x)ch1[i][++ch[i]]=j;
			}
		ans=0;
		
		for(int i=1;i&lt;=n;i++)
		{
			memset(v,true,sizeof(v));
			if(hungary(i))ans++;
		}
		if(ans==n)
			printf("Yes\n");
		else
			printf("No\n");
	}
	return 0;
}<pre><h2>Problem1066</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

int n,m,t,size=-1,ans;
int vh[1010],ch[1010],di[1010],dis[1010],his[1010],pre[1010];
int map[1010][1010],ch1[1010][1010];

struct size
{
	int x,y,c;
}edge[500010];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	edge[++size].x=x;
	edge[size].y=y;
	edge[size].c=z;
	ch1[x][++ch[x]]=size;
	
	edge[++size].x=y;
	edge[size].y=x;
	edge[size].c=0;
	ch1[y][++ch[y]]=size;
}

inline int sap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)di[i]=1;
	int i=1,aug=inf,flow=0;
	
	while(dis[1]&lt;n)
	{
		his[i]=aug;
		bool flag=false;
		for(int j=di[i];j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].y]+1==dis[i])
			{
				flag=true;
				di[i]=j;
				aug=min(aug,edge[ch1[i][j]].c);
				pre[edge[ch1[i][j]].y]=ch1[i][j]^1;
				i=edge[ch1[i][j]].y;
				if(i==n)
				{
					flow+=aug;
					while(i!=1)
					{
						edge[pre[i]].c+=aug;
						edge[pre[i]^1].c-=aug;
						i=edge[pre[i]].y;
					}
					aug=inf;
				}
				break;
			}
		
		if(flag)continue;
		
		int mi=n-1,j1=0;
		
		for(int j=1;j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&gt;0&amp;&amp;dis[edge[ch1[i][j]].y]&lt;mi)
				j1=j,mi=dis[edge[ch1[i][j]].y];
		
		di[i]=j1;
		vh[dis[i]]--;
		if(vh[dis[i]]==0)break;
		
		dis[i]=mi+1;
		vh[dis[i]]++;
		if(i!=1)
		{
			i=edge[pre[i]].y;
			aug=his[i];
		}
	}
	
	return flow;
}

inline int read()
{
	char c=getchar();
	while(c&lt;'0'||c&gt;'9')c=getchar();
	return (int)(c-'0');
}

inline char read1()
{
	char c=getchar();
	while(c!='.'&amp;&amp;c!='L')c=getchar();
	return c;
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;t);
	
	memset(map,0,sizeof(map));
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			map[i][j]=read();
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			if(map[i][j])
			{
				add_edge(1+(i-1)*m+j,1+n*m+(i-1)*m+j,map[i][j]);
				for(int i1=1;i1&lt;=n;i1++)
					for(int j1=1;j1&lt;=m;j1++)
						if((i-i1)*(i-i1)+(j-j1)*(j-j1)&lt;=t*t&amp;&amp;!(i==i1&amp;&amp;j==j1)&amp;&amp;map[i1][j1])
							add_edge(1+n*m+(i-1)*m+j,1+(i1-1)*m+j1,inf/2);
				if(i&lt;=t||j&lt;=t||i&gt;n-t||j&gt;m-t)
					add_edge(1+n*m+(i-1)*m+j,2+2*n*m,inf/2);
			}
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			if(read1()=='L')
				ans++,add_edge(1,1+(i-1)*m+j,1);	
	n=2*n*m+2;
	
	printf("%d\n",ans-sap());
	
	return 0;
}<pre><h2>Problem1070</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int INF=1000000000;

int n,m,S=1,T,cnt=1,ans;
int g[610],dist[610],q[610],pre[610];
bool v[610];
struct edge
{
    int t,c,cst,next;
}e[100010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y,int z1,int z2)
{
    e[++cnt].t=y;
    e[cnt].c=z1;
    e[cnt].cst=z2;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].cst=-z2;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int calc1(int x,int y)
{
    return (x-1)*n+y+1;
}

inline int spfa()
{
    memset(v,0,sizeof(v));
    for(int i=S;i&lt;=T;i++)dist[i]=INF;
    dist[1]=0;q[1]=S;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%T+1;
        int x=q[h];
        v[x]=false;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dist[x]+e[i].cst&lt;dist[e[i].t])
            {
                pre[e[i].t]=i;
                dist[e[i].t]=dist[x]+e[i].cst;

                if(!v[e[i].t])
                {
                    t=t%T+1;
                    v[e[i].t]=true;
                    q[t]=e[i].t;
                }
            }
    }
    return dist[T]!=INF;
}

int main()
{
    m=read();n=read();
    T=2+n*m+n;
    for(int i=1;i&lt;=n;i++)
    {
        int temp=1+n*m+i;
        add_edge(temp,T,1,0);

        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            for(int k=1;k&lt;=n;k++)
                add_edge(calc1(j,k),temp,1,x*k);
        }
    }
    for(int i=1;i&lt;=m;i++)
        for(int j=1;j&lt;=n;j++)
            add_edge(S,calc1(i,j),1,0);

    while(spfa())
    {
        ans+=dist[T];
        for(int i=T;i!=S;i=e[pre[i]^1].t)
        {
            e[pre[i]].c--;
            e[pre[i]^1].c++;
        }
    }

    printf("%.2lf\n",(double)ans/n);

    return 0;
}
<pre><h2>Problem1071</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;

using namespace std;

struct node{
	int b,a,c;
	friend bool operator&lt;(node a,node b)
	{
		return a.c&lt;b.c;
	}
}data[5010];

priority_queue&lt;node&gt;q;
int n,a,b,c;

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline bool cmp(node a,node b)
{
	return a.a&gt;b.a;
}

int main()
{
	scanf("%d%d%d%d",&amp;n,&amp;a,&amp;b,&amp;c);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d%d",&amp;data[i].a,&amp;data[i].b);
		data[i].c=a*data[i].a+b*data[i].b;
	}
	
	sort(data+1,data+1+n,cmp);
	
	int ans=0;
	
	for(int i=1;i&lt;=n;i++)
	{
		while(q.size())q.pop();
		
		int minh=data[i].a,minw=data[i].b;
		
		for(int j=1;j&lt;=n;j++)
		{
			if(data[i].c&gt;minh*a+minw*b+c)
				break;
			
			if(data[j].c&lt;=minh*a+minw*b+c)
			{
				minh=min(data[j].a,minh);
				
				if(data[j].b&gt;=minw)
					q.push(data[j]);
				
				while(q.size()&amp;&amp;(q.top()).c&gt;minh*a+minw*b+c)
					q.pop();
			}
			ans=max(ans,q.size());
		}
	}
	
	printf("%d\n",ans);
	return 0;
}<pre><h2>Problem1072</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;

using namespace std;

int T,n,P,ans;
int a[15];
char str[15];

inline void check()
{
	long long temp=0;
	for(int i=1;i&lt;=n;i++)
		temp=(long long)temp*10+a[i];
	if(temp%P==0)ans++;
}

int main()
{
	for(scanf("%d",&amp;T);T;T--)
	{
		scanf("%s",str);
		cin&gt;&gt;P;
		n=strlen(str);
		
		for(int i=0;i&lt;n;i++)
			a[i+1]=str[i]-'0';
		sort(a+1,a+n+1);
		ans=0;
		check();
		while(next_permutation(a+1,a+n+1))
			check();
		printf("%d\n",ans);
	}
	return 0;
}<pre><h2>Problem1079</h2><pre>#include &lt;cstdio&gt;

using namespace std;

const long long P=1000000007;

int n;
int sum[20];
long long f[16][16][16][16][16][16];

inline long long calc(int a,int b,int c,int d,int e,int last)
{
    if(f[a][b][c][d][e][last])return f[a][b][c][d][e][last];
    if(a+b+c+d+e==0)return f[a][b][c][d][e][last]=1;
    long long sum=0;
    if(a)sum+=(a-(last==2))*calc(a-1,b,c,d,e,1);
    if(b)sum+=(b-(last==3))*calc(a+1,b-1,c,d,e,2);
    if(c)sum+=(c-(last==4))*calc(a,b+1,c-1,d,e,3);
    if(d)sum+=(d-(last==5))*calc(a,b,c+1,d-1,e,4);
    if(e)sum+=e*calc(a,b,c,d+1,e-1,5);
    return f[a][b][c][d][e][last]=sum%P;
}

int main()
{
    for(scanf("%d",&amp;n);n;n--)
    {
        int x;
        scanf("%d",&amp;x);
        sum[x]++;
    }
    printf("%lld\n",calc(sum[1],sum[2],sum[3],sum[4],sum[5],0));

    return 0;
}
<pre><h2>Problem1081</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int dat[25],base[25],sum=1;
int n,m;

inline void init()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		sum*=m,base[i]=1;
}

inline void print()
{
	sum--;
	
	for(int i=1;i&lt;=n;i++)
		printf("%c",dat[i]&lt;10?'0'+dat[i]:'A'+dat[i]-10);
	printf("\n");
}
inline void solve()
{
	print();
	
	while(sum) 
	{
		for(int i=1;i&lt;=n;i++)
			if(dat[i]+base[i]&gt;=0&amp;&amp;dat[i]+base[i]&lt;m)
			{
				dat[i]+=base[i];
				break;
			}
			else
				base[i]*=-1;
		print();
	}
}

int main()
{
	init();
	
	solve();
	
	return 0;
}<pre><h2>Problem1083</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,ma=0,fa[500];

struct size
{
	int a,b,len;
}r[10000];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline bool cmp(size a,size b)
{
	return a.len&lt;b.len;
}

int find(int x)
{
	return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline void kruskal()
{
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	
	for(int i=1;i&lt;=m;i++)
		if(find(r[i].a)!=find(r[i].b))
		{
			ma=max(ma,r[i].len);
			fa[fa[r[i].a]]=fa[fa[r[i].b]];
		}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=m;i++)
		scanf("%d%d%d",&amp;r[i].a,&amp;r[i].b,&amp;r[i].len);
	
	sort(r+1,r+m+1,cmp);
	
	kruskal();
	
	printf("%d %d\n",n-1,ma);
	
	return 0;
}<pre><h2>Problem1084</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=-1000000000;

int n,m,k,num[110][5],s[5][110];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			scanf("%d",&amp;num[i][j]),s[j][i]=s[j][i-1]+num[i][j];
	
	if(m==1)
	{
		int f[110][15];
		for(int i=0;i&lt;=n;i++)
			for(int t=0;t&lt;=k;t++)
				f[i][t]=0;
		
		for(int i=1;i&lt;=n;i++)
			for(int t=1;t&lt;=k;t++)
			{
				f[i][t]=f[i-1][t];
				
				for(int j=0;j&lt;i;j++)
					f[i][t]=max(f[i][t],f[j][t-1]+s[1][i]-s[1][j]);
			}
		
		printf("%d\n",f[n][k]);
	}
	else
	{
		int f[110][110][15];
		
		for(int i=0;i&lt;=n;i++)
			for(int j=0;j&lt;=n;j++)
				for(int t=0;t&lt;=k;t++)
					f[i][j][t]=0;
		
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				for(int t=1;t&lt;=k;t++)
				{
					f[i][j][t]=max(f[i-1][j][t],f[i][j-1][t]);
					
					for(int p=0;p&lt;i;p++)
						f[i][j][t]=max(f[i][j][t],f[p][j][t-1]+s[1][i]-s[1][p]);
					
					for(int p=0;p&lt;j;p++)
						f[i][j][t]=max(f[i][j][t],f[i][p][t-1]+s[2][j]-s[2][p]);
					
					if(i==j)
						for(int p=0;p&lt;i;p++)
							f[i][j][t]=max(f[i][j][t],f[p][p][t-1]+s[1][i]-s[1][p]+s[2][j]-s[2][p]);
				}
		
		printf("%d\n",f[n][n][k]);
	}
	
	return 0;
}<pre><h2>Problem1085</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;queue&gt;

using namespace std;

int t,ans;
int move[10][3];
queue&lt;int&gt; q;
map&lt;int,int&gt; g,g1;

inline bool judge(int x,int y)
{
    return x&gt;0&amp;&amp;x&lt;6&amp;&amp;y&gt;0&amp;&amp;y&lt;6;
}

inline int calc(int p,int x,int y)
{
    return (p*5+x-1)*5+y-1;
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void bfs()
{
    q.push(825012012);
    int m[6][6];

    while(!q.empty())
    {
        int step=g[q.front()];

        if(step==9)
        {
            q.pop();
            continue;
        }

        int u=q.front();
        int y=u%5+1;
        u/=5;
        int x=u%5+1;
        u/=5;

        for(int i=24;i&gt;=0;i--)
        {
            m[i/5+1][i%5+1]=u&amp;1;
            u&gt;&gt;=1;
        }

        for(int i=1;i&lt;=8;i++)
            if(judge(x+move[i][0],y+move[i][1]))
        {
            int x1=x+move[i][0];
            int y1=y+move[i][1];
            int temp=q.front();
            temp/=25;

            if(m[x1][y1])
            {
                temp+=(1&lt;&lt;(30-x*5-y));
                temp-=(1&lt;&lt;(30-x1*5-y1));
            }

            temp=calc(temp,x1,y1);
            if(g[temp]==0)
            {
                g[temp]=step+1;
                q.push(temp);
            }
        }
        q.pop();
    }
}

inline void bfs1(int x)
{
    q.push(x);
    g1[x]=1;
    int m[6][6];

    while(!q.empty())
    {
        int step=g1[q.front()];
        int step1=g[q.front()];
        if(step1)
            ans=min(ans,step+step1-2);

        if(step==8)
        {
            q.pop();
            continue;
        }

        int u=q.front();
        int y=u%5+1;
        u/=5;
        int x=u%5+1;
        u/=5;

        for(int i=24;i&gt;=0;i--)
        {
            m[i/5+1][i%5+1]=u&amp;1;
            u&gt;&gt;=1;
        }

        for(int i=1;i&lt;=8;i++)
            if(judge(x+move[i][0],y+move[i][1]))
        {
            int x1=x+move[i][0];
            int y1=y+move[i][1];
            int temp=q.front();
            temp/=25;

            if(m[x1][y1])
            {
                temp+=(1&lt;&lt;(30-x*5-y));
                temp-=(1&lt;&lt;(30-x1*5-y1));
            }

            temp=calc(temp,x1,y1);
            if(g1[temp]==0)
            {
                g1[temp]=step+1;
                q.push(temp);
            }
        }

        q.pop();
    }
}

int main()
{
    g[825012012]=1;
    move[1][0]=-2;
    move[1][1]=-1;
    move[2][0]=-2;
    move[2][1]=1;
    move[3][0]=-1;
    move[3][1]=2;
    move[4][0]=1;
    move[4][1]=2;
    move[5][0]=2;
    move[5][1]=1;
    move[6][0]=2;
    move[6][1]=-1;
    move[7][0]=1;
    move[7][1]=-2;
    move[8][0]=-1;
    move[8][1]=-2;

    bfs();

    scanf("%d",&amp;t);

    for(;t;t--)
    {
        char str[6][6];
        for(int i=1;i&lt;=5;i++)
            scanf("%s",str[i]);

        int temp=0,x=0,y=0;
        ans=16;
        for(int i=1;i&lt;=5;i++)
            for(int j=0;j&lt;5;j++)
        {
            temp&lt;&lt;=1;
            if(str[i][j]=='1')
                temp|=1;
            if(str[i][j]=='*')
            {
                x=i;
                y=j+1;
            }
        }
        g1.clear();
        bfs1(calc(temp,x,y));

        printf("%d\n",ans==16?-1:ans);
    }
    return 0;
}<pre><h2>Problem1087</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,k,n1;
long long ans;
long long f[10][90][1100];

inline int lowbit(int x)
{
	return x&amp;-x;
}

inline int find1(int x)
{
	int temp=0;
	for(;x;x-=lowbit(x))++temp;
	return temp;
}

inline bool check1(int x)
{
	while(x&gt;1)
	{
		if((x&amp;1)&amp;&amp;(x&amp;2))return false;
		x&gt;&gt;=1;
	}
	return true;
}

inline bool check2(int x,int y)
{
	for(int i=2;i&lt;n;i++)
		if((x&amp;(1&lt;&lt;(i-1)))&amp;&amp;((y&amp;(1&lt;&lt;(i-2)))||(y&amp;(1&lt;&lt;(i-1)))||(y&amp;(1&lt;&lt;i))))
			return false;
	if((x&amp;1)&amp;&amp;((y&amp;1)||(y&amp;2)))
		return false;
	if(n&gt;1&amp;&amp;(x&amp;(1&lt;&lt;(n-1)))&amp;&amp;((y&amp;(1&lt;&lt;(n-1)))||(y&amp;(1&lt;&lt;(n-2)))))
		return false;
	return true;
}

int main()
{	
	scanf("%d%d",&amp;n,&amp;k);
	
	n1=1&lt;&lt;n;
	f[0][0][0]=1;
	for(int i=1;i&lt;=n;i++)
		for(int j=0;j&lt;=k;j++)
			for(int k1=0;k1&lt;n1;k1++)
				if(f[i-1][j][k1])
					for(int k2=0;k2&lt;n1;k2++)
						if(j+find1(k2)&lt;=k)
							if(check1(k2))
								if(check2(k1,k2))
									f[i][j+find1(k2)][k2]+=f[i-1][j][k1];
	
	for(int i=0;i&lt;n1;i++)
		ans+=f[n][k][i];
	
	printf("%lld\n",ans);
	
	return 0;	
}<pre><h2>Problem1088</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,ans;
int a[10010],b[10010];
bool flag;

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",a+i);
	
	if(n==1)
	{
		if(a[1]==1||a[1]==0)
			printf("1\n");
		else
			printf("0\n");
		
		return 0;
	}
			
	for(int i=0;i&lt;4;i++)
	{
		memset(b,0,sizeof(b));
		b[1]=i/2;
		b[2]=i%2;
		flag=true;
		
		if(a[1]!=b[1]+b[2])flag=false;
		
		for(int i=3;i&lt;=n&amp;&amp;flag;i++)
		{
			b[i]=a[i-1]-b[i-1]-b[i-2];
			if(b[i]!=0&amp;&amp;b[i]!=1)flag=false;
		}
		if(b[n]+b[n-1]!=a[n])flag=false;
		
		if(flag)ans++;
	}
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1098</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,cnt;
int size=0;
int ans[100010];
int edge[4000010],pre[2000010],next[4000010];
bool bo[100010],q_b[100010];
queue&lt;int&gt; q;

struct link
{
	int pre,next;
}l[100010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void del(int x)
{
	l[l[x].pre].next=l[x].next;
	l[l[x].next].pre=l[x].pre;
}

inline void addedge(int u,int v)
{
	edge[++size]=v;
	next[size]=pre[u];
	pre[u]=size;
}

inline void bfs()
{
	while(l[0].next)
	{
		int now=l[0].next,temp=1;
		del(now);
		q.push(now);
		q_b[now]=1;

		while(!q.empty())
		{
			int u=q.front();
			q.pop();
			for(int p=pre[u];p;p=next[p])
                bo[edge[p]]=true;

			for(int i=l[0].next;i;i=l[i].next)
			{
				if(!bo[i]&amp;&amp;!q_b[i])
				{
					q_b[i]=1;
					q.push(i);
					temp++;
					del(i);
				}
			}

			for(int p=pre[u];p;p=next[p])
                bo[edge[p]]=false;
		}
		ans[++cnt]=temp;
	}
}

int main()
{
	n=read();
	m=read();

	for (int i=1;i&lt;=m;i++)
	{
		int u,v;
		u=read();
		v=read();
		addedge(u,v);
		addedge(v,u);
	}
	for(int i=1;i&lt;=n;i++)
    {
        l[i-1].next=i;
        l[i].pre=i-1;
    }
    l[n].next=0;

	bfs();

	sort(ans+1,ans+cnt+1);

	printf("%d\n",cnt);
	printf("%d",ans[1]);
	for(int i=2;i&lt;=cnt;i++)
        printf(" %d",ans[i]);

	return 0;
}
<pre><h2>Problem1101</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,T,k;
bool v[50010];
int sum[60010],u[50010],prime[50010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}
inline void swap(int &amp;a,int &amp;b)
{
    a^=b^=a^=b;
}

inline void getmu()
{
	u[1]=1;
	for(int i=2;i&lt;=50000;i++)
	{
		if(!v[i])
        {
			prime[++prime[0]]=i;
			u[i]=-1;
		}
		for(int j=1;j&lt;=prime[0];j++)
        {
			if(i*prime[j]&gt;50000)break;
			v[i*prime[j]]=1;
			if(i%prime[j])
				u[i*prime[j]]=-u[i];
			else
            {
				u[i*prime[j]]=0;
				break;
			}
		}
	}

	sum[0]=0;
	for(int i=1;i&lt;=50000;i++)sum[i]=sum[i-1]+u[i];
}

inline int work(int X,int Y)
{
	int ans=0;
	for(int i=1;i&lt;=X;)
    {
		int temp=min(X/(X/i),Y/(Y/i));
		ans+=(sum[temp]-sum[i-1])*(X/i)*(Y/i);
		i=temp+1;
	}
	return ans;
}

int main()
{
    getmu();
	for(scanf("%d",&amp;T);T;T--)
    {
		scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
		n/=k;m/=k;
		if(n&gt;m)swap(n,m);
		printf("%d\n",work(n,m));
	}

	return 0;
}
<pre><h2>Problem1103</h2><pre>#include&lt;cstdio&gt;

using namespace std;

struct size
{
	int ch;
	size *next;
}*tr[250010];

int n,m,x,y,tot=0;
int tree[500020],s[250010],t[250010];
bool v[250010];
char c;

inline int lowbit(int x)
{
	return x&amp;(-x);
}

inline void add_edge(int a,int b)
{
	size *p;
	
	p=new size;
	p-&gt;ch=b;
	p-&gt;next=tr[a];
	tr[a]=p;
	
	p=new size;
	p-&gt;ch=a;
	p-&gt;next=tr[b];
	tr[b]=p;
}

inline void add(int x,int num)
{
	for(;x&lt;=n*2;x+=lowbit(x))
		tree[x]+=num;
}

inline int query(int x)
{
	int ans=0;
	for(;x;x-=lowbit(x))
		ans+=tree[x];
	return ans;
}

void dfs(int x)
{
	v[x]=false;
	s[x]=++tot;
	add(tot,1);
	
	size *p=tr[x];
	while(p!=NULL)
	{
		if(v[p-&gt;ch])dfs(p-&gt;ch);
		p=p-&gt;next;
	}
	
	t[x]=++tot;
	add(tot,-1);
}

int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(x,y);
	}
	
	for(int i=1;i&lt;=n;i++)v[i]=true;
	
	dfs(1);
	add(1,-1);
	add(n*2,1);
	
	scanf("%d%c",&amp;m,&amp;c);
	m=n+m-1;
	
	for(;m;m--)
	{
		scanf("%c",&amp;c);
		
		if(c=='A')
		{
			scanf("%d%d%c",&amp;x,&amp;y,&amp;c);
			add(s[y],-1);
			add(t[y],1);
		}
		else
		{
			scanf("%d%c",&amp;x,&amp;c);
			printf("%d\n",query(s[x]));
		}
	}
	
	return 0;
}<pre><h2>Problem1146</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;

using namespace std;

const int INF=1000000000;

int n,q,siz1,siz2=13870000,N,Num1,Num2,idx,cnt;
int g[80010],dep[80010];
int v1[810],v2[810],S[80010],T[80010],t[80010];
int root[160010];
int fa[80010][17];
int ls[12430000],rs[12430000],val[13870000];
set&lt;int&gt;s;
int p[160010];
struct Query
{
	int k,a,b;
}Q[80010];
struct edge
{
	int t,next;
}e[160010];
inline void add_edge(int x,int y)
{
	e[++cnt].t=y;
	e[cnt].next=g[x];
	g[x]=cnt;
}
	
inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}
inline void Swap(int&amp;x,int&amp;y)
{
	x^=y^=x^=y;
}

inline int lowbit(int x)
{
	return x&amp;-x;
}

inline void modify(int&amp;x,int l,int r,int pos,int Val)
{
	if(!x)
		if(l==r)
			x=--siz2;
		else
			x=++siz1;
	val[x]+=Val;
	if(l==r)return;
	int mid=(l+r)&gt;&gt;1;
	if(pos&lt;=mid)
		modify(ls[x],l,mid,pos,Val);
	else
		modify(rs[x],mid+1,r,pos,Val);
}
		
inline void add(int x,int t,int val)
{
//	printf("%d %d %d\n",x,t,val);
	for(;x&lt;=n;x+=lowbit(x))
		modify(root[x],1,N,t,val);
}

inline int query(int l,int r,int k)
{
	if(l==r)return p[l];
	int temp=0;
	for(int i=1;i&lt;=Num1;i++)
		temp+=val[rs[v1[i]]];
	for(int i=1;i&lt;=Num2;i++)
		temp-=val[rs[v2[i]]];
//	printf("%d %d %d %d\n",l,r,k,temp);
	int mid=(l+r)&gt;&gt;1;
	if(temp&gt;=k)
	{
		for(int i=1;i&lt;=Num1;i++)v1[i]=rs[v1[i]];
		for(int i=1;i&lt;=Num2;i++)v2[i]=rs[v2[i]];
		return query(mid+1,r,k);
	}
	else
	{
		k-=temp;
		for(int i=1;i&lt;=Num1;i++)v1[i]=ls[v1[i]];
		for(int i=1;i&lt;=Num2;i++)v2[i]=ls[v2[i]];
		return query(l,mid,k);
	}
}

inline void dfs(int x)
{
	//printf("*%d\n",x);
	for(int i=1;i&lt;17;i++)
		fa[x][i]=fa[fa[x][i-1]][i-1];
	S[x]=++idx;
	add(idx,t[x],1);
	for(int i=g[x];i;i=e[i].next)
		if(e[i].t!=fa[x][0])
		{
			dep[e[i].t]=dep[x]+1;
			fa[e[i].t][0]=x;
			dfs(e[i].t);
		}
	T[x]=++idx;
	add(idx,t[x],-1);
}

inline void swim(int&amp;x,int h)
{
	for(int i=0;h;i++)
	{
		if(h&amp;1)x=fa[x][i];
		h&gt;&gt;=1;
	}
}
inline int lca(int x,int y)
{
	if(dep[x]&lt;dep[y])Swap(x,y);
	swim(x,dep[x]-dep[y]);
	for(int i=16;x!=y;i--)
	{
		if(fa[x][i]!=fa[y][i]||i==0)
		{
			x=fa[x][i];
			y=fa[y][i];
		}
		if(!i)i=1;
	}
	return x;
}

int main()
{
	n=read();q=read();
	for(int i=1;i&lt;=n;i++)
	{
		t[i]=read();
		s.insert(t[i]);
	}
	for(int i=1;i&lt;n;i++)
	{
		int x=read(),y;y=read();
		add_edge(x,y);
		add_edge(y,x);
	}
   	for(int i=1;i&lt;=q;i++)
	{
		Q[i].k=read();
		Q[i].a=read();
		Q[i].b=read();
		if(!Q[i].k)s.insert(Q[i].b);
	}
	for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)
		p[++N]=*it;
	for(int i=1;i&lt;=n;i++)
		t[i]=lower_bound(p+1,p+N+1,t[i])-p;
	for(int i=1;i&lt;=q;i++)
		if(!Q[i].k)
			Q[i].b=lower_bound(p+1,p+N+1,Q[i].b)-p;
	
	n&lt;&lt;=1;
	fa[1][0]=1;
	dfs(1);
	for(int i=1;i&lt;=q;i++)
	{
//		printf("%d\n",i);
		if(!Q[i].k)
		{
			add(S[Q[i].a],t[Q[i].a],-1);
			add(T[Q[i].a],t[Q[i].a],1);
			t[Q[i].a]=Q[i].b;
			add(S[Q[i].a],Q[i].b,1);
			add(T[Q[i].a],Q[i].b,-1);
		}
		else
		{
			int z=lca(Q[i].a,Q[i].b);
			int z1=fa[z][0];
			if(z==1)z1=0;
			z=S[z];z1=S[z1];
			Q[i].a=S[Q[i].a];Q[i].b=S[Q[i].b];
			Num1=0;Num2=0;
			int temp=0;
			for(;Q[i].a;Q[i].a-=lowbit(Q[i].a))temp+=val[v1[++Num1]=root[Q[i].a]];
			for(;Q[i].b;Q[i].b-=lowbit(Q[i].b))temp+=val[v1[++Num1]=root[Q[i].b]];
			for(;z;z-=lowbit(z))temp-=val[v2[++Num2]=root[z]];
			for(;z1;z1-=lowbit(z1))temp-=val[v2[++Num2]=root[z1]];
			if(temp&lt;Q[i].k)
				printf("invalid request!\n");
			else
				printf("%d\n",query(1,N,Q[i].k));
		}
	}
//	printf("%d\n",Free);
	return 0;
}
<pre><h2>Problem1163</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,S,T,cnt;
int g[510],in[510],out[510];
int pre[510],his[510],di[510],dis[510],vh[510];

struct edge
{
    int t,c,next;
}e[100010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int rev(int x)
{
    return x&amp;1?x+1:x-1;
}

inline int isap()
{
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)di[i]=g[i];
    int flow=0,aug=inf,X=1;
    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[X]=aug;

        for(int i=g[X];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[X])
            {
                aug=min(aug,e[i].c);
                flag=true;
                di[X]=i;
                pre[e[i].t]=rev(i);
                X=e[i].t;

                if(X==n)
                {
                    flow+=aug;
                    while(X!=1)
                    {
                        e[pre[X]].c+=aug;
                        e[rev(pre[X])].c-=aug;
                        X=e[pre[X]].t;
                    }
                    aug=inf;
                }
                break;
            }
        if(flag)continue;

        vh[dis[X]]--;
        if(vh[dis[X]]==0)break;

        int mi=n,mii;
        for(int i=g[X];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        dis[X]=mi+1;
        vh[dis[X]]++;
        di[X]=mii;

        if(X!=1)
        {
            X=e[pre[X]].t;
            aug=his[X];
        }
    }
    return flow;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    scanf("%d%d",&amp;S,&amp;T);
    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        in[i]=i&lt;&lt;1;out[i]=i&lt;&lt;1|1;
        add_edge(in[i],out[i],x);
    }
    add_edge(1,in[S],inf);
    n=(n&lt;&lt;1)+2;
    add_edge(out[T],n,inf);
    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(out[x],in[y],inf);
        add_edge(out[y],in[x],inf);
    }
    printf("%d\n",isap());
    return 0;
}
<pre><h2>Problem1167</h2><pre>int main(){return 0;}<pre><h2>Problem1179</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,idex,cnt,x,y,ans;
int dfn[500010],low[500010],belong[500010],stack[500010];
int val[500010],dist[500010];
bool instack[500010];

struct size1
{
	int s,t;
}edge[500010];

struct size
{
	int ch;
	size *next;
}*g[500010];

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=g[x];
	g[x]=p;
}

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

void tarjan(int x)
{
	dfn[x]=low[x]=++idex;
	instack[x]=true;
	stack[++stack[0]]=x;
	
	for(size *p=g[x];p!=NULL;p=p-&gt;next)
		if(!dfn[p-&gt;ch])
		{
			tarjan(p-&gt;ch);
			low[x]=min(low[x],low[p-&gt;ch]);
		}
		else
			if(instack[p-&gt;ch])
				low[x]=min(low[x],dfn[p-&gt;ch]);
	
	if(dfn[x]==low[x])
	{
		cnt++;
		while(stack[stack[0]+1]!=x)
		{
			belong[stack[stack[0]]]=cnt;
			instack[stack[stack[0]--]]=false;
		}
	}
}

void spfa(int x)
{
	int h=0,t=1;
	stack[1]=x;
	dist[x]=val[x];
	instack[x]=true;
	
	while(h!=t)
	{
		h=h%cnt+1;
		x=stack[h];
		instack[x]=false;
		
		for(size *p=g[x];p!=NULL;p=p-&gt;next)
			if(dist[x]+val[p-&gt;ch]&gt;dist[p-&gt;ch])
			{
				dist[p-&gt;ch]=dist[x]+val[p-&gt;ch];
				if(!instack[p-&gt;ch])
				{
					instack[p-&gt;ch]=true;
					t=t%cnt+1;
					stack[t]=p-&gt;ch;
				}
			}
	}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;edge[i].s,&amp;edge[i].t);
		add_edge(edge[i].s,edge[i].t);
	}
	
	memset(instack,false,sizeof(instack));
	
	for(int i=1;i&lt;=n;i++)
		if(!dfn[i])
			tarjan(i);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;x);
		val[belong[i]]+=x;
		g[i]=NULL;
	}
	
	for(int i=1;i&lt;=m;i++)
		if(belong[edge[i].s]!=belong[edge[i].t])
			add_edge(belong[edge[i].s],belong[edge[i].t]);
	
	scanf("%d",&amp;x);
	
	x=belong[x];
	spfa(x);
	
	scanf("%d",&amp;x);
	
	for(int i=1;i&lt;=x;i++)
	{
		scanf("%d",&amp;y);
		ans=max(ans,dist[belong[y]]);
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1189</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define S 0
#define T 1000
#define inf 0x7fffffff
using namespace std;
int n,m,door=1,cnt,ans,tot,mn=-1;
int xx[4]={0,0,1,-1},yy[4]={1,-1,0,0};
int mp[21][21],head[1001],h[1001],q[1001];
int dis[401][21][21];
struct data{int x,y,s;}d[401];
struct data2{int to,next,v;}e[1000001];
bool bfs()
{
	int t=0,w=1,i,now;
	memset(h,-1,sizeof(h));
	h[S]=0;q[0]=S;
	while(t&lt;w)
	{
		now=q[t];t++;
		i=head[now];
		while(i)
		{
			if(h[e[i].to]==-1&amp;&amp;e[i].v){h[e[i].to]=h[now]+1;q[w++]=e[i].to;}
			i=e[i].next;
		}
	}
	if(h[T]==-1)return 0;
	return 1;
}
int dfs(int x,int f)
{
    if(x==T)return f;
    int i=head[x];
    int w,used=0;
    while(i)
    {
		if(e[i].v&amp;&amp;h[e[i].to]==h[x]+1)
		{
			w=f-used;
			w=dfs(e[i].to,min(w,e[i].v));
			e[i].v-=w;
			e[i^1].v+=w;
			used+=w;
			if(used==f)return f;                      
		}
		i=e[i].next;
	}
    if(!used)h[x]=-1;
    return used;
}
void dinic(){while(bfs())ans+=dfs(0,inf);}
void ins(int u,int v,int w)
{e[++cnt].to=v;e[cnt].next=head[u];e[cnt].v=w;head[u]=cnt;}
void insert(int u,int v,int w)
{ins(u,v,w);ins(v,u,0);} 
void build(int x)
{
	memset(head,0,sizeof(head));
	cnt=1;
	for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
			if(mp[i][j]==1)insert(S,(i-1)*m+j,1);
	for(int i=2;i&lt;=door;i++)insert(n*m+i,T,x);
	for(int i=2;i&lt;=door;i++)
		for(int j=1;j&lt;=n;j++)
			for(int k=1;k&lt;=m;k++)
				if(dis[i][j][k]&lt;=x)insert((j-1)*m+k,n*m+i,x);
}
void search(int k,int x,int y) 
{
	int t=0,w=1,nowx,nowy;
	d[0].x=x;d[0].y=y;
	while(t&lt;w)
	{
		for(int i=0;i&lt;4;i++)
		{   
			nowx=d[t].x+xx[i],nowy=d[t].y+yy[i];
			if(nowx&lt;1||nowy&lt;1||nowx&gt;n||nowy&gt;m||mp[nowx][nowy]!=1)continue;
			if(dis[k][nowx][nowy]==inf)
			{
				dis[k][nowx][nowy]=d[w].s=d[t].s+1;
				d[w].x=nowx;d[w].y=nowy;
				w++; 
			}
		}
		t++;
	}
}
bool judge(int x)
{ 
	build(x);
	ans=0;
	dinic();
	if(ans==tot)return 1;
	return 0; 
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    char ch[21];
    for(int i=1;i&lt;=n;i++)
    {
		scanf("%s",ch);
		for(int j=1;j&lt;=m;j++)
		{
			if(ch[j-1]=='.'){mp[i][j]=1;tot++;}
			else if(ch[j-1]=='D')mp[i][j]=++door; 
		}
	}
    for(int i=2;i&lt;=door;i++)
		for(int j=1;j&lt;=n;j++)
			for(int k=1;k&lt;=m;k++)
				dis[i][j][k]=inf;
    for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			if(mp[i][j]&gt;1)search(mp[i][j],i,j);
    int l=0,r=400;
    while(l&lt;=r)
    {
		int mid=(l+r)&gt;&gt;1;
		if(judge(mid)){mn=mid;r=mid-1;}
		else l=mid+1;
	}
    if(mn==-1)printf("impossible");
    else printf("%d",mn);
    return 0;
}<pre><h2>Problem1191</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,x,y,ans=0;
int match[1010];
bool bo=true,v[1010];

struct size
{
	int ch;
	size *next;
}*g[1010];

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=g[x];
	g[x]=p;
}

bool hungary(int x)
{
	size *p=g[x];
	
	while(p!=NULL)
	{
		if(v[p-&gt;ch])
		{
			v[p-&gt;ch]=false;
			if(match[p-&gt;ch]==0||hungary(match[p-&gt;ch]))
			{
				match[p-&gt;ch]=x;
				return true;
			}
		}
		p=p-&gt;next;
	}
	return false;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=m;i++)
	{
		memset(v,true,sizeof(v));
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(i,x+1);
		add_edge(i,y+1);
		if(!hungary(i))
		{
			printf("%d\n",i-1);
			bo=false;
			break;
		}
	}
	if(bo)printf("%d\n",m);
	
	return 0;
}<pre><h2>Problem1192</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

int main()
{
    int n;

    scanf("%d",&amp;n);

    printf("%d\n",int(log2(n)+1));;

    return 0;
}
<pre><h2>Problem1196</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,k;
int fa[10010];

struct size
{
	int s,t,c1,c2;
}edge[20010];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int find(int x)
{
	return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline bool check(int num)
{
	int nn=0;
	
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	
	for(int i=1;i&lt;=m;i++)
		if(edge[i].c1&lt;=num)
			if(find(edge[i].s)!=find(edge[i].t))
			{
				++nn;
				fa[find(edge[i].s)]=fa[find(edge[i].t)];
			}
	
	if(nn&lt;k)return false;
	
	for(int i=1;i&lt;=m;i++)
		if(edge[i].c2&lt;=num)
			if(find(edge[i].s)!=find(edge[i].t))
			{
				++nn;
				fa[find(edge[i].s)]=fa[find(edge[i].t)];
			}
	
	if(nn==n-1)
		return true;
	else
		return false;
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;k,&amp;m);
	m--;
	
	int l=1,r=0;
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d%d%d",&amp;edge[i].s,&amp;edge[i].t,&amp;edge[i].c1,&amp;edge[i].c2);
		r=max(r,edge[i].c1);
	}
	
	while(l+1&lt;r)
	{
		int mid=(l+r)/2;
		
		if(check(mid))
			r=mid;
		else
			l=mid+1;
	}
	
	if(check(l))
		printf("%d\n",l);
	else
		printf("%d\n",r);
		
	return 0;
}<pre><h2>Problem1207</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,ans=0;
int t[10010],x[10010],y[10010];
int f[10010],ma[10010];

inline int read()
{
    char c=getchar();
    int temp=0;

    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline int abs(int x)
{
    return x&lt;0?-x:x;
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=m;i++)
    {
        t[i]=read();
        x[i]=read();
        y[i]=read();
    }
    f[1]=1;
    ma[1]=1;
    for(int i=2;i&lt;=m;i++)
    {
        f[i]=1;
        for(int j=i-1;j&gt;=1;j--)
        {
            if(ma[j]+1&lt;=f[i])break;
            if(f[j]+1&gt;f[i])
                if(abs(x[i]-x[j])+abs(y[i]-y[j])&lt;=t[i]-t[j])
			        f[i]=f[j]+1;
        }
        ma[i]=max(f[i],ma[i-1]);
        ans=max(f[i],ans);
    }

    printf("%d",ans);

    return 0;
}
<pre><h2>Problem1213</h2><pre>m,n=input(),input()
l,r=0,1
while r**m&lt;=n:
 l=r
 r=r*2
while l&lt;r:
 mid=(l+r+1)//2
 if mid**m&lt;=n:
  l=mid
 else:
  r=mid-1
print l<pre><h2>Problem1218</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,r,x,y,z,m,l,ans;
int f[5050][5050];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;r);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		f[x+1][y+1]+=z;
		m=max(x+1,m);
		l=max(y+1,l);
	}
	
	for(int i=1;i&lt;min(m+r,5050);i++)
		for(int j=1;j&lt;min(l+r,5050);j++)  
		{
			f[i][j]=f[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1];  
			if(i&gt;=r&amp;&amp;j&gt;=r)
				ans=max(ans,f[i][j]-f[i][j-r]-f[i-r][j]+f[i-r][j-r]);
		}
		
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1221</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=0x3fffffff;

int n,siz=-1,ans=0;
int que[2010],dist[2010],flow[2010],pre[2010];

bitset&lt;2010&gt; inque;

struct size1
{
    int t,c,fe;
}edge[20000];

struct size
{
    int ch;
    size *next;
}*g[2010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int fx(int x)
{
    return x*2;
}

inline int gx(int x)
{
    return x*2+1;
}

inline void add_edge(int x,int y,int z,int fe)
{
    edge[++siz].t=y;
    edge[siz].c=z;
    edge[siz].fe=fe;

    size *p=new size;
    p-&gt;ch=siz;
    p-&gt;next=g[x];
    g[x]=p;

    edge[++siz].t=x;
    edge[siz].c=0;
    edge[siz].fe=-fe;

    p=new size;
    p-&gt;ch=siz;
    p-&gt;next=g[y];
    g[y]=p;
}

inline bool spfa()
{
    memset(dist,63,sizeof(dist));
    memset(flow,0,sizeof(flow));
    dist[1]=0;
    flow[1]=inf;

    inque.reset();
    inque.set(1);
    int h=0,t=1;
    que[1]=1;

    while(h!=t)
    {
        h=h%n+1;
        int x=que[h];
        inque.flip(x);

        for(size *p=g[x];p;p=p-&gt;next)
            if(edge[p-&gt;ch].c&amp;&amp;dist[x]+edge[p-&gt;ch].fe&lt;dist[edge[p-&gt;ch].t])
        {
            int child=edge[p-&gt;ch].t;
            dist[child]=dist[x]+edge[p-&gt;ch].fe;
            flow[child]=min(flow[x],edge[p-&gt;ch].c);
            pre[child]=1^p-&gt;ch;

            if(!inque.test(child))
            {
                inque.set(child);
                t=t%n+1;
                que[t]=child;
            }
        }
    }

    return flow[n]==0?false:true;
}

int main()
{
    int a,b,f,fa,fb;
    scanf("%d%d%d%d%d%d",&amp;n,&amp;a,&amp;b,&amp;f,&amp;fa,&amp;fb);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        add_edge(1,fx(i),inf,f);
        add_edge(fx(i),n*2+2,x,0);
        add_edge(1,gx(i),x,0);
        if(i&lt;n)add_edge(gx(i),gx(i+1),inf,0);
        if(i&lt;n-a)add_edge(gx(i),fx(i+a+1),inf,fa);
        if(i&lt;n-b)add_edge(gx(i),fx(i+b+1),inf,fb);
    }
    n=n*2+2;

    while(spfa())
    {
        ans+=dist[n]*flow[n];

        for(int i=n;i!=1;i=edge[pre[i]].t)
        {
            edge[pre[i]].c+=flow[n];
            edge[1^pre[i]].c-=flow[n];
        }
    }

    printf("%d\n",ans);

    return 0;
}
/*
4 1 2 3 2 1
8 2 1 6
*/
<pre><h2>Problem1230</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m;

struct segment_tree
{
    int l,r;
    int sum,tag;
}seg[400000];

void build(int p,int l,int r)
{
    seg[p].l=l;
    seg[p].r=r;
    seg[p].sum=0;
    seg[p].tag=0;

    if(l!=r)
    {
        int mid=(l+r)/2;
        build(p&lt;&lt;1,l,mid);
        build((p&lt;&lt;1)+1,mid+1,r);
    }
}

inline void update(int p)
{
    seg[p].tag=0;
    seg[p].sum=seg[p].r-seg[p].l+1-seg[p].sum;

    if(seg[p].l!=seg[p].r)
    {
        seg[p&lt;&lt;1].tag^=1;
        seg[(p&lt;&lt;1)+1].tag^=1;
    }
}

void change(int p,int l,int r)
{
    if(seg[p].tag==1)update(p);

    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)
    {
        update(p);
        return;
    }

    int mid=(seg[p].l+seg[p].r)/2;

    if(r&lt;=mid)
        change(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            change((p&lt;&lt;1)+1,l,r);
        else
        {
            change(p&lt;&lt;1,l,mid);
            change((p&lt;&lt;1)+1,mid+1,r);
        }
    if(seg[p&lt;&lt;1].tag)update(p&lt;&lt;1);
    if(seg[(p&lt;&lt;1)+1].tag)update((p&lt;&lt;1)+1);
    seg[p].sum=seg[p&lt;&lt;1].sum+seg[(p&lt;&lt;1)+1].sum;
}

int query(int p,int l,int r)
{

    if(seg[p].tag==1)update(p);

    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p].sum;

    int mid=(seg[p].l+seg[p].r)/2;

    if(r&lt;=mid)
        return query(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            return query((p&lt;&lt;1)+1,l,r);
        else
            return query(p&lt;&lt;1,l,mid)+query((p&lt;&lt;1)+1,mid+1,r);
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    build(1,1,n);

    for(;m;m--)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);

        if(x==0)
            change(1,y,z);
        else
            printf("%d\n",query(1,y,z));
    }

    return 0;
}
<pre><h2>Problem1231</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int inf=1000000000;

int n,K;
int a[20],s[20];
long long f[100010][20];
int num[20][100010];

inline int abs(int x)
{
    return x&lt;0?-x:x;
}

inline void initialize()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n-i;j++)a[j]=0;
        for(int j=n-i+1;j&lt;=n;j++)a[j]=1;
        do
        {
            int temp=0;
            for(int j=1;j&lt;=n;j++)temp=temp&lt;&lt;1|a[j];
            num[i][++num[i][0]]=temp;
        }while(next_permutation(a+1,a+n+1));
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;K);
    for(int i=1;i&lt;=n;i++)scanf("%d",s+i);
    initialize();

    for(int i=1;i&lt;=num[1][0];i++)
        f[num[1][i]][i]=1;

    for(int i=2;i&lt;=n;i++)
        for(int j=1;j&lt;=num[i-1][0];j++)
            for(int k=1;k&lt;=n;k++)
                if((num[i-1][j]&amp;(1&lt;&lt;(k-1)))&amp;&amp;f[num[i-1][j]][k])
                    for(int l=1;l&lt;=n;l++)
                        if(!(num[i-1][j]&amp;(1&lt;&lt;(l-1)))&amp;&amp;abs(s[k]-s[l])&gt;K)
                            f[num[i-1][j]|(1&lt;&lt;(l-1))][l]+=f[num[i-1][j]][k];

    long long ans=0;
    for(int i=1;i&lt;=n;i++)
        ans+=f[num[n][1]][i];
    printf("%lld\n",ans);

    return 0;
}
<pre><h2>Problem1232</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int INF=1000000000;

int n,m,ans=INF;
int a[10010];
int fa[10010],rank[10010];
struct edge
{
  int x,y,c;
  inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
  {
    return a.c&lt;b.c;
  }
}e[100010];

inline int read()
{
  int c=getchar(),temp=0;
  while(c&lt;48||c&gt;57)c=getchar();
  while(c&gt;=48&amp;&amp;c&lt;=57)
    {
      temp=temp*10+c-48;
      c=getchar();
    }
  return temp;
}
inline int Min(const int&amp;a,const int&amp;b)
{
  return a&lt;b?a:b;
}

inline int find(int x)
{
  return fa[x]=x==fa[x]?x:find(fa[x]);
}
inline void unio(int x,int y)
{
  int f1=find(x),f2=find(y);
  if(rank[f1]&lt;rank[f2])
    fa[f1]=f2;
  else
    {
      fa[f2]=f1;
      if(rank[f2]==rank[f1])rank[f2]++;
    }
}

int main()
{
  n=read();m=read();
  for(int i=1;i&lt;=n;i++)
    {
      a[i]=read();
      ans=Min(ans,a[i]);
      fa[i]=i;
    }
  for(int i=1;i&lt;=m;i++)
    {
      e[i].x=read();
      e[i].y=read();
      e[i].c=(read()&lt;&lt;1)+a[e[i].x]+a[e[i].y];
    }

  sort(e+1,e+m+1);
  for(int i=1;i&lt;=m;i++)
    {
      if(find(e[i].x)!=find(e[i].y))
	{
	  unio(e[i].x,e[i].y);
	  ans+=e[i].c;
	}
    }

  printf("%d\n",ans);

  return 0;
}
<pre><h2>Problem1233</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,h=1,t=1;
int sum[100010],f[100010],g[100010],q[100010];

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        sum[i]=sum[i-1]+x;
    }

    q[1]=n+1;

    for(int i=n;i;i--)
    {
        while(t&gt;h&amp;&amp;sum[q[h+1]-1]-sum[i-1]&gt;=f[q[h+1]])h++;
        f[i]=sum[q[h]-1]-sum[i-1];
        g[i]=g[q[h]]+1;
        while(t&gt;h&amp;&amp;f[i]-sum[i-1]&lt;f[q[t]]-sum[q[t]-1])t--;
        q[++t]=i;
    }

    printf("%d\n",g[1]);

    return 0;
}
<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;

inline int Max(int x,int y)
{
    return x&gt;y?x:y;
}

struct Splay_tree
{
    int val,ma,siz,tag1,tag2;
    Splay_tree *ls,*rs,*fa;

    inline Splay_tree():val(0),ma(0),siz(1),tag1(0),tag2(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Splay_tree(const int&amp;x):val(x),ma(0),siz(1),tag1(0),tag2(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void new_node(int x)
    {
        *this=Splay_tree(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag1)
        {
            Splay_tree*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag1^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag1^=1;
            this-&gt;tag1=0;
        }
        if(this-&gt;tag2)
        {
            if(this-&gt;ls!=NULL)
            {
                this-&gt;ls-&gt;val+=this-&gt;tag2;
                this-&gt;ls-&gt;ma+=this-&gt;tag2;
                this-&gt;ls-&gt;tag2+=this-&gt;tag2;
            }
            if(this-&gt;rs!=NULL)
            {
                this-&gt;rs-&gt;val+=this-&gt;tag2;
                this-&gt;rs-&gt;ma+=this-&gt;tag2;
                this-&gt;rs-&gt;tag2+=this-&gt;tag2;
            }
            this-&gt;tag2=0;
        }
    }
    inline void recalc()
    {
        this-&gt;ma=this-&gt;val;
        if(this-&gt;ls!=NULL)this-&gt;ma=Max(this-&gt;ma,this-&gt;ls-&gt;ma);
        if(this-&gt;rs!=NULL)this-&gt;ma=Max(this-&gt;ma,this-&gt;rs-&gt;ma);
    }
    inline void LR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;

        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
        f-&gt;recalc();
        this-&gt;recalc();
    }
    inline void RR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;

        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
        f-&gt;recalc();
        this-&gt;recalc();
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Insert(int x)
    {
        Splay_tree*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            if(x&lt;now-&gt;val)
                now=now-&gt;ls;
            else
                now=now-&gt;rs;
        }
        now=new Splay_tree;
        now-&gt;new_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)
            if(x&lt;prv-&gt;val)prv-&gt;ls=now;
            else prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Splay_tree*Get_kth(int x)
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }

    inline void Splay1()//for LR
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Get_kth1(int x)//for LR
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Splay_tree*Get_LR(int x,int y)
    {
        Splay_tree*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y+2);
        return now-&gt;fa;
    }
}*root;

int n,m;

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    n++;
    for(int i=0;i&lt;=n;i++)
        root=root-&gt;Insert(0);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;z,&amp;x,&amp;y);
        root=root-&gt;Get_LR(x,y);

        if(z==1)
        {
            scanf("%d",&amp;z);

            root-&gt;rs-&gt;ls-&gt;val+=z;
            root-&gt;rs-&gt;ls-&gt;ma+=z;
            root-&gt;rs-&gt;ls-&gt;tag2+=z;

            root-&gt;rs-&gt;recalc();
            root-&gt;recalc();
        }
        else
            if(z==2)
                root-&gt;rs-&gt;ls-&gt;tag1^=1;
            else
                printf("%d\n",root-&gt;rs-&gt;ls-&gt;ma);
    }

    return 0;
}
<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;

inline int Max(int x,int y)
{
    return x&gt;y?x:y;
}

struct Splay_tree
{
    int val,ma,siz,tag1,tag2;
    Splay_tree *ls,*rs,*fa;

    inline Splay_tree():val(0),ma(0),siz(1),tag1(0),tag2(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Splay_tree(const int&amp;x):val(x),ma(0),siz(1),tag1(0),tag2(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void new_node(int x)
    {
        *this=Splay_tree(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag1)
        {
            Splay_tree*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag1^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag1^=1;
            this-&gt;tag1=0;
        }
        if(this-&gt;tag2)
        {
            if(this-&gt;ls!=NULL)
            {
                this-&gt;ls-&gt;val+=this-&gt;tag2;
                this-&gt;ls-&gt;ma+=this-&gt;tag2;
                this-&gt;ls-&gt;tag2+=this-&gt;tag2;
            }
            if(this-&gt;rs!=NULL)
            {
                this-&gt;rs-&gt;val+=this-&gt;tag2;
                this-&gt;rs-&gt;ma+=this-&gt;tag2;
                this-&gt;rs-&gt;tag2+=this-&gt;tag2;
            }
            this-&gt;tag2=0;
        }
    }
    inline void recalc()
    {
        this-&gt;ma=this-&gt;val;
        if(this-&gt;ls!=NULL)this-&gt;ma=Max(this-&gt;ma,this-&gt;ls-&gt;ma);
        if(this-&gt;rs!=NULL)this-&gt;ma=Max(this-&gt;ma,this-&gt;rs-&gt;ma);
    }
    inline void LR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;

        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
        f-&gt;recalc();
        this-&gt;recalc();
    }
    inline void RR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;

        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
        f-&gt;recalc();
        this-&gt;recalc();
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Insert(int x)
    {
        Splay_tree*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            if(x&lt;now-&gt;val)
                now=now-&gt;ls;
            else
                now=now-&gt;rs;
        }
        now=new Splay_tree;
        now-&gt;new_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)
            if(x&lt;prv-&gt;val)prv-&gt;ls=now;
            else prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Splay_tree*Get_kth(int x)
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }

    inline void Splay1()//for LR
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Get_kth1(int x)//for LR
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Splay_tree*Get_LR(int x,int y)
    {
        Splay_tree*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y+2);
        return now-&gt;fa;
    }
}*root;

inline int read()
{
    char c=getchar();
    int f=1,temp=0;
    while((c&lt;'0'||c&gt;'9')&amp;&amp;c!='-')c=getchar();
    if(c=='-'){f=-1;c=getchar();}
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp*f;
}

int n,m;

int main()
{
    n=read();n++;m=read();
    for(int i=0;i&lt;=n;i++)
        root=root-&gt;Insert(0);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        z=read();x=read();y=read();
        root=root-&gt;Get_LR(x,y);

        if(z==1)
        {
            z=read();

            root-&gt;rs-&gt;ls-&gt;val+=z;
            root-&gt;rs-&gt;ls-&gt;ma+=z;
            root-&gt;rs-&gt;ls-&gt;tag2+=z;

            root-&gt;rs-&gt;recalc();
            root-&gt;recalc();
        }
        else
            if(z==2)
                root-&gt;rs-&gt;ls-&gt;tag1^=1;
            else
                printf("%d\n",root-&gt;rs-&gt;ls-&gt;ma);
    }

    return 0;
}
<pre><h2>Problem1258</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

using namespace std;

string s,que[200];
int size=0,a[5];

inline void add(string ss)
{
	que[++size]=ss;
}

inline bool cmp(string a,string b)
{
	return (a+b)&lt;(b+a);
}
int main()
{
	cin&gt;&gt;s;
	
	if(s[s.length()-1]=='4')
	{
		cout&lt;&lt;s.substr(0,s.length()-1)&lt;&lt;'1'&lt;&lt;endl;
		cout&lt;&lt;s.substr(0,s.length()-1)&lt;&lt;'2'&lt;&lt;endl;
		cout&lt;&lt;s.substr(0,s.length()-1)&lt;&lt;'3'&lt;&lt;endl;
	}
	else
	{
		a[1]=a[2]=a[3]=1;
		for(int i=s.length()-1;i&amp;&amp;a[1]+a[2]+a[3];i--)
			if(a[(int)s[i]-48])a[(int)s[i]-48]=0,add(s.substr(0,i)+"4");
		sort(que,que+size+1,cmp);
		for(int i=1;i&lt;=size;i++)cout&lt;&lt;que[i]&lt;&lt;endl;
	}
	return 0;
} <pre><h2>Problem1258</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

using namespace std;

string s,que[50];
int size=0,a[4];

inline void add(string ss)
{
	que[++size]=ss;
}

inline bool cmp(string a,string b)
{
	return (a+b)&lt;(b+a);
}
int main()
{
	cin&gt;&gt;s;
	
	if(s[s.length()-1]=='4')
	{
		cout&lt;&lt;s.substr(0,s.length()-1)&lt;&lt;'1'&lt;&lt;endl;
		cout&lt;&lt;s.substr(0,s.length()-1)&lt;&lt;'2'&lt;&lt;endl;
		cout&lt;&lt;s.substr(0,s.length()-1)&lt;&lt;'3'&lt;&lt;endl;
	}
	else
	{
		a[1]=a[2]=a[3]=1;
		
		for(int i=s.length()-1;i&amp;&amp;a[1]+a[2]+a[3];i--)
			if(a[(int)s[i]-48])a[(int)s[i]-48]=0,add(s.substr(0,i)+"4");
			
		sort(que,que+size+1,cmp);
		
		for(int i=1;i&lt;=size;i++)cout&lt;&lt;que[i]&lt;&lt;endl;
	}
	return 0;
} <pre><h2>Problem1266</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
const int maxn=502;
const int maxm=124752;
int d[maxn][maxn],i,j,k,n,l,r,mm,q[maxm*5],h[maxn],m;
bool v[maxm],vv;
int c[maxn],js[maxn],ans,min,kk;
struct arr
{
	int x,y,c,t;
}a[maxm];
struct brr
{
	int ne,to,f;
}b[maxm*5];
void floyed()
{
	for (k=1;k&lt;=n;k++)
	for (i=1;i&lt;=n;i++)
	for (j=1;j&lt;=n;j++)
	if (d[i][j]&gt;d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];
	printf("%d\n",d[1][n]);
}
void add(int x,int y,int w)
{
	b[++mm].ne=h[x];b[mm].to=y;b[mm].f=w;h[x]=mm;
	b[++mm].ne=h[y];b[mm].to=x;b[mm].f=0;h[y]=mm;
}
void build()
{
	for (i=1;i&lt;=m;i++)
	{
		if (d[1][a[i].x]+d[a[i].y][n]+a[i].t==d[1][n]) add(a[i].x,a[i].y,a[i].c),v[a[i].y]=v[a[i].x]=1;
		if (d[1][a[i].y]+d[a[i].x][n]+a[i].t==d[1][n]) add(a[i].y,a[i].x,a[i].c),v[a[i].y]=v[a[i].x]=1;
	}
}
void init()
{
	memset(c,10,sizeof c);
	q[l=r=1]=n;c[n]=0;js[0]++;
	for (;l&lt;=r;l++)
	{
		for (i=h[q[l]];i;i=b[i].ne)
		if (!b[i].f&amp;&amp;c[q[l]]+1&lt;c[b[i].to])
		{
			q[++r]=b[i].to;
			c[q[r]]=c[q[l]]+1;
			js[c[q[r]]]++;
		}
	}
}
void sap(int i)
{
	if (i==n)
	{
		ans+=min;vv=1;
		return;
	}
	int minx=min,e=n-1,j=h[i];
	for (;j;j=b[j].ne)
	if (b[j].f)
	{
		if (c[b[j].to]+1==c[i])
		{
			if (b[j].f&lt;min) min=b[j].f;
			sap(b[j].to);
			if (c[1]&gt;=n) return;
			if (!vv) min=minx;else break;
		}
		if (c[b[j].to]&lt;e) e=c[b[j].to];
	}
	if (vv) b[j].f-=min,b[j^1].f+=min;
	else
	{
		js[c[i]]--;
		if (!js[c[i]]) c[1]=n;
		c[i]=e+1;
		js[c[i]]++;
	}
}
int main()
{
	scanf("%d %d\n",&amp;n,&amp;m);mm=1;
	memset(d,10,sizeof d);
	for (i=1;i&lt;=m;i++) scanf("%d %d %d %d\n",&amp;a[i].x,&amp;a[i].y,&amp;a[i].t,&amp;a[i].c);
	for (i=1;i&lt;=m;i++) d[a[i].x][a[i].y]=d[a[i].y][a[i].x]=a[i].t;
	for (i=1;i&lt;=n;i++) d[i][i]=0;
	floyed();build();
	init();
	for (i=1;i&lt;=n;i++)
	if (v[i]) kk++;
	while (c[1]&lt;kk)
	{
		min=1000000;vv=0;
		sap(1);
	}
	printf("%d\n",ans);
	return 0;
} 
<pre><h2>Problem1267</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;cstring&gt;

using namespace std;

int n,cnt,K;
int sum,root,num;
int ans,Mi,Ma;
int g[50010],v[50010],siz[50010],f[50010],dist[50010];
int Ans[300010];
int cnt1,cnt2;
int num1[50010],num2[50010];
vector&lt;int&gt;v1[50010],v2[50010];
struct edge
{
    int t,c,next;
}e[100010];
struct Num
{
    int num;
    inline friend bool operator&lt;(const Num&amp;x,const Num&amp;y)
    {
        return x.num&gt;y.num;
    }
};
multiset&lt;Num&gt;s;

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}
inline bool cmp(const int&amp;a,const int&amp;b)
{
    return a&gt;b;
}

inline void dfs(int x,int y,int fa)
{
    dist[++num]=y;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs(e[i].t,y+e[i].c,x);
}
inline void calc(int x,int dis,int tag)
{
    num=0;
    dfs(x,dis,0);
    sort(dist+1,dist+num+1);
    if(tag==0)
    {
        num1[++cnt1]=num;
        for(int i=1;i&lt;=num;i++)
            v1[cnt1].push_back(dist[i]);
        if(num&gt;=2)
        {
            Ma=Max(Ma,dist[num]+dist[num-1]);
            Mi=Min(Mi,dist[1]+dist[2]);
        }
    }
    else
    {
        num2[++cnt2]=num;
        for(int i=1;i&lt;=num;i++)
            v2[cnt2].push_back(dist[i]);
    }
}
inline void get_root(int x,int fa)
{
    siz[x]=1;f[x]=0;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
        {
            get_root(e[i].t,x);
            siz[x]+=siz[e[i].t];
            f[x]=Max(f[x],siz[e[i].t]);
        }
    f[x]=Max(f[x],sum-siz[x]);
    if(f[x]&lt;f[root])root=x;
}
inline void work(int x)
{
    v[x]=1;
    calc(x,0,0);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            calc(e[i].t,e[i].c,1);
            sum=num;root=0;
            get_root(e[i].t,0);
            work(root);
        }
}

inline void dfs1(int x,int y,int fa)
{
    if(y&gt;ans)Ans[++num]=y;
    for(multiset&lt;Num&gt;::iterator it=s.begin();it!=s.end();it++)
        if(y+it-&gt;num&gt;ans)
            Ans[++num]=y+it-&gt;num;
        else
            break;

    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs1(e[i].t,y+e[i].c,x);
}
inline void dfs2(int x,int fa)
{
    sum++;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs2(e[i].t,x);
}
inline void add(int x,int y,int fa)
{
    Num a;a.num=y;
    s.insert(a);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            add(e[i].t,y+e[i].c,x);
}
inline void calc1(int x)
{
    s.clear();
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            dfs1(e[i].t,e[i].c,x);
            add(e[i].t,e[i].c,x);
        }
}
inline void work1(int x)
{
    v[x]=1;
    calc1(x);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            sum=0;dfs2(e[i].t,x);
            root=0;
            get_root(e[i].t,0);
            work1(root);
        }
}

inline int check(int x)
{
    int temp=0;
    vector&lt;int&gt;::iterator it;
    for(int i=1;i&lt;=cnt1;i++)
    {
        it=v1[i].end();
        for(int k=1;k&lt;=num1[i];k++)
        {
            it--;
            int temp1=v1[i].end()-lower_bound(v1[i].begin(),v1[i].end(),x-*it);
            if(temp1==0)break;
            temp+=temp1;
        }
    }
    for(int i=1;i&lt;=cnt2;i++)
    {
        it=v2[i].end();
        for(int k=1;k&lt;=num2[i];k++)
        {
            it--;
            int temp1=v2[i].end()-lower_bound(v2[i].begin(),v2[i].end(),x-*it);
            if(temp1==0)break;
            temp-=temp1;
        }
    }
    return temp&gt;&gt;1;
}

int main()
{
    n=read();K=read();
    for(int i=1;i&lt;n;i++)
    {
        int x=read(),y,z;y=read();z=read();
        add_edge(x,y,z);
        add_edge(y,x,z);
    }

    Ma=0;Mi=1000000000;
    f[0]=n;sum=n;
    get_root(1,0);
    work(1);

    int L=Mi,R=Ma;
    while(L&lt;=R)
    {
        int mid=(L+R)&gt;&gt;1;
        if(check(mid)&gt;=K)
        {
            ans=mid;
            L=mid+1;
        }
        else
            R=mid-1;
    }

    f[0]=n;sum=n;
    get_root(1,0);
    num=0;
    memset(v,0,sizeof(v));
    work1(1);

    sort(Ans+1,Ans+num+1,cmp);
    for(int i=1;i&lt;=num;i++)
        printf("%d\n",Ans[i]);
    for(int i=num+1;i&lt;=K;i++)
        printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1293</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;

using namespace std;

typedef struct
{
	int a,b,c;      
}size;

struct cmp
{
	bool operator()(const size &amp;t1,const size &amp;t2)
	{
		return t1.a&gt;t2.a;
	}
};

priority_queue&lt;size,vector&lt;size&gt;,cmp&gt;q;

size temp;

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

int n,k,ma,ans=2147483647;
int sum[100],a[1000010];

int main()
{
	scanf("%d%d",&amp;k,&amp;n);
	sum[1]=1;
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;k);
		
		sum[i+1]=sum[i]+k;
		for(int j=1;j&lt;=k;j++)
			scanf("%d",&amp;a[sum[i]+j-1]);
			
		temp.a=a[sum[i]];
		temp.b=sum[i];
		temp.c=i;
		q.push(temp);
		
		ma=max(ma,a[sum[i]]);
	}
	
	while(1)
	{
		ans=min(ans,ma-q.top().a);
		
		if(q.top().b+1==sum[q.top().c+1])break;
		
		temp.a=a[q.top().b+1];
		temp.b=q.top().b+1;
		temp.c=q.top().c;
		ma=max(ma,temp.a);
		
		q.pop();
		q.push(temp);
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1296</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,t,num,ans;
int last[5],f[55][2510],g[55][2510];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int read()
{
	char c=getchar();
	while(c!='0'&amp;&amp;c!='1')c=getchar();
	return c-'0';
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;t);
	
	for(int i=1;i&lt;=n;i++)
	{
		last[0]=last[1]=0;
		memset(g,0,sizeof(g));
		
		for(int j=1;j&lt;=m;j++)
		{
			num=read();
			
			for(int k=1;k&lt;=j;k++)
			{
				g[j][k]=max(g[j-1][k-1]+1,g[last[num]][k]+1);
				if(last[num]==j-1)g[j][k]=max(g[j][k],g[j-1][k]+1);
				f[i][k]=max(f[i][k],g[j][k]);
			}
			last[num]=j;
		}
	}
	
	memset(g,0,sizeof(g));
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=t;j++)
			for(int k=1;k&lt;=j;k++)
				ans=max(ans,g[i][j]=max(g[i][j],g[i-1][j-k]+f[i][k]));
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1296</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,t,num,ans;
int last[5],f[55][2510],g[55][2510];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline int read()
{
	char c=getchar();
	while(c!='0'&amp;&amp;c!='1')c=getchar();
	return c-'0';
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;t);
	
	for(int i=1;i&lt;=n;i++)
	{
		last[0]=last[1]=0;
		memset(g,0,sizeof(g));
		
		for(int j=1;j&lt;=m;j++)
		{
			num=read();
			
			for(int k=1;k&lt;=j;k++)
			{
				g[j][k]=max(g[j-1][k-1]+1,g[last[num]][k]+1);
				if(last[num]==j-1)g[j][k]=max(g[j][k],g[j-1][k]+1);
				f[i][k]=max(f[i][k],g[j][k]);
			}
			last[num]=j;
		}
	}
	
	memset(g,0,sizeof(g));
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=t;j++)
			for(int k=1;k&lt;=min(j,m);k++)
				ans=max(ans,g[i][j]=max(g[i][j],g[i-1][j-k]+f[i][k]));
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1296</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
 
using namespace std;
 
int n,m,t,num,ans;
int last[5],f[55][2510],g[55][2510];
 
inline int max(int a,int b)
{
    return a&gt;b?a:b;
}
 
inline int min(int a,int b)
{
    return a&lt;b?a:b;
}
 
inline int read()
{
    char c=getchar();
    while(c!='0'&amp;&amp;c!='1')c=getchar();
    return c-'0';
}
 
int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;t);
     
    for(int i=1;i&lt;=n;i++)
    {
        last[0]=last[1]=0;
        memset(g,0,sizeof(g));
         
        for(int j=1;j&lt;=m;j++)
        {
            num=read();
             
            for(int k=1;k&lt;=j;k++)
            {
                g[j][k]=max(g[j-1][k-1]+1,g[last[num]][k]+1);
                f[i][k]=max(f[i][k],g[j][k]);
            }
            last[num]=j;
        }
    }
     
    memset(g,0,sizeof(g));
     
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=t;j++)
            for(int k=1;k&lt;=min(j,m);k++)
                ans=max(ans,g[i][j]=max(g[i][j],g[i-1][j-k]+f[i][k]));
     
    printf("%d\n",ans);
     
    return 0;
}<pre><h2>Problem1303</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,k,p,s,i,ans,a[100000],c[200000];

int main()
{
	scanf("%d%d",&amp;n,&amp;k);
	for(i=1;i&lt;=n;i++)
	{
		scanf("%d",a+i);
		if(a[i]==k)p=i;
	}
	
	for(i=p-1,c[s=100000]=1;i;i--)c[s+=a[i]&gt;k?1:-1]++;
	
	for(i=p+1,ans=c[s=100000];i&lt;=n;i++)ans+=c[s+=a[i]&lt;k?1:-1];
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1305</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int maxint=1000000000;

int n,k,nu=-1,num,ans=maxint;
int l[500],vh[500],dis[500],his[500],pre[500];

struct size
{
    int ch;
    size *next;
}*g[500],*di[500];

struct size1
{
    int t,c;
}edg[100000],edge[100000];

inline void add_edge(int x,int y,int z)
{
    edg[++nu].t=y;
    edg[nu].c=z;

    size *p=new size;
    p-&gt;ch=nu;
    p-&gt;next=g[x];
    g[x]=p;

    edg[++nu].t=x;
    edg[nu].c=0;

    p=new size;
    p-&gt;ch=nu;
    p-&gt;next=g[y];
    g[y]=p;
}

inline void add(int x,int y)
{
    size *p=new size;
    p-&gt;ch=++num;
    p-&gt;next=g[x];
    g[x]=p;

    p=new size;
    p-&gt;ch=++num;
    p-&gt;next=g[y];
    g[y]=p;
}

inline void add_edge1(int x,int y,int z)
{
    edge[++num].t=y;
    edge[num].c=z;

    edge[++num].t=x;
    edge[num].c=0;
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int sap()
{
    vh[0]=n*4+2;
    for(int i=1;i&lt;=n*4+2;i++)
        di[i]=g[i],dis[i]=0,vh[i]=0;
    int i=1,aug=maxint,flow=0;

    while(dis[1]&lt;n*4+2)
    {
        bool flag=false;
        his[i]=aug;

        for(size *p=di[i];p!=NULL;p=p-&gt;next)
            if(edge[p-&gt;ch].c&amp;&amp;dis[i]==dis[edge[p-&gt;ch].t]+1)
            {
                flag=true;
                aug=min(aug,edge[p-&gt;ch].c);
                pre[edge[p-&gt;ch].t]=1^p-&gt;ch;
                i=edge[p-&gt;ch].t;

                if(i==n*4+2)
                {
                    flow+=aug;
                    while(i!=1)
                    {
                        edge[pre[i]].c+=aug;
                        edge[pre[i]^1].c-=aug;
                        i=edge[pre[i]].t;
                    }
                    aug=maxint;
                }
                break;
            }

        if(flag)continue;

        int mi=n*4+2;
        size *p1;

        for(size *p=g[i];p!=NULL;p=p-&gt;next)
            if(edge[p-&gt;ch].c&amp;&amp;dis[edge[p-&gt;ch].t]+1&lt;mi)
                mi=dis[edge[p-&gt;ch].t]+1,p1=p;

        di[i]=p1;

        vh[dis[i]]--;
        if(!vh[dis[i]])break;
        dis[i]=mi;
        vh[dis[i]]++;

        if(i!=1)
        {
            i=edge[pre[i]].t;
            aug=his[i];
        }
    }

    return flow;
}

inline bool test(int x)
{
    for(int i=0;i&lt;=nu;i++)
        edge[i]=edg[i];
    num=nu;
    for(int i=1;i&lt;=n;i++)
    {
        add_edge1(1,i+1,x);
        add_edge1(i+n*3+1,n*4+2,x);
    }
    int temp=sap();

    return temp==x*n?1:0;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;k);

    for(int i=1;i&lt;=n;i++)
    {
        add_edge(i+1,i+n+1,k);
        add_edge(i+n*2+1,i+n*3+1,k);

        char c[500];
        scanf("%s",c);

        for(int j=0;j&lt;n;j++)
            if(c[j]=='Y')
                add_edge(i+1,j+n*3+2,1);
            else
                add_edge(i+n+1,j+n*2+2,1);
    }
    num=nu;
    for(int i=1;i&lt;=n;i++)
    {
        add(1,i+1);
        add(i+n*3+1,n*4+2);
    }

    int l=0,r=n;
    while(l+1&lt;r)
    {
        int mid=(l+r)/2;
        if(test(mid))
            l=mid;
        else
            r=mid-1;
    }

    if(test(r))
        printf("%d\n",r);
    else
        printf("%d\n",l);

    return 0;
}<pre><h2>Problem1324</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};

int n,m,cnt=-1,sum;
int g[40010];
int di[40010],dis[40010],vh[40010],his[40010],pre[40010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

struct edge
{
    int t,c,next;
}e[300000];

inline void add_edge(int x,int y,int z)
{
    //printf("%d %d %d\n",x,y,z);

    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int calc(int x,int y)
{
    return (x-1)*m+y+1;
}

inline bool judge(int x,int y)
{
    return x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=m;
}

inline int isap()
{
    n=n*m+2;
    for(int i=1;i&lt;=n;i++)di[i]=g[i];
    vh[0]=n;
    int x=1,flow=0,aug=inf;

    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[x]=aug;

        for(int i=di[x];i!=-1;i=e[i].next)
            if(e[i].c&amp;&amp;dis[x]==dis[e[i].t]+1)
            {
                flag=true;
                aug=min(aug,e[i].c);
                di[x]=i;
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==n)
                {
                    flow+=aug;
                    for(;x!=1;x=e[pre[x]].t)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                    }
                    aug=inf;
                }

                break;
            }

        if(flag)continue;

        int mi=n,mii=0;

        for(int i=g[x];i!=-1;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        vh[dis[x]]--;
        if(!vh[dis[x]])break;
        dis[x]=mi+1;
        vh[dis[x]]++;
        di[x]=mii;

        if(x!=1)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }

    return flow;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    memset(g,-1,sizeof(g));

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x;
            scanf("%d",&amp;x);
            sum+=x;

            if((i+j)&amp;1)
                add_edge(calc(i,j),n*m+2,x);
            else
            {
                add_edge(1,calc(i,j),x);

                for(int k=0;k&lt;4;k++)
                    if(judge(i+dx[k],j+dy[k]))
                        add_edge(calc(i,j),calc(i+dx[k],j+dy[k]),inf);
            }
        }

    printf("%d\n",sum-isap());

    return 0;
}
/*
2 2
1 2
2 1
*/
<pre><h2>Problem1339</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,S,T,cnt;
int g[510],in[510],out[510];
int pre[510],his[510],di[510],dis[510],vh[510];

struct edge
{
    int t,c,next;
}e[100010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int rev(int x)
{
    return x&amp;1?x+1:x-1;
}

inline int isap()
{
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)di[i]=g[i];
    int flow=0,aug=inf,X=1;
    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[X]=aug;

        for(int i=g[X];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[X])
            {
                aug=min(aug,e[i].c);
                flag=true;
                di[X]=i;
                pre[e[i].t]=rev(i);
                X=e[i].t;

                if(X==n)
                {
                    flow+=aug;
                    while(X!=1)
                    {
                        e[pre[X]].c+=aug;
                        e[rev(pre[X])].c-=aug;
                        X=e[pre[X]].t;
                    }
                    aug=inf;
                }
                break;
            }
        if(flag)continue;

        vh[dis[X]]--;
        if(vh[dis[X]]==0)break;

        int mi=n,mii;
        for(int i=g[X];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        dis[X]=mi+1;
        vh[dis[X]]++;
        di[X]=mii;

        if(X!=1)
        {
            X=e[pre[X]].t;
            aug=his[X];
        }
    }
    return flow;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    scanf("%d%d",&amp;S,&amp;T);
    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        in[i]=i&lt;&lt;1;out[i]=i&lt;&lt;1|1;
        add_edge(in[i],out[i],x);
    }
    add_edge(1,in[S],inf);
    n=(n&lt;&lt;1)+2;
    add_edge(out[T],n,inf);
    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(out[x],in[y],inf);
        add_edge(out[y],in[x],inf);
    }
    printf("%d\n",isap());
    return 0;
}
<pre><h2>Problem1342</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,x,c,h1,t1,h2,t2;
bool flag=false;

struct size
{
	int c,t;
}minq[1000010],maxq[1000010];

inline void pushmin(int x,int p)
{
	while(x&lt;=minq[t1].c&amp;&amp;t1&gt;=h1)t1--;
	minq[++t1].c=x;
	minq[t1].t=p;
}

inline void pushmax(int x,int p)
{
	while(x&gt;=maxq[t2].c&amp;&amp;t2&gt;=h2)t2--;
	maxq[++t2].c=x;
	maxq[t2].t=p;
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;c);
	h1=t1=h2=t2=1;
	scanf("%d",&amp;x);
	minq[1].c=maxq[1].c=x;
	minq[1].t=maxq[1].t=1;
	
	for(int i=2;i&lt;=m;i++)
	{
		scanf("%d",&amp;x);
		pushmin(x,i);
		pushmax(x,i);
	}
	
	for(int i=m+1;i&lt;=n;i++)
	{
		if(maxq[h2].c-minq[h1].c&lt;=c)
		{
			printf("%d\n",i-m);
			flag=true;
		}
		scanf("%d",&amp;x);
		pushmin(x,i);
		pushmax(x,i);
		
		while(minq[h1].t&lt;=i-m)h1++;
		while(maxq[h2].t&lt;=i-m)h2++;
	}
	if(maxq[h2].c-minq[h1].c&lt;=c)
	{
		printf("%d\n",n+1-m);
		flag=true;
	}
	if(!flag)
		printf("NONE\n");
	
	return 0;
}<pre><h2>Problem1349</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

unsigned long long n;

int main()
{
	scanf("%lld",&amp;n);
	
	unsigned long long ans=(unsigned long long)(sqrt(n));
	
	if(ans&gt;=n)
		printf("%lld\n",ans);
	else
		printf("%lld\n",ans+1);
	
	return 0;
}<pre><h2>Problem1351</h2><pre>int main(){return 0;}<pre><h2>Problem1354</h2><pre>int main(){return 0;}<pre><h2>Problem1355</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n;
int next[1000010];
char str[1000010];

inline void get_next()
{
    next[0]=-1;
    int j=-1;
    for(int i=1;i&lt;n;i++)
    {
        while(j!=-1&amp;&amp;str[j+1]!=str[i])j=next[j];
        if(str[j+1]==str[i])j++;
        next[i]=j;
    }
}

int main()
{
    scanf("%d",&amp;n);
    scanf("%s",str);

    get_next();

    printf("%d\n",n-next[n-1]-1);

    return 0;
}<pre><h2>Problem1359</h2><pre>int main(){return 0;}<pre><h2>Problem1360</h2><pre>int main(){return 0;}<pre><h2>Problem1370</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,ans;
char ch[5];
int bel[1010];
int fa[2010],rnk[2010];
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}
inline void unio(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(fx==fy)return;
    if(rnk[fx]&lt;rnk[fy])
        fa[fx]=fy;
    else
    {
        fa[fy]=fx;
        if(rnk[fx]==rnk[fy])rnk[fx]++;
    }
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=(n&lt;&lt;1);i++)
        fa[i]=i;
    for(int i=1;i&lt;=m;i++)
    {
        scanf("%s",ch);
        int x=read(),y;y=read();
        if(ch[0]=='F')
            unio(x,y);
        else
        {
            unio(x,y+n);unio(y,x+n);
        }
    }

    for(int i=1;i&lt;=n;i++)
        bel[i]=find(i);
    sort(bel+1,bel+n+1);
    for(int i=1;i&lt;=n;i++)
        if(bel[i]!=bel[i-1])
            ans++;
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1391</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int INF=1000000000;

int n,m,S=1,T,cnt,sum;
int g[2500],vh[2500],di[2500],dis[2500],pre[2500],his[2500];
struct edge
{
    int t,c,next;
}e[3000000];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline int rev(int x)
{
    return x&amp;1?x+1:x-1;
}

inline int isap()
{
    vh[0]=T;
    for(int i=S;i&lt;=T;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;

    while(dis[1]&lt;T)
    {
        his[x]=aug;
        bool flag=false;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[x]==dis[e[i].t]+1)
            {
                flag=true;
                di[x]=i;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=rev(i);
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[rev(pre[x])].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        int mi=T,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;
        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();m=read();
    T=n+m+2;
    for(int i=1;i&lt;=n;i++)
    {
        int x=read();sum+=x;
        add_edge(1,i+1,x);
        x=read();
        for(int j=1;j&lt;=x;j++)
        {
            int y=read(),z;z=read();
            add_edge(i+1,y+n+1,z);
        }
    }
    for(int i=1;i&lt;=m;i++)
    {
        int x=read();
        add_edge(i+n+1,T,x);
    }

    printf("%d\n",sum-isap());

    return 0;
}
<pre><h2>Problem1411</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n;
int pre[100010],state[100010];
long long T;

int main()
{
    scanf("%d%lld",&amp;n,&amp;T);
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",state+i);
        state[i]--;
    }

    long long p;
    for(p=1;p&lt;=(T&gt;&gt;1);p&lt;&lt;=1)
    {
        if(p&amp;(T&gt;&gt;1))
        {
            memcpy(pre,state,sizeof(long)*(n+1));
            for(int i=1;i&lt;=n;i++)
            {
                int temp=p%n;
                state[i]=pre[(i-temp+n-1)%n+1]^pre[(i+temp-1)%n+1];
            }
        }
    }
    state[0]=state[n];
    state[n+1]=state[1];

    if(T&amp;1)
        for(int i=1;i&lt;n;i++)
            printf("0 %d ",(state[i]^state[i+1])+1);
    else
        for(int i=1;i&lt;n;i++)
            printf("%d 0 ",state[i]+1);

    if(T&amp;1)
        printf("0 %d\n",(state[n]^state[n+1])+1);
    else
        printf("%d 0\n",state[n]+1);

    return 0;
}
<pre><h2>Problem1412</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

int n,m,siz=-1;
int xx[4]={0,0,1,-1},yy[4]={1,-1,0,0},mp[105][105];
int ch[10010];
int vh[10010],dis[10010],pre[10010],di[10010],his[10010];

vector&lt;int&gt; g[10010];

struct size
{
    int t,c;
}edge[300000];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    edge[++siz].t=y;
    edge[siz].c=z;
    ch[x]++;
    g[x].push_back(siz);

    edge[++siz].t=x;
    edge[siz].c=0;
    ch[y]++;
    g[y].push_back(siz);
}

inline int isap()
{
    vh[0]=n;
    memset(di,0,sizeof(di));
    int flow=0,aug=inf,i=1;

    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[i]=aug;

        for(int x=di[i];x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]+1==dis[i])
            {
                di[i]=x;
                aug=min(aug,edge[g[i][x]].c);
                flag=true;
                pre[edge[g[i][x]].t]=g[i][x]^1;
                i=edge[g[i][x]].t;

                if(i==n)
                {
                    flow+=aug;

                    while(i!=1)
                    {
                        edge[pre[i]].c+=aug;
                        edge[pre[i]^1].c-=aug;
                        i=edge[pre[i]].t;
                    }

                    aug=inf;
                }

                break;
            }

        if(flag)continue;

        int mi=n,mii;

        for(int x=0;x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]&lt;mi)
                mi=dis[edge[g[i][x]].t],mii=x;

        vh[dis[i]]--;
        if(vh[dis[i]]==0)break;
        dis[i]=mi+1;

        vh[dis[i]]++;
        di[i]=mii;

        if(i!=1)
        {
            i=edge[pre[i]].t;
            aug=his[i];
        }
    }

    return flow;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf("%d",&amp;mp[i][j]);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            if(mp[i][j]==1)add_edge(1,(i-1)*m+j+1,inf);
            else if(mp[i][j]==2)add_edge((i-1)*m+j+1,n*m+2,inf);
            for(int k=0;k&lt;4;k++)
            {
                int nowx=i+xx[k],nowy=j+yy[k];
                if(nowx&lt;1||nowx&gt;n||nowy&lt;1||nowy&gt;m||mp[i][j]==2)continue;
                if(mp[i][j]!=1||mp[nowx][nowy]!=1)
                    add_edge((i-1)*m+j+1,(nowx-1)*m+nowy+1,1);
            }
        }

    n=n*m+2;
    printf("%d\n",isap());

    return 0;
}
<pre><h2>Problem1413</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int t,n,x,y;

inline int abs(int x)
{
	return x&lt;0?-x:x;
}

int main()
{
	scanf("%d",&amp;t);
	for(;t;t--)
	{
		scanf("%d",&amp;n);
		scanf("%d",&amp;x);
		for(int i=2;i&lt;=n;i++)scanf("%d",&amp;y);
		if(abs(x-y)&lt;=1)
			printf("0\n");
		else
			printf("1\n");
	}
	
	return 0;
}
<pre><h2>Problem1432</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,k;

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;k);

    if(n==1)
        printf("1\n");
    else
    {
        printf("%d\n",2*min(k,n+1-k));
    }

    return 0;
}
<pre><h2>Problem1433</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

int n,t,cnt;
int g[110],di[110],dis[110],vh[110],his[110],pre[110];
int school[110];

struct size
{
    int t,c,next;
}e[10000];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int isap()
{
    memset(vh,0,sizeof(vh));
    memset(dis,0,sizeof(dis));
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)di[i]=g[i];

    int x=1,flow=0,aug=inf;

    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[x]=aug;

        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[x]==dis[e[i].t]+1)
            {
                aug=min(aug,e[i].c);
                flag=true;
                di[x]=i;
                pre[e[i].t]=i&amp;1?i+1:i-1;
                x=e[i].t;

                if(x==n)
                {
                    flow+=aug;
                    for(;x!=1;x=e[pre[x]].t)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]&amp;1?pre[x]+1:pre[x]-1].c-=aug;
                    }
                    aug=inf;
                }
                break;
            }
        if(flag)continue;

        int mi=n,mii=0;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
        {
            mi=dis[e[i].t];
            mii=i;
        }

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;
        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=1)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    scanf("%d",&amp;t);

    while(t--)
    {
        memset(g,0,sizeof(g));
        cnt=0;
        int sum=0;
        scanf("%d",&amp;n);

        for(int i=1;i&lt;=n;i++)
        {
            int x;
            scanf("%d",school+i);
            if(school[i])add_edge(i+n+1,n+n+2,1);
        }

        for(int i=1;i&lt;=n;i++)
        {
            int x;
            scanf("%d",&amp;x);

            if((school[i]&amp;&amp;!x)||!school[i])
            {
                add_edge(1,i+1,1);
                sum++;
            }
        }

        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
        {
            int x;
            scanf("%d",&amp;x);

            if(x||i==j)add_edge(i+1,j+n+1,1);
        }

        n+=n+2;

        if(isap()==sum)
            printf("%c%c%c\n",94,95,94);
        else
            printf("%c%c%c\n",84,95,84);
    }

    return 0;
}
<pre><h2>Problem1443</h2><pre>#include &lt;stdio.h&gt;

int m,s,t,flow=0,delta,x=0,i,j,stp=0,N,M,all=-1;
int dis[10002],gap[30001],win[10002],v[10002];
char str[100][101];

struct edge
{
    int x,y,w;
    struct edge *opp,*next;
}*map[10002],*neck[10002],*from[10002],*cur[10002],st[60000],*f;

__inline void add_edge(x,y)
{
    st[stp].next=map[st[stp^1].y=st[stp].x=x];
    st[stp^1].next=map[st[stp].y=st[stp^1].x=y];
    (st[stp^1].opp=map[x]=st+stp)-&gt;w=1;st[stp].opp=map[y]=st+(stp^1);
    stp+=2;
}

void dfs(x)
{
    struct edge *p=map[x];
    if((((x%M^x/M))&amp;1)==i)
        all++,win[x]=1;
    for(v[x]=1;p;p=p-&gt;next)
        if(p-&gt;w==i&amp;&amp;!v[p-&gt;y])
            dfs(p-&gt;y);
}

main()
{
    scanf("%d%d\n",&amp;N,&amp;M);

    gap[m]=N*M+2;
    s=N*M;
    t=s+1;
    for(i=0;i&lt;N;i++)gets(str[i]);
    for(i=0;i&lt;N;i++)
        for(j=0;j&lt;M;j++,x++)
        {
            if(str[i][j]=='#')
                continue;
            if((i^j)&amp;1)
            {
                add_edge(s,x);
                if(i&amp;&amp;str[i-1][j]=='.')
                    add_edge(x,x-M);
                if(j&amp;&amp;str[i][j-1]=='.')
                    add_edge(x,x-1);
                if(i!=N-1&amp;&amp;str[i+1][j]=='.')
                    add_edge(x,x+M);
                if(j!=M-1&amp;&amp;str[i][j+1]=='.')
                    add_edge(x,x+1);
            }
            else
                add_edge(x,t);
        }
    for(m=stp&gt;&gt;1,i=s;dis[s]&lt;=m;)
    {
        for(cur[i]||(cur[i]=map[i]);cur[i];cur[i]=cur[i]-&gt;next)
            if(cur[i]-&gt;w&amp;&amp;dis[cur[i]-&gt;y]+1==dis[i])
            {
                neck[(from[cur[i]-&gt;y]=cur[i])-&gt;y]=s==i?cur[i]:neck[i]-&gt;w&gt;cur[i]-&gt;w?cur[i]:neck[i];
                if(t==(i=cur[i]-&gt;y))
                {
                    for(flow+=delta=neck[t]-&gt;w;i!=s;i=from[i]-&gt;x)
                        from[i]-&gt;w-=delta,from[i]-&gt;opp-&gt;w+=delta;
                    i=neck[t]-&gt;x;
                }
                break;
            }
        if(!cur[i])
        {
            if(!--gap[dis[i]])break;
            for(dis[i]=m,f=map[i];f;f=f-&gt;next)
                if(f-&gt;w&amp;&amp;dis[f-&gt;y]&lt;dis[i])
                    dis[i]=dis[(cur[i]=f)-&gt;y];
            gap[++dis[i]]++;
            i=i==s?s:from[i]-&gt;x;
        }
    }
    i=1;
    dfs(s);
    i=0;
    dfs(t);

    if(all)
    {
        puts("WIN");
        for(;i&lt;s;i++)
            if(win[i])
                printf("%d %d\n",i/M+1,i%M+1);
    }
    else
        puts("LOSE");

    return 0;
}
<pre><h2>Problem1443</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int m,s,t,flow=0,delta,x=0,i,j,stp=0,N,M,all=-1;
int dis[10010],gap[30010],win[10010],v[10010];
char str[110][110];

struct edge
{
    int x,y,w;
    struct edge *opp,*next;
}*map[10010],*neck[10010],*from[10010],*cur[10010],st[60010],*f;

inline void add_edge(int x,int y)
{
    st[stp].next=map[st[stp^1].y=st[stp].x=x];
    st[stp^1].next=map[st[stp].y=st[stp^1].x=y];
    (st[stp^1].opp=map[x]=st+stp)-&gt;w=1;st[stp].opp=map[y]=st+(stp^1);
    stp+=2;
}

void dfs(int x)
{
    struct edge *p=map[x];
    if((((x%M^x/M))&amp;1)==i)
        all++,win[x]=1;
    for(v[x]=1;p;p=p-&gt;next)
        if(p-&gt;w==i&amp;&amp;!v[p-&gt;y])
            dfs(p-&gt;y);
}

int main()
{
    scanf("%d%d\n",&amp;N,&amp;M);

    gap[m]=N*M+2;
    s=N*M;
    t=s+1;
    for(i=0;i&lt;N;i++)gets(str[i]);
    for(i=0;i&lt;N;i++)
        for(j=0;j&lt;M;j++,x++)
        {
            if(str[i][j]=='#')
                continue;
            if((i^j)&amp;1)
            {
                add_edge(s,x);
                if(i&amp;&amp;str[i-1][j]=='.')
                    add_edge(x,x-M);
                if(j&amp;&amp;str[i][j-1]=='.')
                    add_edge(x,x-1);
                if(i!=N-1&amp;&amp;str[i+1][j]=='.')
                    add_edge(x,x+M);
                if(j!=M-1&amp;&amp;str[i][j+1]=='.')
                    add_edge(x,x+1);
            }
            else
                add_edge(x,t);
        }
    for(m=stp&gt;&gt;1,i=s;dis[s]&lt;=m;)
    {
        for(cur[i]||(cur[i]=map[i]);cur[i];cur[i]=cur[i]-&gt;next)
            if(cur[i]-&gt;w&amp;&amp;dis[cur[i]-&gt;y]+1==dis[i])
            {
                neck[(from[cur[i]-&gt;y]=cur[i])-&gt;y]=s==i?cur[i]:neck[i]-&gt;w&gt;cur[i]-&gt;w?cur[i]:neck[i];
                if(t==(i=cur[i]-&gt;y))
                {
                    for(flow+=delta=neck[t]-&gt;w;i!=s;i=from[i]-&gt;x)
                        from[i]-&gt;w-=delta,from[i]-&gt;opp-&gt;w+=delta;
                    i=neck[t]-&gt;x;
                }
                break;
            }
        if(!cur[i])
        {
            if(!--gap[dis[i]])break;
            for(dis[i]=m,f=map[i];f;f=f-&gt;next)
                if(f-&gt;w&amp;&amp;dis[f-&gt;y]&lt;dis[i])
                    dis[i]=dis[(cur[i]=f)-&gt;y];
            gap[++dis[i]]++;
            i=i==s?s:from[i]-&gt;x;
        }
    }
    i=1;
    dfs(s);
    i=0;
    dfs(t);

    if(all)
    {
        puts("WIN");
        for(;i&lt;s;i++)
            if(win[i])
                printf("%d %d\n",i/M+1,i%M+1);
    }
    else
        puts("LOSE");

    return 0;
}
<pre><h2>Problem1452</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,t,x,y,x1,y1,c;
int a[310][310];
int tr[310][310][110];

inline int lowbit(int x)
{
	return x&amp;-x;
}

inline void add(int x,int y,int c)
{
	for(;x&lt;=n;x+=lowbit(x))
		for(int j=y;j&lt;=m;j+=lowbit(j))
			tr[x][j][c]++;
}

inline void dec(int x,int y,int c)
{
	for(;x&lt;=n;x+=lowbit(x))
		for(int j=y;j&lt;=m;j+=lowbit(j))
			tr[x][j][c]--;
}

inline int query(int x,int y,int c)
{
	int temp=0;
	for(;x;x-=lowbit(x))
		for(int j=y;j;j-=lowbit(j))
			temp+=tr[x][j][c];
	return temp;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
		{
			scanf("%d",&amp;a[i][j]);
			add(i,j,a[i][j]);
		}
	
	scanf("%d",&amp;t);
	
	for(;t;t--)
	{
		scanf("%d",&amp;x);
		if(x==1)
		{
			scanf("%d%d%d",&amp;x,&amp;y,&amp;c);
			dec(x,y,a[x][y]);
			add(x,y,a[x][y]=c);
		}
		else
		{
			scanf("%d%d%d%d%d",&amp;x,&amp;x1,&amp;y,&amp;y1,&amp;c);
			printf("%d\n",query(x1,y1,c)-query(x1,y-1,c)-query(x-1,y1,c)+query(x-1,y-1,c));
		}
	}
	
	return 0;
}<pre><h2>Problem1458</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int INF=1000000000;

int n,m,k,S=1,T,cnt=1;
int L[110],C[110];
int mp[110][110];
int g[210],vh[210],di[210],dis[210],pre[210],his[210];
struct edge
{
    int t,c,next;
}e[50000];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int isap()
{
    vh[0]=T;
    for(int i=S;i&lt;=T;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;

    while(dis[1]&lt;T)
    {
        his[x]=aug;
        bool flag=false;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[x]==dis[e[i].t]+1)
            {
                flag=true;
                di[x]=i;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        int mi=T,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;
        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();m=read();k=read();
    T=n+m+2;
    for(int i=1;i&lt;=n;i++)
    {
        L[i]=m-read();
        if(L[i]&lt;0){printf("JIONG!");return 0;}
    }
    for(int i=1;i&lt;=m;i++)
    {
        C[i]=n-read();
        if(C[i]&lt;0){printf("JIONG!");return 0;}
    }
    for(int i=1;i&lt;=k;i++)
    {
        int x=read(),y;y=read();
        mp[x][y]=1;
        L[x]--;
        if(L[i]&lt;0){printf("JIONG!");return 0;}
        C[y]--;
        if(C[i]&lt;0){printf("JIONG!");return 0;}
    }

    for(int i=1;i&lt;=n;i++)
        add_edge(S,1+i,L[i]);
    for(int i=1;i&lt;=m;i++)
        add_edge(1+n+i,T,C[i]);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            if(!mp[i][j])
                add_edge(1+i,1+n+j,1);

    printf("%d\n",n*m-k-isap());

    return 0;
}
<pre><h2>Problem1461</h2><pre>    #include&lt;cstdio&gt;
    #include&lt;cstring&gt;

    using namespace std;

    int n,k,s;
    int a[500010],b[500010];
    int next[500010],ans[500010];
    int tr1[10010],tr2[10010];

    inline int lowbit(int x)
    {
        return x&amp;-x;
    }

    inline void add1(int x)
    {
        for(;x&lt;=s;x+=lowbit(x))
            tr1[x]++;
    }
    inline void add2(int x)
    {
        for(;x&lt;=s;x+=lowbit(x))
            tr2[x]++;
    }

    inline void dec1(int x)
    {
        for(;x&lt;=s;x+=lowbit(x))
            tr1[x]--;
    }
    inline void dec2(int x)
    {
        for(;x&lt;=s;x+=lowbit(x))
            tr2[x]--;
    }

    inline int query1(int x)
    {
        int temp=0;
        for(;x;x-=lowbit(x))
            temp+=tr1[x];
        return temp;
    }
    inline int query2(int x)
    {
        int temp=0;
        for(;x;x-=lowbit(x))
            temp+=tr2[x];
        return temp;
    }

    inline bool same1(int x,int y)
    {
        return query1(a[x]-1)==query2(b[y]-1)&amp;&amp;query1(a[x])==query2(b[y]);
    }
    inline bool same2(int x,int y)
    {
        return query1(b[x]-1)==query2(b[y]-1)&amp;&amp;query1(b[x])==query2(b[y]);
    }

    inline void get_next()
    {
        next[1]=0;
        int j=0;
        for(int i=2;i&lt;=k;i++)
        {
            while(j!=0&amp;&amp;!same2(i,j+1))
            {
                for(int kk=j;kk&gt;next[j];kk--)
                {
                    dec2(b[kk]);
                    dec1(b[i-kk]);
                }
                j=next[j];
            }
            j++;
            next[i]=j;
            add1(b[i]);
            add2(b[j]);
        }
    }

    inline void kmp()
    {
        int j=0;
        for(int i=1;i&lt;=n;i++)
        {
            while(j!=0&amp;&amp;!same1(i,j+1))
            {
                //printf("##%d %d\n",i,j);
                //printf("###%d %d %d %d\n",query1(a[i]),query1(a[i]-1),query2(b[j+1]),query2(b[j+1]-1));
                for(int kk=j;kk&gt;next[j];kk--)
                {
                    dec2(b[kk]);
                    dec1(a[i-kk]);
                }
                j=next[j];
            }
            j++;
            add2(b[j]);

            if(j==k)
            {
                ans[++ans[0]]=i-k+1;

                for(int kk=j;kk&gt;next[j];kk--)
                {
                    dec2(b[kk]);
                    dec1(a[i-kk+1]);
                }
                j=next[j];
            }

            add1(a[i]);
        }
    }

    int main()
    {
        scanf("%d%d%d",&amp;n,&amp;k,&amp;s);

        for(int i=1;i&lt;=n;i++)scanf("%d",a+i);
        for(int i=1;i&lt;=k;i++)scanf("%d",b+i);

        get_next();

        memset(tr1,0,sizeof(tr1));
        memset(tr2,0,sizeof(tr2));

        kmp();

        for(int i=0;i&lt;=ans[0];i++)
            printf("%d\n",ans[i]);

        return 0;
    }
<pre><h2>Problem1468</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,cnt,K,num,sum,root,ans;
int g[40010],v[40010],siz[40010],f[40010],dist[40010];
struct edge
{
    int t,c,next;
}e[80010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}

inline void dfs(int x,int y,int fa)
{
    dist[++num]=y;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs(e[i].t,y+e[i].c,x);
}
inline int calc(int x,int dis)
{
    num=0;
    dfs(x,dis,0);
    int temp=0;
    sort(dist+1,dist+num+1);
    for(int i=1;i&lt;=num;i++)
        if(dist[i]&lt;=K)
            temp+=upper_bound(dist+1,dist+num+1,K-dist[i])-dist-1;
        else
            break;
    return temp;
}
inline void get_root(int x,int fa)
{
    siz[x]=1;f[x]=0;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
        {
            get_root(e[i].t,x);
            siz[x]+=siz[e[i].t];
            f[x]=Max(f[x],siz[e[i].t]);
        }
    f[x]=Max(f[x],sum-siz[x]);
    if(f[x]&lt;f[root])root=x;
}
inline void work(int x)
{
    v[x]=1;
    ans+=calc(x,0);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            ans-=calc(e[i].t,e[i].c);
            sum=num;root=0;
            get_root(e[i].t,0);
            work(e[i].t);
        }
}
int main()
{
    n=read();
    for(int i=1;i&lt;n;i++)
    {
        int x=read(),y,z;y=read();z=read();
        add_edge(x,y,z);
        add_edge(y,x,z);
    }
    K=read();

    f[0]=n;sum=n;
    get_root(1,0);
    work(1);

    printf("%d\n",(ans-n)/2);

    return 0;
}
<pre><h2>Problem1469</h2><pre>int main(){return 0;}<pre><h2>Problem1482</h2><pre>int main(){return 0;}<pre><h2>Problem1488</h2><pre>#include&lt;cstdio&gt;
int ans[]={1,1,2,4,11,34,156,47,382,493,291,56,400,993,778,96,890,888,766,749,7,304,785,887,46,799,403,68,742,852,567,582,803,231,122,61,761,151,931,617,870,170,736,521,412,976,217,383,119,447,314,793,952,321,665,663,780,791,78,403,683};
int main()
{
    int x;
    scanf("%d",&amp;x);
    printf("%d\n",ans[x]);
    return 0;
}
<pre><h2>Problem1497</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

int n,m,x,y,z,size=-1;
int vh[60010],dis[60010],his[60010],pre[60010],ans=0;

struct size
{
	int x,y,c;
}edge[500010];

struct size1
{
	int num;
	size1 *next;
}*graph[60010],*di[60010];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	edge[++size].x=x;
	edge[size].y=y;
	edge[size].c=z;
	
	size1 *p=new size1;
	p-&gt;num=size;
	p-&gt;next=graph[x];
	graph[x]=p;
	
	edge[++size].x=y;
	edge[size].y=x;
	edge[size].c=0;
	
	p=new size1;
	p-&gt;num=size;
	p-&gt;next=graph[y];
	graph[y]=p;
}

inline int sap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)di[i]=graph[i];
	int i=1,aug=inf,flow=0;
	
	while(dis[1]&lt;n)
	{
		his[i]=aug;
		bool flag=false;
		size1 *p=di[i];
		while(p!=NULL)
		{
			if(edge[p-&gt;num].c&amp;&amp;dis[edge[p-&gt;num].y]+1==dis[i])
			{
				flag=true;
				di[i]=p;
				aug=min(aug,edge[p-&gt;num].c);
				pre[edge[p-&gt;num].y]=p-&gt;num^1;
				i=edge[p-&gt;num].y;
				if(i==n)
				{
					flow+=aug;
					while(i!=1)
					{
						edge[pre[i]].c+=aug;
						edge[pre[i]^1].c-=aug;
						i=edge[pre[i]].y;
					}
					aug=inf;
				}
				break;
			}
			p=p-&gt;next;
		}
		
		if(flag)continue;
		
		int mi=n-1;
		size1 *p1;
		p=graph[i];
		
		while(p!=NULL)
		{
			if(edge[p-&gt;num].c&gt;0&amp;&amp;dis[edge[p-&gt;num].y]&lt;mi)
				p1=p,mi=dis[edge[p-&gt;num].y];
			p=p-&gt;next;
		}
		
		di[i]=p1;
		vh[dis[i]]--;
		if(vh[dis[i]]==0)break;
		
		dis[i]=mi+1;
		vh[dis[i]]++;
		if(i!=1)
		{
			i=edge[pre[i]].y;
			aug=his[i];
		}
	}
	
	return flow;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);

	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;x);
		add_edge(1,i+1,x);
	}
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		ans+=z;
		add_edge(1+x,1+n+i,inf);
		add_edge(1+y,1+n+i,inf);
		add_edge(1+n+i,2+n+m,z);
	}
	
	n=2+m+n;
	
	printf("%d\n",ans-sap());

	return 0;
}
<pre><h2>Problem1497</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

int n,m,siz=-1,ans;
int ch[60010];
int vh[60010],dis[60010],pre[60010],di[60010],his[60010];

vector&lt;int&gt; g[60010];

struct size
{
    int t,c;
}edge[500000];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    edge[++siz].t=y;
    edge[siz].c=z;
    ch[x]++;
    g[x].push_back(siz);

    edge[++siz].t=x;
    edge[siz].c=0;
    ch[y]++;
    g[y].push_back(siz);
}

inline int isap()
{
    vh[0]=n;
    memset(di,0,sizeof(di));
    int flow=0,aug=inf,i=1;

    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[i]=aug;

        for(int x=di[i];x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]+1==dis[i])
            {
                di[i]=x;
                aug=min(aug,edge[g[i][x]].c);
                flag=true;
                pre[edge[g[i][x]].t]=g[i][x]^1;
                i=edge[g[i][x]].t;

                if(i==n)
                {
                    flow+=aug;

                    while(i!=1)
                    {
                        edge[pre[i]].c+=aug;
                        edge[pre[i]^1].c-=aug;
                        i=edge[pre[i]].t;
                    }

                    aug=inf;
                }

                break;
            }

        if(flag)continue;

        int mi=inf,mii;

        for(int x=0;x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]&lt;mi)
                mi=dis[edge[g[i][x]].t],mii=x;

        vh[dis[i]]--;
        if(vh[dis[i]]==0)break;
        dis[i]=mi+1;

        vh[dis[i]]++;
        di[i]=mii;

        if(i!=1)
        {
            i=edge[pre[i]].t;
            aug=his[i];
        }
    }

    return flow;
}
/*
int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
    }

    printf("%d\n",isap());

    return 0;
}
*/
int main()
{
	scanf("%d%d",&amp;n,&amp;m);

	for(int i=1;i&lt;=n;i++)
	{
	    int x;
		scanf("%d",&amp;x);
		add_edge(1,i+1,x);
	}

	for(int i=1;i&lt;=m;i++)
	{
	    int x,y,z;
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		ans+=z;
		add_edge(1+x,1+n+i,inf);
		add_edge(1+y,1+n+i,inf);
		add_edge(1+n+i,2+n+m,z);
	}

	n=2+m+n;

	printf("%d\n",ans-isap());

	return 0;
}

/*
2 1
1 2 1
*/
<pre><h2>Problem1503</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

using namespace std;

const int maxn=1&lt;&lt;18;

int n,m,ans;
int tot,delta;
char com;
int f[maxn+10],b[maxn+10],now;

inline int lowbit(int x)
{
    return x&amp;-x;
}

inline void ins(int pos,int v)
{
     for(;pos&lt;=maxn;pos+=lowbit(pos))
        f[pos]+=v;
}

int find(int x)
{
    int an=0,cnt=0;
    if(x&lt;1)return -1;
    for(int i=17;i&gt;=0;i--)
        if((an+(1&lt;&lt;i))&lt;maxn&amp;&amp;cnt+f[an+(1&lt;&lt;i)]&lt;x)
            an+=(1&lt;&lt;i),cnt+=f[an];
    return an+1-delta;
}

int main()
{
    com=0;
    memset(f,0,sizeof(f));
    memset(b,0,sizeof(b));

    scanf("%d%d",&amp;n,&amp;m);
    delta=100001;now=ans=0;

    while(n--)
    {
        int x;
        while(com!='I'&amp;&amp;com!='A'&amp;&amp;com!='S'&amp;&amp;com!='F')com=getchar();
        scanf("%d",&amp;x);
        if(com=='I')
        {
            if(x&gt;=m)
                ins(x+delta,1),b[x+delta]++,now++;
        }
        if(com=='A')
            delta-=x;
        if(com=='S')
        {
            for(int j=delta+m;j&lt;=delta+m+x-1;j++)
                if(j&gt;0&amp;&amp;b[j]&gt;0)
                {
                    ins(j,-b[j]);
                    ans+=b[j];
                    now-=b[j];
                    b[j]=0;
                }
            delta+=x;
        }
        if(com=='F')
            printf("%d\n",find(now-x+1));
        com=0;
    }
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1509</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int maxint=1000000000;

int que[200010],n,m;
long long dist[200010],dist1[200010];
bool inque[200010];

struct size
{
	int child,dist;
	size *next;
}*tree[200010];

inline long long max(long long a,long long b)
{
	return a&gt;b?a:b;
}

inline long long min(long long a,long long b)
{
	return a&lt;b?a:b;
}
inline int bfs(int x)
{
	int h=1,t=1;
	que[1]=x;
	for(int i=1;i&lt;=n;i++)inque[i]=false;
	inque[x]=true;
	dist[x]=0;
	
	while(h&lt;=t)
	{
		int x=que[h++];
		size *p=tree[x];
		
		while(p!=NULL)
		{
			if(!inque[p-&gt;child])
			{
				dist[p-&gt;child]=dist[x]+p-&gt;dist;
				inque[p-&gt;child]=true;
				que[++t]=p-&gt;child;
			}
			p=p-&gt;next;
		}
	}
	
	long long maxx=0;
	int k;
	for(int i=1;i&lt;=n;i++)
	  if(dist[i]&gt;maxx)
	    maxx=dist[i],k=i;

	return k;
}

inline void bfs1(int x)
{
	int h=1,t=1;
	que[1]=x;
	for(int i=1;i&lt;=n;i++)inque[i]=false;
	inque[x]=true;
	dist1[x]=0;
	
	while(h&lt;=t)
	{
		int x=que[h++];
		size *p=tree[x];
		
		while(p!=NULL)
		{
			if(!inque[p-&gt;child])
			{
				dist1[p-&gt;child]=dist1[x]+p-&gt;dist;
				inque[p-&gt;child]=true;
				que[++t]=p-&gt;child;
			}
			p=p-&gt;next;
		}
	}
}

int main()
{

	scanf("%d%d",&amp;n,&amp;m);
	
	size *p;
	
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		
		p=new size;
		
		p-&gt;child=y;
		p-&gt;dist=z;
		p-&gt;next=tree[x];
		tree[x]=p;
		
		p=new size;
		p-&gt;child=x;
		p-&gt;dist=z;
		p-&gt;next=tree[y];
		tree[y]=p;
	}
	
	int s=bfs(1);
	int t=bfs(s);
	bfs1(t);
	
	long long ans=0;
	for(int i=1;i&lt;=n;i++)
	  if(i!=s&amp;&amp;i!=t)
	    ans=max(ans,min(dist[i],dist1[i]));
	
	printf("%lld\n",dist[t]+ans);
	
	return 0;
}<pre><h2>Problem1520</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int S=401,T=402,N=405;
const int INF=2139062143;

int n,cnt=1,ans=0,sum=0;
int g[410];
int dist[410],pre[410],flow[410],q[410],v[410];
struct edge
{
    int t,c,cst,next;
}e[100010];
inline void add_edge(int x,int y,int z1,int z2)
{
    e[++cnt].t=y;
    e[cnt].c=z1;
    e[cnt].cst=z2;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].cst=-z2;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Abs(int x)
{
    return x&lt;0?-x:x;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline bool spfa()
{
    memset(dist,127,sizeof(dist));
    dist[S]=0;q[1]=S;v[S]=1;flow[S]=INF;
    int h=0,t=1;

    while(h!=t)
    {
        h=h%N+1;
        int x=q[h];
        v[x]=0;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dist[x]+e[i].cst&lt;dist[e[i].t])
        {
            dist[e[i].t]=dist[x]+e[i].cst;
            pre[e[i].t]=i^1;
            flow[e[i].t]=Min(flow[x],e[i].c);

            if(!v[e[i].t])
            {
                v[e[i].t]=1;
                t=t%N+1;
                q[t]=e[i].t;
            }
        }
    }
    return dist[T]!=INF;
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
    {
        add_edge(S,i,1,0);
        int m=read(),a,b,k;a=read();b=read();k=read();
        for(int j=a;j&lt;=b;j++)
            add_edge(i,j+n,1,Abs(m-j)*k);
    }
    for(int i=1;i&lt;=n;i++)
        add_edge(i+n,T,1,0);

    while(spfa())
    {
        sum+=flow[T];
        ans+=flow[T]*dist[T];
        int x=T;
        while(x!=S)
        {
            e[pre[x]].c+=flow[T];
            e[pre[x]^1].c-=flow[T];
            x=e[pre[x]].t;
        }
    }

    if(sum==n)
        printf("%d\n",ans);
    else
        printf("NIE\n");

    return 0;
}
<pre><h2>Problem1532</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int INF=1000000000;

int n,m,cnt,ans,C;
int S=20001,T=20002;
int g[20010],x[20010],y[20010];
int vh[20010],dis[20010],di[20010],pre[20010],his[20010];
struct edge
{
    int t,c,next;
}e[100010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}

inline int isap()
{
    memset(vh,0,sizeof(vh));
    vh[0]=n;
    for(int i=1;i&lt;=n+m;i++)di[i]=g[i];
    di[S]=g[S],di[T]=g[T];
    int x=S,aug=INF,flow=0;

    while(dis[S]&lt;n+m+2)
    {
        if(C&gt;n*10000)return 0;
        C++;
        bool flag=false;
        his[x]=aug;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[x]==dis[e[i].t]+1)
            {
                di[x]=i;
                flag=true;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    if(flow==m)return m;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;
        C+=n;
        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;

        int mi=n+m+2,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }
        di[x]=mii;
        dis[x]=mi+1;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}
inline bool check(int val)
{
    memset(g,0,sizeof(g));
    cnt=1;
    for(int i=1;i&lt;=m;i++)
    {
        dis[i]=2;
        add_edge(S,i,1);
        add_edge(i,x[i]+m,1);
        add_edge(i,y[i]+m,1);
    }
    for(int i=1;i&lt;=n;i++)
    {
        dis[i+m]=1;
        add_edge(i+m,T,val);
    }
    dis[S]=3;dis[T]=0;
    return isap()==m;
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=m;i++)
    {
        x[i]=read();
        y[i]=read();
    }

    int l=0,r=500;
    while(l&lt;=r)
    {
        C=0;
        int mid=(l+r)&gt;&gt;1;
        if(check(mid))
        {ans=mid;r=mid-1;}
        else
            l=mid+1;
    }
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1537</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,N,k;
int tr[100010];

struct size
{
    int x,y,yy,num;
}dot[100010];

inline int lowbit(int x)
{
    return x&amp;-x;
}

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline bool cmp_pos(size a,size b)
{
    return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);
}
inline bool cmp_yy(size a,size b)
{
    return a.yy&lt;b.yy;
}

inline void change(int x,int val)
{
    for(;x&lt;=N;x+=lowbit(x))
        tr[x]=max(tr[x],val);
}
inline int calc(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp=max(temp,tr[x]);
    return temp;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);

    for(int i=1;i&lt;=k;i++)
        scanf("%d%d%d",&amp;dot[i].x,&amp;dot[i].yy,&amp;dot[i].num);

    sort(dot+1,dot+k+1,cmp_yy);
    for(int i=1;i&lt;=k;i++)
        if(dot[i].yy!=dot[i-1].yy)
            dot[i].y=dot[i-1].y+1;
        else
            dot[i].y=dot[i-1].y;
    N=dot[k].y;
    sort(dot+1,dot+k+1,cmp_pos);

    for(int i=1;i&lt;=k;i++)
        change(dot[i].y,calc(dot[i].y)+dot[i].num);

    printf("%d\n",calc(N));

    return 0;
}
<pre><h2>Problem1560</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=0xfffffff;

int n,m,h,p[1010];
int f[1010];
int g[1010][1010];

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    memset(g,0xffffffff,sizeof(g));

    for(int i=1;i&lt;=n;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        g[x][y]=z;
    }
    for(int i=1;i&lt;=m;i++)f[i]=-inf;
    f[1]=g[1][1];
    h=1;
    p[1]=1;
    for(int j=2;j&lt;=m;j++)
        if(g[1][j]!=-1)
    {
        f[j]=f[h]+g[1][j]-(j-h)*(j-h);
        p[j]=1;
        h=j;
    }

    for(int i=2;i&lt;=m;i++)
    {
        h=1;

        for(int j=1;j&lt;=m;j++)
            if(g[i][j]!=-1)
        {
            int temp=-inf;

            for(int k=j;k&gt;=h;k--)
                if(f[k]!=-inf)
                    if(f[k]+g[i][j]-(p[k]-i)*(p[k]-i)-(k-j)*(k-j)&gt;temp)
                        temp=f[k]+g[i][j]-(p[k]-i)*(p[k]-i)-(k-j)*(k-j);
            f[j]=temp;
            h=j;
            p[j]=i;
        }
    }

    printf("%d\n",f[m]);

    return 0;
}
<pre><h2>Problem1562</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}
inline void Swap(int&amp;x,int&amp;y)
{
	x^=y^=x^=y;
}

int n,cnt;
int g[10010],pp[10010],ans[10010];
bitset&lt;10010&gt;v;
struct edge
{
	int t,next;
}e[20010];
inline void add_edge(int x,int y)
{
	e[++cnt].t=y;
	e[cnt].next=g[x];
	g[x]=cnt;
}

inline bool find(int x)
{
	for(int i=g[x];i;i=e[i].next)
		if(!v[e[i].t])
		{
			v[e[i].t]=1;
			if(pp[e[i].t]==0||find(pp[e[i].t]))
			{
				pp[e[i].t]=x;
				return 1;
			}
		}
	return 0;
}

int main()
{
	n=read();
	for(int i=0;i&lt;n;i++)
	{
		int dist=read();
		int x=i+dist,y=i-dist+n;
		x%=n;y%=n;
		if(x&lt;y)Swap(x,y);
		add_edge(i,x);
		if(x!=y)add_edge(i,y);
	}
	for(int i=n-1;i&gt;=0;i--)
	{
		v.reset();
		if(!find(i))
		{
			printf("No Answer\n");
			return 0;
		}
	}
	
	for(int i=0;i&lt;n;i++)
		ans[pp[i]]=i;
	for(int i=0;i&lt;n-1;i++)
		printf("%d ",ans[i]);
	printf("%d\n",ans[n-1]);
	
	return 0;
}<pre><h2>Problem1565</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1e9;

int n,m,ans=0;
int idx,top;
int num=-1;
int v[610];
int dfn[610],low[610],stack[610];
int dis[610],vh[610],his[610],pre[610];
bitset&lt;610&gt; vis;

struct size
{
	int ch;
	size *next;
}*g[610],*g1[610],*di[610];

struct size1
{
	int t,c;
}edge[360000];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	edge[++num].t=y;
	edge[num].c=z;
	
	size *p=new size;
	p-&gt;ch=num;
	p-&gt;next=g[x];
	g[x]=p;
	
	edge[++num].t=x;
	edge[num].c=0;
	
	p=new size;
	p-&gt;ch=num;
	p-&gt;next=g[y];
	g[y]=p;
}

inline void add_edge1(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=g1[x];
	g1[x]=p;
}

void dfs(int x)
{
	dfn[x]=low[x]=++idx;
	stack[++top]=x;
	vis.set(x);
	
	for(size *p=g1[x];p;p=p-&gt;next)
		if(!dfn[p-&gt;ch])
		{
			dfs(p-&gt;ch);
			low[x]=min(low[x],low[p-&gt;ch]);
		}
		else
			if(vis.test(p-&gt;ch))
				low[x]=min(low[x],low[p-&gt;ch]);
	
	if(dfn[x]==low[x])
		if(stack[top]!=x)
		{
			while(stack[top]!=x)
				vis.flip(stack[top--]);
			
			vis.flip(stack[top]);
			v[stack[top--]]=-inf;
		}
		else
			vis.flip(stack[top--]);
}

inline void dfs1(int x)
{
	vis.set(x);
	v[x]=-inf;
	
	for(size *p=g1[x];p;p=p-&gt;next)
		if(!vis.test(p-&gt;ch))
			dfs1(p-&gt;ch);
}

inline int isap()
{
	vh[0]=n+1;
	for(int i=0;i&lt;=n;i++)
		di[i]=g[i];
	
	int aug=inf,i=n-1,flow=0;
	
	while(dis[n-1]&lt;=n)
	{
		bool flag=false;
		his[i]=aug;
		
		for(size *p=di[i];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&amp;&amp;dis[i]==dis[edge[p-&gt;ch].t]+1)
			{
				di[i]=p;
				flag=true;
				aug=min(aug,edge[p-&gt;ch].c);
				pre[edge[p-&gt;ch].t]=1^p-&gt;ch;
				i=edge[p-&gt;ch].t;
				
				if(i==n)
				{
					flow+=aug;
					for(;i!=n-1;i=edge[pre[i]].t)
					{
						edge[pre[i]].c+=aug;
						edge[1^pre[i]].c-=aug;
					}
					aug=inf;
				}
				
				break;
			}
		
		if(flag)continue;
		
		int mi=n+1;
		size *pp;
		
		for(size *p=g[i];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&amp;&amp;dis[edge[p-&gt;ch].t]+1&lt;mi)
				mi=dis[edge[p-&gt;ch].t]+1,pp=p;
		
		di[i]=pp;
		vh[dis[i]]--;
		if(!vh[dis[i]])break;
		dis[i]=mi;
		vh[dis[i]]++;
		
		if(i!=n-1)
		{
			i=edge[pre[i]].t;
			aug=his[i];
		}
	}
	
	return flow;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=0;i&lt;n;i++)
		for(int j=0;j&lt;m;j++)
		{
			int t,x,y;
			scanf("%d%d",v+i*m+j,&amp;t);
			if(j)
				add_edge1(i*m+j,i*m+j-1);
			
			for(;t;t--)
			{
				scanf("%d%d",&amp;x,&amp;y);
				add_edge1(i*m+j,x*m+y);
			}
		}
	
	vis.reset();
	for(int i=0;i&lt;n*m;i++)
		if(!dfn[i])
			dfs(i);
	
	vis.reset();
	for(int i=0;i&lt;n*m;i++)
		if(v[i]==-inf&amp;&amp;!vis.test(i))
			dfs1(i);
	
	for(int i=0;i&lt;n*m;i++)
	{
		for(size *p=g1[i];p;p=p-&gt;next)
			add_edge(p-&gt;ch,i,inf);
		
		if(v[i]&gt;0)
			ans+=v[i],add_edge(n*m,i,v[i]);
		else
			add_edge(i,n*m+1,-v[i]);
	}
	
	n=n*m+1;
	
	ans-=isap();
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1567</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,ans;
bool flag;
int a[55][55],b[55][55];
long long tr1[55][55],tr2[55][55];

inline int lowbit(int x)
{
	return x&amp;-x;
}

inline void add1(int x,int y,int num)
{
	for(;x&lt;=n;x+=lowbit(x))
		for(int j=y;j&lt;=n;j+=lowbit(j))
			tr1[x][j]+=num;
}

inline void add2(int x,int y,int num)
{
	for(;x&lt;=n;x+=lowbit(x))
		for(int j=y;j&lt;=n;j+=lowbit(j))
			tr2[x][j]+=num;
}

inline long long query1(int x,int y)
{
	long long temp=0;
	for(;x;x-=lowbit(x))
		for(int j=y;j;j-=lowbit(j))
			temp+=tr1[x][j];
	return temp;
}

inline long long query2(int x,int y)
{
	long long temp=0;
	for(;x;x-=lowbit(x))
		for(int j=y;j;j-=lowbit(j))
			temp+=tr2[x][j];
	return temp;
}

inline long long sum1(int x,int y,int nn)
{
	return query1(x+nn-1,y+nn-1)-query1(x+nn-1,y-1)-query1(x-1,y+nn-1)+query1(x-1,y-1);
}

inline long long sum2(int x,int y,int nn)
{
	return query2(x+nn-1,y+nn-1)-query2(x+nn-1,y-1)-query2(x-1,y+nn-1)+query2(x-1,y-1);
}

inline bool check(int x1,int y1,int x2,int y2,int nn)
{
	for(int i=0;i&lt;nn;i++)
		for(int j=0;j&lt;nn;j++)
			if(a[x1+i][y1+j]!=b[x2+i][y2+j])
				return false;
	return true;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			scanf("%d",&amp;a[i][j]);
			add1(i,j,a[i][j]);
		}
		
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			scanf("%d",&amp;b[i][j]);
			add2(i,j,b[i][j]);
		}
	
	for(ans=n,flag=false;ans;ans--)
	{
		for(int i1=1;i1&lt;=n+1-ans;i1++)
		{
			for(int j1=1;j1&lt;=n+1-ans;j1++)
			{
				for(int i2=1;i2&lt;=n+1-ans;i2++)
				{
					for(int j2=1;j2&lt;=n+1-ans;j2++)
						if(sum1(i1,j1,ans)==sum2(i2,j2,ans))
							if(check(i1,j1,i2,j2,ans))
							{
								flag=true;
								break;
							}
					if(flag)break;
				}
				if(flag)break;
			}
			if(flag)break;
		}
		if(flag)break;
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1567</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,ans;
bool flag;
int a[55][55],b[55][55];

inline bool check(int x1,int y1,int x2,int y2,int nn)
{
	for(int i=0;i&lt;nn;i++)
		for(int j=0;j&lt;nn;j++)
			if(a[x1+i][y1+j]!=b[x2+i][y2+j])
				return false;
	return true;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			scanf("%d",&amp;a[i][j]);
		
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			scanf("%d",&amp;b[i][j]);
			
	for(ans=n,flag=false;ans;ans--)
	{
		for(int i1=1;i1&lt;=n+1-ans;i1++)
		{
			for(int j1=1;j1&lt;=n+1-ans;j1++)
			{
				for(int i2=1;i2&lt;=n+1-ans;i2++)
				{
					for(int j2=1;j2&lt;=n+1-ans;j2++)
						if(check(i1,j1,i2,j2,ans))
						{
							flag=true;
							break;
						}
					if(flag)break;
				}
				if(flag)break;
			}
			if(flag)break;
		}
		if(flag)break;
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1567</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,ans;
bool flag;
int a[55][55],b[55][55];
long long tr1[55][55],tr2[55][55];

inline int lowbit(int x)
{
	return x&amp;-x;
}

inline void add1(int x,int y,int num)
{
	for(;x&lt;=n;x+=lowbit(x))
		for(int j=y;j&lt;=n;j+=lowbit(j))
			tr1[x][j]+=num;
}

inline void add2(int x,int y,int num)
{
	for(;x&lt;=n;x+=lowbit(x))
		for(int j=y;j&lt;=n;j+=lowbit(j))
			tr2[x][j]+=num;
}

inline long long query1(int x,int y)
{
	long long temp=0;
	for(;x;x-=lowbit(x))
		for(int j=y;j;j-=lowbit(j))
			temp+=tr1[x][j];
	return temp;
}

inline long long query2(int x,int y)
{
	long long temp=0;
	for(;x;x-=lowbit(x))
		for(int j=y;j;j-=lowbit(j))
			temp+=tr2[x][j];
	return temp;
}

inline long long sum1(int x,int y,int nn)
{
	return query1(x+nn-1,y+nn-1)-query1(x+nn-1,y-1)-query1(x-1,y+nn-1)+query1(x-1,y-1);
}

inline long long sum2(int x,int y,int nn)
{
	return query2(x+nn-1,y+nn-1)-query2(x+nn-1,y-1)-query2(x-1,y+nn-1)+query2(x-1,y-1);
}

inline bool check(int x1,int y1,int x2,int y2,int nn)
{
	for(int i=0;i&lt;nn;i++)
		for(int j=0;j&lt;nn;j++)
			if(a[x1+i][y1+j]!=b[x2+i][y2+j])
				return false;
	return true;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			scanf("%d",&amp;a[i][j]);
			add1(i,j,a[i][j]);
		}
		
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			scanf("%d",&amp;b[i][j]);
			add2(i,j,b[i][j]);
		}
	
	for(ans=n,flag=false;ans;ans--)
	{
		for(int i1=1;i1&lt;=n+1-ans;i1++)
		{
			for(int j1=1;j1&lt;=n+1-ans;j1++)
			{
				for(int i2=1;i2&lt;=n+1-ans;i2++)
				{
					for(int j2=1;j2&lt;=n+1-ans;j2++)
						if(a[i1][j1]==b[i2][j2])
							if(sum1(i1,j1,ans)==sum2(i2,j2,ans))
								if(check(i1,j1,i2,j2,ans))
								{
									flag=true;
									break;
								}
					if(flag)break;
				}
				if(flag)break;
			}
			if(flag)break;
		}
		if(flag)break;
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1571</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int t,s,n,v,cnt;
int f[10010][110];

struct course
{
    int s,l,a;
}c[110];
struct event
{
    int c,d;
}e[110],e1[10010];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline bool cmp(event a,event b)
{
    return a.c&lt;b.c||a.c==b.c&amp;&amp;a.d&lt;b.d;
}

int main()
{
    scanf("%d%d%d",&amp;t,&amp;s,&amp;n);
    v=1;
    for(int i=1;i&lt;=s;i++)
    {
        scanf("%d%d%d",&amp;c[i].s,&amp;c[i].l,&amp;c[i].a);
        v=max(v,c[i].a);
    }
    for(int i=1;i&lt;=n;i++)
        scanf("%d%d",&amp;e1[i].c,&amp;e1[i].d);
    sort(e1+1,e1+n+1,cmp);
    for(int i=1;i&lt;=n;i++)
        if(e1[i].c!=e1[i-1].c)
            e[++cnt]=e1[i];

    for(int i=0;i&lt;=t;i++)
        for(int j=1;j&lt;=v;j++)
            f[i][j]=-1;
    f[0][1]=0;
    for(int i=0;i&lt;t;i++)
        for(int j=1;j&lt;=v;j++)
            if(f[i][j]!=-1)
            {
                f[i+1][j]=max(f[i+1][j],f[i][j]);
                for(int k=1;k&lt;=s;k++)
                    if(i==c[k].s&amp;&amp;i+c[k].l&lt;=t&amp;&amp;c[k].a&gt;j)
                        f[i+c[k].l][c[k].a]=max(f[i+c[k].l][c[k].a],f[i][j]);
                for(int k=1;k&lt;=cnt;k++)
                    if(j&gt;=e[k].c&amp;&amp;i+e[k].d&lt;=t)
                        f[i+e[k].d][j]=max(f[i+e[k].d][j],f[i][j]+1);
            }

    int ans=0;
    for(int i=1;i&lt;=v;i++)ans=max(ans,f[t][i]);
    printf("%d\n",ans);

    return 0;
}<pre><h2>Problem1572</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;

using namespace std;

int n;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;

struct size
{
    int d,p;
}t[100010];

inline bool cmp(size a,size b)
{
    return a.d&lt;b.d;
}

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf("%d%d",&amp;t[i].d,&amp;t[i].p);

    sort(t+1,t+n+1,cmp);

    long long ans=0;
    int time=0;
    for(int i=1;i&lt;=n;i++)
    {
        if(time&lt;t[i].d)
        {
            time++;
            ans+=t[i].p;
            q.push(t[i].p);
        }
        else
        {
            if(t[i].p&gt;q.top())
            {
                ans-=q.top();
                q.pop();
                q.push(t[i].p);
                ans+=t[i].p;
            }
        }
    }

    printf("%lld\n",ans);

    return 0;
}
<pre><h2>Problem1574</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,p,cnt=0,ans=0;
int g[30010],v[30010],d[30010];

struct edge
{
    int t,next;
}e[200010];

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void del(int x)
{
    for(int i=g[x];i;i=e[i].next)
        d[e[i].t]=1;
}

inline void dfs(int x)
{
    v[x]=1;
    ans++;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;!d[e[i].t])
            dfs(e[i].t);
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;p);
    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(x,y);
        add_edge(y,x);
    }
    for(;p;p--)
    {
        int x;
        scanf("%d",&amp;x);
        del(x);
    }
    dfs(1);

    printf("%d\n",n-ans);

    return 0;
}
<pre><h2>Problem1579</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1000000000;
const long long Inf=(long long)inf*inf;

int n,m,k,cnt;
int g[300010];
long long dist[300010];
bitset&lt;300010&gt; v;

struct size
{
    int t;
    long long c;
    size(int A,int B):t(A),c(B){}
    inline friend bool operator&lt;(const size&amp;a,const size&amp;b){return a.c&gt;b.c;}
};
priority_queue&lt;size&gt; q;

struct edge
{
    int t,c,next;
}e[200000];

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void dijkstra()
{
    v.reset();
    for(int i=1;i&lt;=n*(k+1);i++)dist[i]=Inf;
    q.push(size(1,0));
    dist[1]=0;

    while(!q.empty())
    {
        int x=q.top().t;
        q.pop();

        if(v.test(x))continue;

        int X=x%n;
        if(!X)X=n;
        int del=x-X;
        for(int i=g[X];i;i=e[i].next)
        {
            int t=e[i].t+del;
            int c=e[i].c;
            if(dist[x]+c&lt;dist[t]&amp;&amp;!v.test(t))
            {
                dist[t]=dist[x]+c;
                q.push(size(t,dist[t]));
            }
            if(t&lt;=n*k&amp;&amp;dist[x]&lt;dist[t+n]&amp;&amp;!v.test(t+n))
            {
                dist[t+n]=dist[x];
                q.push(size(t+n,dist[t+n]));
            }
        }
        v.set(x);
    }
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
        add_edge(y,x,z);
    }

    dijkstra();

    long long ans=Inf;
    for(int i=1;i&lt;=k+1;i++)
        if(dist[n*i]&lt;ans)
            ans=dist[n*i];

    printf("%lld\n",ans);

    return 0;
}
<pre><h2>Problem1583</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,p1,p2;
int a1,b1,d1,a2,b2,d2;
long long seq[4000005];

int main()
{
    scanf("%lld%d",seq,&amp;n);
    scanf("%d%d%d",&amp;a1,&amp;b1,&amp;d1);
    scanf("%d%d%d",&amp;a2,&amp;b2,&amp;d2);

    long long a=seq[0]*a1/d1+b1,b=seq[0]*a2/d2+b2;

    for(int i=1;i&lt;n;)
    {
        if(a&lt;b)
        {
            if(a!=seq[i-1])
                seq[i++]=a;
            a=(long long)seq[++p1]*a1/d1+b1;
        }
        else
        {
            if(b!=seq[i-1])
                seq[i++]=b;
            b=(long long)seq[++p2]*a2/d2+b2;
        }
    }
    printf("%lld\n",seq[n-1]);

    return 0;
}
/*
3 10
4 3 3
17 8 2
*/
<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;

using namespace std;

const int inf=2147483647;
const int maxn=20000000;

int n,x,ans=0;
set&lt;int&gt; s;

inline int abs(int x)
{
	return x&lt;0?-x:x;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;x);
	
	ans=x;
	
	s.insert(x+maxn);
	
	for(int i=1;i&lt;n;i++)
	{
		if(scanf("%d",&amp;x)==EOF)x=0;
		
		x+=maxn;
		
		if(s.insert(x).second)
		{
			int temp=inf;
			
			set&lt;int&gt;::iterator it=s.find(x);
			if(it!=s.end())
			{
				it++;
				temp=abs(x-*it);
			}
			
			it=s.find(x);
			if(it!=s.begin())
			{
				it--;
				temp=min(temp,abs(*it-x));
			}
			
			ans+=temp;
		}
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1e9;

int n,x,ans;

struct size
{
	int num;
	size *fa,*l,*r;
}*root=new size;

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void left(size *temp)
{
	size *p=temp-&gt;fa;
	
	p-&gt;r=temp-&gt;l;
	
	if(p-&gt;r!=NULL)
		p-&gt;r-&gt;fa=p;
	
	temp-&gt;fa=p-&gt;fa;
	
	if(p-&gt;fa!=NULL)
		if(p==p-&gt;fa-&gt;l)
			p-&gt;fa-&gt;l=temp;
		else
			p-&gt;fa-&gt;r=temp;
	
	p-&gt;fa=temp;
	temp-&gt;l=p;
}

inline void right(size *temp)
{
	size *p=temp-&gt;fa;
	
	p-&gt;l=temp-&gt;r;
	
	if(p-&gt;l!=NULL)
		p-&gt;l-&gt;fa=p;
	
	temp-&gt;fa=p-&gt;fa;
	
	if(p-&gt;fa!=NULL)
		if(p==p-&gt;fa-&gt;l)
			p-&gt;fa-&gt;l=temp;
		else
			p-&gt;fa-&gt;r=temp;
	
	p-&gt;fa=temp;
	temp-&gt;r=p;
}

inline void splay(size *temp)
{
	while(temp-&gt;fa!=NULL)
	{
		size *p=temp-&gt;fa;
		
		if(p-&gt;fa==NULL)
			if(temp==p-&gt;r)
				left(temp);
			else
				right(temp);
		else
			if(p==p-&gt;fa-&gt;l)
				if(temp==p-&gt;l)
				{
					right(p);
					right(temp);
				}
				else
				{
					left(temp);
					right(temp);
				}
			else
				if(temp==p-&gt;l)
				{
					right(temp);
					left(temp);
				}
				else
				{
					left(p);
					left(temp);
				}
	}
	
	root=temp;
}

inline void insert(int x)
{
	size *p=root,*temp=new size;
	temp-&gt;num=x;
	temp-&gt;l=temp-&gt;r=NULL;
	
	while(1)
	{
		if(x&lt;p-&gt;num)
			if(p-&gt;l!=NULL)
				p=p-&gt;l;
			else
			{
				p-&gt;l=temp;
				temp-&gt;fa=p;
				break;
			}
		else
			if(p-&gt;r!=NULL)
				p=p-&gt;r;
			else
			{
				p-&gt;r=temp;
				temp-&gt;fa=p;
				break;
			}
	}
	
	splay(temp);
}

inline bool find(int x)
{
	size *p=root;
	
	while(1)
	{
		if(x==p-&gt;num)
			return true;
		
		if(x&lt;p-&gt;num)
			if(p-&gt;l!=NULL)
				p=p-&gt;l;
			else
				break;
		else
			if(p-&gt;r!=NULL)
				p=p-&gt;r;
			else
				break;
	}
	
	return false;
}

inline int fmin()
{
	size *p=root;
	if(p-&gt;l==NULL)
		return inf;
	p=p-&gt;l;
	
	while(p-&gt;r!=NULL)
		p=p-&gt;r;
	return p-&gt;num;
}

inline int fmax()
{
	size *p=root;
	if(p-&gt;r==NULL)
		return inf;
	p=p-&gt;r;
	
	while(p-&gt;l!=NULL)
		p=p-&gt;l;
	return p-&gt;num;
}

int main()
{
	scanf("%d",&amp;n);
	
	scanf("%d",&amp;x);
	root-&gt;num=x;
	root-&gt;fa=root-&gt;l=root-&gt;r=NULL;
	ans=x;
	
	for(int i=1;i&lt;n;i++)
	{
		if(scanf("%d",&amp;x)==EOF)x=0;
		
		if(!find(x))
		{
			insert(x);
			int temp=inf,temp1=fmin(),temp2=fmax();
			if(temp1!=inf)
				temp=x-temp1;
			if(temp2!=inf)
				temp=min(temp,temp2-x);
			ans+=temp;
		}
	}
	
	printf("%d\n",ans);
	
	return 0;
} <pre><h2>Problem1597</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,cnt;
int h,t,q[50010];
long long a[50010],b[50010],f[50010];
struct size
{
    int x,y;
}rec[50010];
inline bool cmp(size a,size b)
{
    return a.x&gt;b.x||a.x==b.x&amp;&amp;a.y&gt;b.y;
}

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;rec[i].x,&amp;rec[i].y);
    sort(rec+1,rec+n+1,cmp);
    for(int i=1;i&lt;=n;i++)
    {
        if(rec[i].y&gt;b[cnt])
        {
            cnt++;
            a[cnt]=rec[i].x;
            b[cnt]=rec[i].y;
        }
    }

    q[h=t=1]=0;
    for(int i=1;i&lt;=cnt;i++)
    {
        while(h&lt;t&amp;&amp;f[q[h+1]]-f[q[h]]&lt;b[i]*(a[q[h]+1]-a[q[h+1]+1]))h++;
        f[i]=f[q[h]]+a[q[h]+1]*b[i];
        while ((h&lt;t)&amp;&amp;(f[i]-f[q[t-1]])*(a[q[t]+1]-a[i+1])&gt;=(f[i]-f[q[t]])*(a[q[t-1]+1]-a[i+1]))t--;
        q[++t]=i;
    }
    printf("%lld\n",f[cnt]);

    return 0;
}
/*
4
100 1
15 15
20 5
1 100
*/
<pre><h2>Problem1599</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int a,b,c;
int fa[100],fb[100],fc[100];

int main()
{
    scanf("%d%d%d",&amp;a,&amp;b,&amp;c);

    for(int i=1;i&lt;=a;i++)fa[i]=1;

    for(int i=1;i&lt;=a;i++)
        for(int j=1;j&lt;=b;j++)
            fb[i+j]+=fa[i];
    for(int i=1;i&lt;=a+b;i++)
        for(int j=1;j&lt;=c;j++)
            fc[i+j]+=fb[i];

    int ma=0,ans=0;
    for(int i=1;i&lt;=a+b+c;i++)
        if(fc[i]&gt;ma)ma=fc[i],ans=i;

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1600</h2><pre>#include&lt;cstdio&gt;

using namespace std;

long long n;

int main()
{
	scanf("%lld",&amp;n);
	long long ans=(n-1)*(n-2)*(n-3)/6;
	for(int i=(n+1)/2;i&lt;=n-3;i++)
		ans-=(n-i-1)*(n-i-2)*2;
	
	printf("%lld\n",ans);
	
	return 0;
}<pre><h2>Problem1601</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

struct graph
{
	int a,b,len;
}e[100000];

int n,x,fa[5000],size=0;

inline void add_edge(int a,int b,int len)
{
	e[++size].a=a;
	e[size].b=b;
	e[size].len=len;
}

inline bool cmp(graph x,graph y)
{
	return x.len&lt;y.len;
}

int find(int x)
{
	return fa[x]=fa[x]==x?x:find(fa[x]);
}

inline int kruscal()
{
	int ans=0;
	
	for(int i=0;i&lt;=n;i++)fa[i]=i;
	
	sort(e+1,e+size+1,cmp);
	
	for(int i=1;i&lt;=size;i++)
		if(find(e[i].a)!=find(e[i].b))
		{
			ans+=e[i].len;
			fa[fa[e[i].a]]=fa[e[i].b];
		}
		
	return ans;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=0;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			scanf("%d",&amp;x);
			add_edge(i,j,x);
		}
	
	printf("%d\n",kruscal());
	
	return 0;
}<pre><h2>Problem1601</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

struct graph
{
	int a,b,len;
}e[100000];

int n,x,fa[1000],size=0;

inline void add_edge(int a,int b,int len)
{
	e[++size].a=a;
	e[size].b=b;
	e[size].len=len;
}

inline bool cmp(graph x,graph y)
{
	return x.len&lt;y.len;
}

int find(int x)
{
	return fa[x]=fa[x]==x?x:find(fa[x]);
}

inline int kruscal()
{
	int ans=0;
	
	for(int i=0;i&lt;=n;i++)fa[i]=i;
	
	sort(e+1,e+size+1,cmp);
	
	for(int i=1;i&lt;=size;i++)
		if(find(e[i].a)!=find(e[i].b))
		{
			ans+=e[i].len;
			fa[fa[e[i].a]]=fa[e[i].b];
		}
		
	return ans;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=0;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			scanf("%d",&amp;x);
			add_edge(i,j,x);
		}
	
	printf("%d\n",kruscal());
	
	return 0;
}<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,m,x,y,z;
int c[1010],up[1010],up1[1010],stack[1010];
bitset&lt;1010&gt; v;

struct size
{
	int ch,len;
	size *next;
}*tr[1010];

inline void add_edge(int x,int y,int z)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=tr[x];
	tr[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;len=z;
	p-&gt;next=tr[y];
	tr[y]=p;
}

inline void bfs()
{
	stack[1]=1;
	c[1]=0;
	v.set(1);
	int h=1,t=1;
	
	while(h&lt;=t)
	{
		for(size *p=tr[stack[h]];p!=NULL;p=p-&gt;next)
			if(!v.test(p-&gt;ch))
			{
				stack[++t]=p-&gt;ch;
				up[p-&gt;ch]=p-&gt;len;
				up1[p-&gt;ch]=stack[h];
				c[p-&gt;ch]=c[stack[h]]+1;
				v.set(p-&gt;ch);
			}
		h++;
	}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;n;i++)
	{
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		add_edge(x,y,z);
	}
	
	v.reset();
	bfs();
	
	for(;m;m--)
	{
		scanf("%d%d",&amp;x,&amp;y);
		int ans=0;
		if(c[x]&gt;c[y])
		{
			int t=x;
			x=y,y=t;
		}
		
		while(c[y]&gt;c[x])
		{
			ans+=up[y];
			y=up1[y];
		}
		
		while(x!=y)
		{
			ans+=up[x]+up[y];
			x=up1[x];
			y=up1[y];
		}
		
		printf("%d\n",ans);
	}
	
	return 0;
}<pre><h2>Problem1603</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,x,y,z;
int c[1010],stack[1010];
bitset&lt;1010&gt; v;

struct size
{
	int ch,len;
	size *next;
}*tr[1010];

inline void add_edge(int x,int y,int z)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=tr[x];
	tr[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;len=z;
	p-&gt;next=tr[y];
	tr[y]=p;
}

inline void bfs()
{
	stack[1]=1;
	c[1]=0;
	v.set(1);
	int h=1,t=1;
	
	while(h&lt;=t)
	{
		for(size *p=tr[stack[h]];p!=NULL;p=p-&gt;next)
			if(!v.test(p-&gt;ch))
			{
				stack[++t]=p-&gt;ch;
				if(p-&gt;len)
					c[p-&gt;ch]=1^c[stack[h]];
				else
					c[p-&gt;ch]=c[stack[h]];
				v.set(p-&gt;ch);
			}
		h++;
	}
}

int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++)
	{
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		add_edge(x,y,z);
	}
	
	v.reset();
	bfs();
	
	printf("%d\n",c[n]);
	
	return 0;
}<pre><h2>Problem1606</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,c,x;
bitset&lt;100010&gt; v;

int main()
{
	scanf("%d%d",&amp;c,&amp;n);
	v.set(c);
	
	for(;n;n--)
	{
		scanf("%d",&amp;x);
		for(int i=c;i;i--)
			if(v.test(i))
				v.set(i+x);
	}
	
	for(;c;c--)
		if(v.test(c))
			break;
	
	printf("%d\n",c);
	
	return 0;
}<pre><h2>Problem1607</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,ma;
int a[100010];
int b[1000010],c[1000010];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",a+i);
		b[a[i]]++;
		ma=max(ma,a[i]);
	}
	
	for(int i=1;i&lt;=ma;i++)
	{
		if(b[i])
		{
			for(int j=i;j&lt;=ma;j+=i)
				c[j]+=b[i];
		}
	}
	
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",c[a[i]]-1);
		
	return 0;
}<pre><h2>Problem1609</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n;
int num[30010];
int f[30010][4];

inline int calc(int x,int y)
{
    return x==y?0:1;
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
        scanf("%d",num+i);

    for(int i=1;i&lt;=n;i++)
    {
        f[i][1]=f[i-1][1]+calc(num[i],1);
        f[i][2]=min(f[i-1][1],f[i-1][2])+calc(num[i],2);
        f[i][3]=min(f[i-1][1],min(f[i-1][2],f[i-1][3]))+calc(num[i],3);
    }

    int ans=min(f[n][1],min(f[n][2],f[n][3]));

    memset(f,0,sizeof(f));

    for(int i=1;i&lt;=n;i++)
    {
        f[i][3]=f[i-1][3]+calc(num[i],3);
        f[i][2]=min(f[i-1][3],f[i-1][2])+calc(num[i],2);
        f[i][1]=min(f[i-1][1],min(f[i-1][2],f[i-1][3]))+calc(num[i],1);
    }

    ans=min(min(ans,f[n][1]),min(f[n][2],f[n][3]));

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1610</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const double inf=(double)1000000000.0;

int n,num;

struct size1
{
	int x,y;
}dot[300];

struct size2
{
	int dx,dy;
	double k;
}line[50000];

inline bool cmp(size2 a,size2 b)
{
	return a.k&lt;b.k;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;dot[i].x,&amp;dot[i].y);
	
	for(int i=1;i&lt;n;i++)
		for(int j=i+1;j&lt;=n;j++)
		{
			line[++num].dx=dot[j].x-dot[i].x;
			line[num].dy=dot[j].y-dot[i].y;
			if(line[num].dx==0)
				line[num].k=inf;
			else
				line[num].k=(double)line[num].dy/(double)line[num].dx;
		}
	
	sort(line+1,line+num+1,cmp);
	
	int ans=1;
	
	for(int i=2;i&lt;=num;i++)
		if(line[i].k!=line[i-1].k)
			ans++;
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1612</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,x,y,ans;
int e[110][110];

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	memset(e,0,sizeof(e));
	
	for(int i=1;i&lt;=n;i++)
		e[i][i]=1;
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		e[x][y]=1;
	}
	
	for(int k=1;k&lt;=n;k++)
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				if(e[i][k]&amp;&amp;e[k][j])
					e[i][j]=1;
	
	
	for(int i=1;i&lt;=n;i++)
	{
		bool flag=true;
		for(int j=1;j&lt;=n;j++)
			if((e[i][j]|e[j][i])==0)
			{
				flag=false;
				break;
			}
		if(flag)ans++;
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1613</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1e9;

int n,m;
int d[10010];
int f[10010][510];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",d+i);
	
	for(int i=1;i&lt;=n;i++)
	{
		f[i][0]=f[i-1][0];
		for(int j=1;j&lt;=i&amp;&amp;j&lt;=m;j++)
			f[i][0]=max(f[i][0],f[i-j][j]);
		
		for(int j=1;j&lt;=m;j++)
			f[i][j]=f[i-1][j-1]+d[i];
		
	}
	
	printf("%d\n",f[n][0]);
	
	return 0;
}<pre><h2>Problem1615</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,x,y,temp,temp1;
double s[1100],ans[1100];
bitset&lt;1100&gt; v;

struct size
{
	int ch;
	size *next;
}*tr[1100];

struct size1
{
	int x,y,r;
}c[1100];

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=tr[x];
	tr[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;next=tr[y];
	tr[y]=p;
}
inline int f(int x)
{
	return x*x;
}

inline void dfs(int x)
{
	for(size *p=tr[x];p!=NULL;p=p-&gt;next)
		if(!v.test(p-&gt;ch))
		{
			v.set(p-&gt;ch);
			s[p-&gt;ch]=(double)s[x]*(double)c[x].r/(double)c[p-&gt;ch].r;
			ans[p-&gt;ch]=ans[x]+s[p-&gt;ch];
			dfs(p-&gt;ch);
		}
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;x,&amp;y);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d%d%d",&amp;c[i].x,&amp;c[i].y,&amp;c[i].r);
		if(c[i].x==x&amp;&amp;c[i].y==y)
			temp=i;
		if(c[i].x==0&amp;&amp;c[i].y==0)
			temp1=i;
		for(int j=1;j&lt;i;j++)
			if(f(c[i].x-c[j].x)+f(c[i].y-c[j].y)==f(c[i].r+c[j].r))
				add_edge(i,j);
	}
	
	v.set(temp1);
	s[temp1]=(double)10000.0;
	ans[temp1]=s[temp1];
	dfs(temp1);
	
	printf("%d\n",(int)ans[temp]);
	
	return 0;
}<pre><h2>Problem1616</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,t,x1,y1,x2,y2;
int xx[5],yy[5];
int map[105][105];
int f[105][105][16];

inline char read()
{
	char c=getchar();
	while(c!='.'&amp;&amp;c!='*')
		c=getchar();
	return c;
}

void sear(int x,int y,int t)
{
	if(t==0)
		if(x==x1&amp;&amp;y==y1&amp;&amp;t==0)
		{
			f[x][y][t]=1;
			return;
		}
		else
		{
			f[x][y][t]=0;
			return;
		}
	
	f[x][y][t]=0;
	if(map[x][y])return;
	
	for(int i=1;i&lt;=4;i++)
	{
		int tx=x+xx[i],ty=y+yy[i];
		if(tx&gt;n||tx&lt;1||ty&gt;m||ty&lt;1)
			continue;
		if(f[tx][ty][t-1]==-1)
			sear(tx,ty,t-1);
		f[x][y][t]+=f[tx][ty][t-1];
	}
}

int main()
{
	xx[1]=yy[2]=-1;
	xx[3]=yy[4]=1;
	
	scanf("%d%d%d",&amp;n,&amp;m,&amp;t);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			for(int k=0;k&lt;=t;k++)
				f[i][j][k]=-1;
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
		{
			char c=read();
			if(c=='*')
				map[i][j]=1;
		}
	
	scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
	
	sear(x2,y2,t);
	
	printf("%d\n",f[x2][y2][t]);
	
	return 0;
}<pre><h2>Problem1617</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m;
int s[2510],f[2510];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    s[0]=m;
    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        s[i]=s[i-1]+x;
    }

    for(int i=1;i&lt;=n;i++)
    {
        f[i]=s[i];
        for(int j=1;j&lt;i;j++)
            f[i]=min(f[i],f[j]+m+s[i-j]);
    }
    printf("%d\n",f[n]);

    return 0;
}
<pre><h2>Problem1618</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1e9;

int n,m,w,c;
int f[60010];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=m+5000;i++)
		f[i]=inf;
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d%d",&amp;w,&amp;c);
		for(int j=w;j&lt;=m+5000;j++)
			f[j]=min(f[j],f[j-w]+c);
	}
	
	int ans=inf;
	for(int i=m;i&lt;=m+5000;i++)
		ans=min(ans,f[i]);
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1620</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;

struct size
{
	int s,t;
}m[1010];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline bool cmp(size a,size b)
{
	return a.s&gt;b.s;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;m[i].t,&amp;m[i].s);
	
	sort(m+1,m+n+1,cmp);
	
	int temp=m[1].s;
	for(int i=1;i&lt;=n;i++)
	{
		temp=min(temp,m[i].s);
		temp-=m[i].t;
	}
	
	printf("%d\n",temp&lt;0?-1:temp);
	
	return 0;
}<pre><h2>Problem1621</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,k;

int search(int x)
{
	if(x-k&gt;0&amp;&amp;(x-k)%2==0)
		return search((x-k)/2)+search((x+k)/2);
	else
		return 1;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;k);
	
	printf("%d\n",search(n));
	
	return 0;
}<pre><h2>Problem1622</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

int n,m;
string name[1010];
string str[110];

inline int f(char c)
{
	if(c&gt;='a'&amp;&amp;c&lt;='z')
		return (int)(c-'a');
	if(c&gt;='A'&amp;&amp;c&lt;='Z');
		return (int)(c-'A');
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;name[i];
	for(int i=1;i&lt;=m;i++)
		cin&gt;&gt;str[i];
	
	for(int i=1;i&lt;=n;i++)
	{
		int ans=0,tag=0;
		
		for(int k=1;k&lt;=m;k++)
		{
			int tag=0;
			for(int j=0;j&lt;name[i].length();j++)
				if(f(name[i][j])==f(str[k][tag]))
					tag++;
			if(tag==str[k].length())
				ans++;
		}
		printf("%d\n",ans);
	}
	
	return 0;
}<pre><h2>Problem1623</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;

using namespace std;

priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;que;
int n,m,d,l,ans;
int a[50010];

int main()
{
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;d,&amp;l);
	
	for(int i=1;i&lt;=m;i++)
		que.push(0);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",a+i);
		
	sort(a+1,a+n+1);
	
	for(int i=1;i&lt;=n;i++)
	{
		int temp=que.top();
		
		if(a[i]-temp*d&gt;=l)
		{
			ans++;
			que.pop();
			que.push(temp+1);
		}
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1624</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,ans;
int a[10010];
int dist[110][110];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=m;i++)
		scanf("%d",a+i);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			scanf("%d",&amp;dist[i][j]);
	
	for(int k=1;k&lt;=n;k++)
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
	
	for(int i=2;i&lt;=m;i++)
		ans+=dist[a[i-1]][a[i]];
	
	printf("%d\n",ans);
	
	return 0;
} <pre><h2>Problem1625</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1e9;

int n,m,w,c,ans;
int f[20010];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d%d",&amp;w,&amp;c);
		for(int j=m;j&gt;=w;j--)
			ans=max(ans,f[j]=max(f[j],f[j-w]+c));
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1626</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;

using namespace std;

int n,m,num;
int fa[1010];
double ans=0.0;

struct size
{
	double len;
	int x,y;
}edge[500010];

struct size1
{
	int x,y;
}dot[1010];

int find(int x)
{
	return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline void join(int x,int y)
{
	fa[find(x)]=fa[find(y)];
}

inline long long f(long long x)
{
	return (long long)(x*x);
}

inline bool cmp(size a,size b)
{
	return a.len&lt;b.len;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d%d",&amp;dot[i].x,&amp;dot[i].y);
		fa[i]=i;
	}
	
	for(int i=1;i&lt;=m;i++)
	{
		int x,y;
		scanf("%d%d",&amp;x,&amp;y);
		join(x,y);
	}
	
	for(int i=1;i&lt;n;i++)
		for(int j=i+1;j&lt;=n;j++)
			if(find(i)!=find(j))
			{
				edge[++num].len=(double)sqrt((long long)(f((long long)(dot[i].x-dot[j].x))+f((long long)(dot[i].y-dot[j].y))));
				edge[num].x=i;
				edge[num].y=j;
			}
	
	sort(edge+1,edge+num+1,cmp);
	
	for(int i=1;i&lt;=num;i++)
		if(find(edge[i].x)!=find(edge[i].y))
		{
			join(edge[i].x,edge[i].y);
			ans+=edge[i].len;
		}
	
	printf("%.2lf\n",ans);
	
	return 0;
}<pre><h2>Problem1627</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int delt=501;

int X,Y,n;
int dist[1010][1010];
int mov[4][2];
bool v[1010][1010];
struct size
{
    int x,y;
}stack[1100000];

inline bool check(int x,int y)
{
    return x&gt;=0&amp;&amp;x&lt;=1002&amp;&amp;y&gt;=0&amp;&amp;y&lt;=1002;
}

inline void bfs(int x,int y)
{
    int h=0,t=1;
    dist[x][y]=1;
    stack[1].x=x;stack[1].y=y;

    while(h!=t)
    {
        h++;
        int x=stack[h].x,y=stack[h].y;
        for(int i=0;i&lt;4;i++)
            if(v[x+mov[i][0]][y+mov[i][1]]&amp;&amp;dist[x+mov[i][0]][y+mov[i][1]]==0&amp;&amp;check(x+mov[i][0],y+mov[i][1]))
            {
                dist[x+mov[i][0]][y+mov[i][1]]=dist[x][y]+1;
                stack[++t].x=x+mov[i][0];
                stack[t].y=y+mov[i][1];
            }
        if(dist[X][Y])
        {
            printf("%d\n",dist[X][Y]-1);
            return;
        }
    }
}

int main()
{
    memset(v,1,sizeof(v));
    mov[0][0]=1;
    mov[2][0]=-1;
    mov[1][1]=1;
    mov[3][1]=-1;
    scanf("%d%d%d",&amp;X,&amp;Y,&amp;n);
    X+=delt;Y+=delt;
    for(int i=1;i&lt;=n;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        v[x+delt][y+delt]=false;
    }

    bfs(delt,delt);

    return 0;
}
<pre><h2>Problem1629</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,ans=-2000000000,sigmaw;

struct size
{
	int w,s;
}cow[50010];

inline bool cmp(size a,size b)
{
	return a.w+a.s&lt;b.w+b.s;
}

inline int max(long long a,long long b)
{
	return a&gt;b?a:b; 
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;cow[i].w,&amp;cow[i].s);
	
	sort(cow+1,cow+n+1,cmp);
	
	for(int i=1;i&lt;=n;i++)
	{
		ans=max(ans,sigmaw-cow[i].s);
		sigmaw+=cow[i].w;
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1631</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1000000000;

int n,m,S,cnt;
int g[1010],dist1[1010],dist2[1010];
int q[1010];
bitset&lt;1010&gt;v;

struct size
{
    int x,y,c;
}E[100010];
struct edge
{
    int t,c,next;
}e[100010];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void spfa1(int x)
{
    for(int i=1;i&lt;=n;i++)
        dist1[i]=inf;
    dist1[x]=0;
    v.reset();
    q[1]=x;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        v.reset(x);
        for(int i=g[x];i;i=e[i].next)
            if(dist1[x]+e[i].c&lt;dist1[e[i].t])
            {
                dist1[e[i].t]=dist1[x]+e[i].c;
                if(!v.test(e[i].t))
                {
                    v.set(e[i].t);
                    t=t%n+1;
                    q[t]=e[i].t;
                }
            }
    }
}

inline void spfa2(int x)
{
    for(int i=1;i&lt;=n;i++)
        dist2[i]=inf;
    dist2[x]=0;
    v.reset();
    q[1]=x;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        v.reset(x);
        for(int i=g[x];i;i=e[i].next)
            if(dist2[x]+e[i].c&lt;dist2[e[i].t])
            {
                dist2[e[i].t]=dist2[x]+e[i].c;
                if(!v.test(e[i].t))
                {
                    v.set(e[i].t);
                    t=t%n+1;
                    q[t]=e[i].t;
                }
            }
    }
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;S);
    for(int i=1;i&lt;=m;i++)
    {
        scanf("%d%d%d",&amp;E[i].x,&amp;E[i].y,&amp;E[i].c);
        add_edge(E[i].x,E[i].y,E[i].c);
    }
    spfa1(S);

    memset(g,0,sizeof(g));
    cnt=0;
    for(int i=1;i&lt;=m;i++)
        add_edge(E[i].y,E[i].x,E[i].c);
    spfa2(S);

    int ans=0;
    for(int i=1;i&lt;=n;i++)
        ans=max(ans,dist1[i]+dist2[i]);
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1632</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

int n,m,cnt;
int S,T;
int mx[10],my[10];
int a[35][35];
int g[1010],dist[1010],q[1010];
long long b[1010];
bitset&lt;1010&gt;v;
struct edge
{
    int t,c,next;
}e[10010];

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline bool check(int x,int y)
{
    return x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=m;
}

inline int calc(int x,int y)
{
    return (x-1)*m+y;
}

inline void spfa(int x)
{
    for(int i=1;i&lt;=n;i++)
        dist[i]=inf;
    memset(b,0,sizeof(b));
    v.reset();

    dist[x]=0;
    b[x]=1;
    q[1]=x;

    int h=0,t=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        v.reset(x);

        for(int i=g[x];i;i=e[i].next)
            if(dist[x]+e[i].c&lt;dist[e[i].t])
            {
                dist[e[i].t]=dist[x]+e[i].c;
                b[e[i].t]=b[x];
                if(!v.test(e[i].t))
                {
                    t=t%n+1;
                    q[t]=e[i].t;
                    v.set(e[i].t);
                }
            }
            else
                if(dist[x]+e[i].c==dist[e[i].t])
                    b[e[i].t]+=b[x];

    }
}

int main()
{
    mx[0]=1;mx[1]=2;mx[2]=2;mx[3]=1;mx[4]=-1;mx[5]=-2;mx[6]=-2;mx[7]=-1;
    my[0]=2;my[1]=1;my[2]=-1;my[3]=-2;my[4]=-2;my[5]=-1;my[6]=1;my[7]=2;

    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            scanf("%d",&amp;a[i][j]);
            if(a[i][j]==3)
            {
                S=calc(i,j);
                continue;
            }
            if(a[i][j]==4)
            {
                T=calc(i,j);
                continue;
            }
        }
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            if(a[i][j]!=2)
                for(int k=0;k&lt;8;k++)
                    if(check(i+mx[k],j+my[k])&amp;&amp;a[i+mx[k]][j+my[k]]!=2)
                        add_edge(calc(i,j),calc(i+mx[k],j+my[k]),a[i+mx[k]][j+my[k]]==0?2001:1);

    n=n*m;
    spfa(S);

    if(dist[T]==inf)
        printf("-1\n");
    else
        printf("%d\n%d\n%lld\n",dist[T]/2000,dist[T]%2000,b[T]);

    return 0;
}
/*
4 8
0 0 0 1 0 0 0 0
0 0 0 0 0 2 0 1
0 0 0 0 0 4 0 0
3 0 0 0 0 0 1 0
*/
<pre><h2>Problem1633</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;

using namespace std;

int n,f[310],L;
char a[310],b[610][30];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int cal(int x,int len,int y)
{
    int tot=0;
    int l1=x,l2=1;
    while(l1&lt;=L)
    {
        if(a[l1]==b[y][l2])l2++;
        else tot++;
        if(l2==len+1)return tot;
        l1++;
    }
    return -1;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;L);

    scanf("%s",a+1);

    for(int i=1;i&lt;=n;i++)
        scanf("%s",b[i]+1);

    f[L+1]=0;
    for(int i=L;i;i--)
    {
        f[i]=f[i+1]+1;
        for(int j=1;j&lt;=n;j++)
        {
            int len=strlen(b[j]+1);
            int t=cal(i,len,j);
            if(t!=-1)f[i]=min(f[i],f[i+len+t]+t);
        }
    }

    printf("%d",f[1]);

    return 0;
}
<pre><h2>Problem1634</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;
long long ans;

struct size
{
    int t,d;
}cow[100010];

inline bool cmp(size x,size y)
{
    return x.t*y.d&lt;x.d*y.t;
}

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf("%d%d",&amp;cow[i].t,&amp;cow[i].d);
    sort(cow+1,cow+n+1,cmp);

    long long time=0;
    for(int i=1;i&lt;=n;i++)
    {
        ans+=(long long)time*cow[i].d;
        time+=cow[i].t&lt;&lt;1;
    }
    printf("%lld\n",ans);

    return 0;
}
<pre><h2>Problem1641</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

int n,m,t;
int dist[310][310];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;t);

    memset(dist,127,sizeof(dist));
    for(int i=1;i&lt;=n;i++)dist[i][i]=0;

    for(;m;m--)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        dist[x][y]=min(dist[x][y],z);
    }

    for(int k=1;k&lt;=n;k++)
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
                dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));

    for(;t;t--)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        printf("%d\n",dist[x][y]&lt;inf?dist[x][y]:-1);
    }

    return 0;
}
<pre><h2>Problem1642</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,r,ans;
int f[1010];
struct size
{
    int s,t,v;
    inline friend bool operator&lt;(size a,size b)
    {
        return a.s&lt;b.s;
    }
}cow[1010];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;r);
    for(int i=1;i&lt;=m;i++)
        scanf("%d%d%d",&amp;cow[i].s,&amp;cow[i].t,&amp;cow[i].v);

    sort(cow+1,cow+m+1);
    for(int i=1;i&lt;=m;i++)
    {
        f[i]=cow[i].v;
        for(int j=1;j&lt;i;j++)
            if(cow[j].t+r&lt;=cow[i].s)
                ans=max(ans,f[i]=max(f[i],f[j]+cow[i].v));
    }

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1648</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int k,n,m,cnt;
int cow[110];
int g[1010];
bitset&lt;1010&gt;v,V;

struct edge
{
    int t,next;
}e[10010];

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void dfs(int x)
{
    v.set(x);
    for(int i=g[x];i;i=e[i].next)
        if(!v.test(e[i].t))
            dfs(e[i].t);
}

int main()
{
    scanf("%d%d%d",&amp;k,&amp;n,&amp;m);
    for(int i=1;i&lt;=k;i++)
        scanf("%d",cow+i);
    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(x,y);
    }

    V.set();
    for(int i=1;i&lt;=k;i++)
    {
        v.reset();
        dfs(cow[i]);
        V=V&amp;v;
    }

    printf("%d\n",V.count());

    return 0;
}
<pre><h2>Problem1649</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int l,n,b;
int f[1010][1010];

struct size
{
    int x,w,f,c;
}m[10010];
inline bool cmp(size a,size b)
{
    return a.x&lt;b.x;
}

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

int main()
{
    scanf("%d%d%d",&amp;l,&amp;n,&amp;b);
    for(int i=1;i&lt;=n;i++)
        scanf("%d%d%d%d",&amp;m[i].x,&amp;m[i].w,&amp;m[i].f,&amp;m[i].c);
    sort(m+1,m+n+1,cmp);

    for(int i=0;i&lt;=l;i++)
        for(int j=0;j&lt;=b;j++)
            f[i][j]=-1;
    f[0][0]=0;
    for(int i=1;i&lt;=n;i++)
    {
        int ma=b-m[i].c;
        for(int j=0;j&lt;=ma;j++)
            if(f[m[i].x][j]&gt;=0)
                f[m[i].x+m[i].w][j+m[i].c]=max(f[m[i].x+m[i].w][j+m[i].c],f[m[i].x][j]+m[i].f);
    }

    int ans=-1;
    for(int i=0;i&lt;=b;i++)
        ans=max(ans,f[l][i]);
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1650</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
#include&lt;algorithm&gt;

using namespace std;

int L,n,m;
int a[50010];
bitset&lt;50010&gt;v;

inline int check(int x)
{
    int temp=0,cnt=0;
    v.reset();

    for(int i=1;i&lt;=n;i++)
        if(a[i]-temp&lt;x)
        {
            cnt++;
            v.set(i);
        }
        else
            temp=a[i];

    for(int i=n;i;i--)
        if(L-a[i]&lt;x&amp;&amp;!v.test(i))
        {
            cnt++;
            v.set(i);
        }
        else
            if(L-a[i]&gt;=x)
                break;

    return cnt;
}
int main()
{
    scanf("%d%d%d",&amp;L,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        scanf("%d",a+i);
    sort(a+1,a+n+1);

    int ans=0;
    int l=1,r=L;
    while(l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(check(mid)&lt;=m)
        {
            ans=mid;
            l=mid+1;
        }
        else
            r=mid-1;
    }

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1651</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;

using namespace std;

int n,siz,ans;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;
struct cow
{
	int l,r;
	inline friend bool operator&lt;(cow x,cow y)
	{
		return x.l&lt;y.l;
	}
}c[50010];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;c[i].l,&amp;c[i].r);
	sort(c+1,c+n+1);
	
	for(int i=1;i&lt;=n;i++)
	{
		while(!q.empty()&amp;&amp;c[i].l&gt;q.top())
		{
			q.pop();
			siz--;
		}
		q.push(c[i].r);
		siz++;
		ans=max(ans,siz);
	}
	printf("%d\n",ans);
	
	return 0;
} <pre><h2>Problem1652</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n;
int a[2010];
int f[2010][2010];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",a+i);
		f[i][i]=n*a[i];
	}
	for(int i=2;i&lt;=n;i++)
		for(int j=1;j&lt;=n+1-i;j++)
			f[j][j+i-1]=max(f[j+1][j+i-1]+a[j]*(n-i+1),f[j][j+i-2]+a[j+i-1]*(n-i+1));
	printf("%d\n",f[1][n]);
	
	return 0;
}<pre><h2>Problem1657</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,top,ans;
int f[50010],h[50010],v[50010];
int s1[50010],s2[50010];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
        scanf("%d%d",h+i,v+i);

	for(int i=1;i&lt;=n;i++)
	{
		while(top&gt;0&amp;&amp;h[i]&gt;s1[top])
		{
			f[i]+=s2[top];
			top--;
		}
		s1[++top]=h[i];
        s2[top]=v[i];
	}

	top=0;
	for(int i=n;i&gt;0;i--)
	{
		while(top&gt;0&amp;&amp;h[i]&gt;s1[top])
		{
			f[i]+=s2[top];
			top--;
		}
		s1[++top]=h[i];
		s2[top]=v[i];
	}

	for(int i=1;i&lt;=n;i++)
        ans=max(ans,f[i]);

	printf("%d",ans);

	return 0;
}
<pre><h2>Problem1661</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,ans=0;
char str[1010];
int map[1010][1010];

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%s",str);
        for(int j=1;j&lt;=n;j++)
        {
            if(str[j-1]=='J')map[i][j]=1;
            if(str[j-1]=='*')map[i][j]=2;
        }
    }

    for(int x=1;x&lt;=n;x++)
        for(int y=1;y&lt;=n;y++)
            if(map[x][y]==1)
                for(int i=1;i&lt;=n;i++)
                    for(int j=1;j&lt;=n;j++)
                        if(!(x==i&amp;&amp;y==j)&amp;&amp;map[i][j])
                        {
                            int a=i-x,b=j-y;
                            if(a*a+b*b&lt;=ans)continue;
                            if(i-b&gt;0&amp;&amp;j+a&gt;0&amp;&amp;x-b&gt;0&amp;&amp;y+a&gt;0&amp;&amp;map[i-b][j+a]==1&amp;&amp;map[x-b][y+a]==1)
                            {
                                ans=a*a+b*b;
                                continue;
                            }
                            if(i+b&gt;0&amp;&amp;j-a&gt;0&amp;&amp;x+b&gt;0&amp;&amp;y-a&gt;0&amp;&amp;map[i+b][j-a]==1&amp;&amp;map[x+b][y-a]==1)ans=a*a+b*b;
                        }

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1665</h2><pre>#include&lt;cstdio&gt;
 
using namespace std;
 
const int inf=1000000000;
 
int n,H;
int cnt,siz;
int g[10010];
bool v[10010];
int key[10010],num[10010],pl[10010];
 
struct edge
{
    int t,c,next;
}e[3000010];
struct rock
{
	int x,y;
}h[10010];

inline void swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline int sqr(int x)
{
	return x*x;
}
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
 
inline void up(int p)
{
    while(p&gt;&gt;1)
    {
        int x=p&gt;&gt;1;
        if(key[p]&gt;=key[x])return;
        swap(key[x],key[p]);
        swap(num[x],num[p]);
        swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void down(int p)
{
    while((p&lt;&lt;1)&lt;=siz)
    {
        int x=p&lt;&lt;1;
        if(x&lt;siz&amp;&amp;key[x|1]&lt;key[x])x|=1;
        if(key[p]&lt;=key[x])return;
        swap(key[x],key[p]);
        swap(num[x],num[p]);
        swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void ins(int p,int v)
{
    key[++siz]=v;
    num[siz]=p;
    pl[p]=siz;
    up(siz);
}
inline void del(int p)
{
    key[p]=key[siz];
    num[p]=num[siz];
    pl[num[p]]=p;
    siz--;
    down(p);
}
 
inline int dijkstra()
{
    siz=1;
    key[1]=0;
    num[1]=1;
    pl[1]=1;
 
    while(siz)
    {
        int x=num[1];
        int dist=key[1];
        if(x==n)return dist;
        v[x]=true;
        del(1);
 
        for(int i=g[x];i;i=e[i].next)
            if(!v[e[i].t])
                if(!pl[e[i].t])
                    ins(e[i].t,dist+e[i].c);
                else
                    if(dist+e[i].c&lt;key[pl[e[i].t]])
                    {
                        key[pl[e[i].t]]=dist+e[i].c;
                        up(pl[e[i].t]);
                    }
    }
}
 
int main()
{
    scanf("%d%d",&amp;H,&amp;n);
    
    for(int i=1;i&lt;=n;i++)
    {
		scanf("%d%d",&amp;h[i].x,&amp;h[i].y);
		if(h[i].y&lt;=1000)add_edge(1,i+1,1);
		if(h[i].y&gt;=H-1000)add_edge(i+1,n+2,0);
		for(int j=1;j&lt;i;j++)
			if(sqr(h[i].x-h[j].x)+sqr(h[i].y-h[j].y)&lt;=1000000)
			{
				add_edge(i+1,j+1,1);
				add_edge(j+1,i+1,1);
			}
	}
	n+=2;
    printf("%d\n",dijkstra());
    
    return 0;
}
/*
3000 5
600 800
1600 1800
100 1300
300 2100
1600 2300
*/<pre><h2>Problem1666</h2><pre>#include&lt;cstdio&gt;
using namespace std;
long long n;
int cnt;
int main()
{
    scanf("%lld",&amp;n);
    while(n!=1)
    {
        if(n&amp;1)n=n*3+1;else n&gt;&gt;=1;
        cnt++;
    }
    printf("%d\n",cnt);
    return 0;
}
<pre><h2>Problem1669</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,t,ans=0;
int que[5010];

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        if(x&gt;que[ans])
            que[++ans]=x;
        else
        {
            int l=1,r=ans;
            while(l&lt;=r)
            {
                int mid=(l+r)/2;
                if(x&gt;que[mid])
                    l=mid+1;
                else
                    r=mid-1;
            }
            que[l]=x;
        }
    }

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1677</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n;
int a[1000001];
int main()
{
    scanf("%d",&amp;n);

    a[1]=1;
	for(int i=2;i&lt;=n;i++)
	{
		a[i]=a[i-1];
		if(!(i&amp;1))a[i]=a[i-1]+a[i&gt;&gt;1];
		a[i]%=1000000000;
	}

	printf("%d\n",a[n]);

	return 0;
}
<pre><h2>Problem1681</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,c,t;
int cnt,siz;
int ans[510];
int g[510],dist[510];
bool v[510];
int key[510],num[510],pl[510];

struct edge
{
    int t,c,next;
}e[2010];

inline void swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void up(int p)
{
    while(p&gt;&gt;1)
    {
        int x=p&gt;&gt;1;
        if(key[p]&gt;=key[x])return;
        swap(key[x],key[p]);
        swap(num[x],num[p]);
        swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void down(int p)
{
    while((p&lt;&lt;1)&lt;=siz)
    {
        int x=p&lt;&lt;1;
        if(x&lt;siz&amp;&amp;key[x|1]&lt;key[x])x|=1;
        if(key[p]&lt;=key[x])return;
        swap(key[x],key[p]);
        swap(num[x],num[p]);
        swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void ins(int p,int v)
{
    key[++siz]=v;
    num[siz]=p;
    pl[p]=siz;
    up(siz);
}
inline void del(int p)
{
    key[p]=key[siz];
    num[p]=num[siz];
    pl[num[p]]=p;
    siz--;
    down(p);
}

inline void dijkstra(int x)
{
    for(int i=1;i&lt;=n;i++)
        dist[i]=inf;

    siz=1;
    key[1]=0;
    num[1]=x;
    pl[x]=1;

    while(siz)
    {
        int x=num[1];
        dist[x]=key[1];
        v[x]=true;
        del(1);

        for(int i=g[x];i;i=e[i].next)
            if(!v[e[i].t])
                if(!pl[e[i].t])
                    ins(e[i].t,dist[x]+e[i].c);
                else
                    if(dist[x]+e[i].c&lt;key[pl[e[i].t]])
                    {
                        key[pl[e[i].t]]=dist[x]+e[i].c;
                        up(pl[e[i].t]);
                    }
    }
}

int main()
{
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;c,&amp;t);
	for(int i=1;i&lt;=m;i++)
	{
	    int x,y,z;
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		add_edge(x,y,z);
		add_edge(y,x,z);
	}

	dijkstra(1);
	for(int i=1;i&lt;=c;i++)
    {
        int x;
        scanf("%d",&amp;x);
        if(dist[x]&lt;=t)ans[++ans[0]]=i;
    }

    printf("%d\n",ans[0]);
    for(int i=1;i&lt;=ans[0];i++)
        printf("%d\n",ans[i]);

	return 0;
}
<pre><h2>Problem1682</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,ans;
int fa[2010],ran[2010];

struct edge
{
    int x,y,c;
    inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
    {
        return a.c&lt;b.c;
    }
}e[10010];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}
inline void unio(int x,int y)
{
    int f1=find(x),f2=find(y);
    if(ran[f1]&lt;ran[f2])
        fa[f1]=f2;
    else
    {
        fa[f2]=f1;
        if(ran[f1]==ran[f2])ran[f1]++;
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=m;i++)
        scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].c);

    for(int i=1;i&lt;=n;i++)
        fa[i]=i;
    sort(e+1,e+m+1);
    for(int i=1;i&lt;=m;i++)
    {
        if(find(e[i].x)!=find(e[i].y))
        {
            unio(e[i].x,e[i].y);
            ans=max(ans,e[i].c);
        }
    }
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1684</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const long double eps=1e-10;

inline long double fabs(long double x)
{
	return x&lt;0.0?-x:x;
}
inline bool check(long double a,long double b)
{
	return fabs(a-b)&lt;eps;
}

int main()
{
	int a,b;
	scanf("%d%d",&amp;a,&amp;b);
	long double P1=(long double)a/b;
	long double mi=1000000.0;
	int N1,N2;
	for(int i=1;i&lt;=32767;i++)
	{
		int B=i,a1=i*a/b,a2=i*a/b+1,a3=i*a/b-1;
		long double P2=(long double)a1/B,P3=(long double)a2/B,P4=(long double)a3/B;
		if(!check(P1,P2))
		{
			if(fabs(P1-P2)&lt;mi)
			{
				mi=fabs(P1-P2);
				N1=a1;
				N2=B;
			}
		}
		if(!check(P1,P3)&amp;&amp;a2&lt;=32767)
		{
			if(fabs(P1-P3)&lt;mi)
			{
				mi=fabs(P1-P3);
				N1=a2;
				N2=B;
			}
		}
		if(!check(P1,P4)&amp;&amp;a3&gt;0)
		{
			if(fabs(P1-P4)&lt;mi)
			{
				mi=fabs(P1-P4);
				N1=a3;
				N2=B;
			}
		}
	}
	printf("%d %d\n",N1,N2);
	
	return 0;
}<pre><h2>Problem1691</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m;
long long ans=0;
multiset&lt;int&gt;s;
struct size
{
    int a,b;
    inline friend bool operator&lt;(const size&amp;x,const size&amp;y)
    {
        return x.b&gt;y.b;
    }
}cow[100010],g[100010];

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        scanf("%d%d",&amp;cow[i].a,&amp;cow[i].b);
    for(int i=1;i&lt;=m;i++)
        scanf("%d%d",&amp;g[i].a,&amp;g[i].b);
    sort(cow+1,cow+n+1);
    sort(g+1,g+m+1);
    int temp=0;
    for(int i=1;i&lt;=n;i++)
    {
        while(temp&lt;m&amp;&amp;g[temp+1].b&gt;=cow[i].b)s.insert(g[++temp].a);
        multiset&lt;int&gt;::iterator it=s.lower_bound(cow[i].a);
        if(it==s.end())
        {
            printf("-1\n");
            return 0;
        }
        else
        {
            ans+=*it;
            s.erase(it);
        }
    }
    printf("%lld\n",ans);
    return 0;
}
<pre><h2>Problem1699</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,q;
int a[20];
int st1[50010][20],st2[50010][20];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;q);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;st1[i][0]);
        st2[i][0]=st1[i][0];
    }

    int k=0;
    a[0]=1;

    while((a[k]&lt;&lt;1)&lt;=n)
    {
        k++;
        a[k]=a[k-1]&lt;&lt;1;
    }

    for(int i=1;i&lt;=k;i++)
        for(int j=1;j&lt;=n;j++)
            if(j+a[i]-1&lt;=n)
            {
                st1[j][i]=max(st1[j][i-1],st1[j+a[i-1]][i-1]);
                st2[j][i]=min(st2[j][i-1],st2[j+a[i-1]][i-1]);
            }

    for(;q;q--)
    {
        int l,r;
        scanf("%d%d",&amp;l,&amp;r);

        int ma=0,mi=inf;
        for(int i=k;i&gt;=0;i--)
            if(l+a[i]-1&lt;=r)
            {
                ma=max(ma,st1[l][i]);
                mi=min(mi,st2[l][i]);
                l+=a[i];
            }
        printf("%d\n",ma-mi);
    }

    return 0;
}
<pre><h2>Problem1700</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n,m;
int a[310],b[310],s1[310],s2[310];
int f[310][310];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}

int main()
{
    m=read();n=read();
    for(int i=1;i&lt;=n;i++)
    {
        a[i]=read();b[i]=read();
        s1[i]=s1[i-1]+a[i];s2[i]=s2[i-1]+b[i];
    }

    memset(f,-1,sizeof(f));
    f[1][0]=m;
    for(int i=2;i&lt;=n+1;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            int temp=-1;
            for(int k=0;k&lt;=j;k++)
                if(f[i-1][k]!=-1)
                    if(s1[j]-s1[k]&lt;=f[i-1][k]&amp;&amp;s2[j]-s2[k]&lt;=m)
                        temp=Max(temp,m-s2[j]+s2[k]);
            f[i][j]=temp;
        }
        if(f[i][n]!=-1)
        {
            printf("%d\n",i+1);
            return 0;
        }
    }
    return 0;
}
<pre><h2>Problem1702</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;

using namespace std;

const int Pr1=1999997;
const int Pr2=19999999;

int n,k,ans=0;
int sum[100010][31];
unsigned int h1[100010],h2[100010];
map&lt;pair&lt;unsigned int,unsigned int&gt;,int&gt;m;

inline int read()
{
    char c=getchar();
    int temp=0;

    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
    n=read();k=read();
    for(int i=1;i&lt;=n;i++)
    {
        int x=read();
        for(int j=1;j&lt;=k;j++)
        {
            if(x&amp;1)sum[i][j]=1;
            sum[i][j]+=sum[i-1][j];
            x&gt;&gt;=1;
        }
    }

    for(int i=1;i&lt;=n;i++)
    {
        for(int j=2;j&lt;=k;j++)
            sum[i][j]-=sum[i][1];
        sum[i][1]=0;

        for(int j=2;j&lt;=k;j++)
        {
            h1[i]=h1[i]*Pr1+sum[i][j];
            h2[i]=h2[i]*Pr2+sum[i][j];
        }
    }

    for(int i=n;i&gt;=0;i--)
    {
        int temp=m[make_pair(h1[i],h2[i])];

        if(temp)
            ans=max(ans,temp-i);
        else
            m[make_pair(h1[i],h2[i])]=i;
    }

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1705</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int bigint=1000000000,a[100010],dp[2][233];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

int main()
{
	int i,j,k,m,n,o,p,ans;
	scanf("%d%d",&amp;n,&amp;m);
	for(i=1;i&lt;=n;i++)scanf("%d",a+i);
	o=0;
	p=1;
	for(i=1;i&lt;=n;i++)
	{
		k=1;
		for(j=1;j&lt;=100;j++)
		{
			if(dp[o][k]+m*(j-k)&gt;dp[o][j])k=j;
			if(j&lt;a[i])
			{
				dp[p][j]=bigint;
				continue;
			}
			dp[p][j]=dp[o][k]+m*(j-k)+(j-a[i])*(j-a[i]);
		}
		k=100;
		for(j=100;j&gt;=a[i];j--)
		{
			if(dp[o][k]+m*(k-j)&gt;dp[o][j])k=j;
			dp[p][j]=min(dp[p][j],dp[o][k]+m*(k-j)+(j-a[i])*(j-a[i]));
		}
		swap(o,p);
	}
	ans=bigint;
	
	for(i=1;i&lt;=100;i++)
		ans=min(ans,dp[o][i]);
		
	printf("%d\n",ans);
	return 0;
}<pre><h2>Problem1706</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int maa[2333],dp[2][23333];

struct node
{
	int u,v,k;
}a[23333];

int main()
{
	int i,j,k,m,n,t,s,e,l,o,p,u,v;
	scanf("%d%d%d%d",&amp;t,&amp;m,&amp;s,&amp;e);
	n=0;
	memset(maa,0,sizeof(maa));
	for(i=1;i&lt;=m;i++)
	{
		scanf("%d%d%d",&amp;l,&amp;j,&amp;k);
		if(maa[j]==0)
		{
			n++;
			maa[j]=n;
		}
		if(maa[k]==0)
		{
			n++;
			maa[k]=n;
		}
		a[i].u=maa[j];
		a[i].v=maa[k];
		a[i].k=l;
	}
	for(i=1;i&lt;=n;i++)
	{
		dp[0][i]=-1;
	}
	dp[0][maa[s]]=0;
	o=0;
	p=1;
	for(i=1;i&lt;=t;i++)
	{
		for(j=1;j&lt;=n;j++)
		{
			dp[p][j]=-1;
		}
		for(j=1;j&lt;=m;j++)
		{
			u=a[j].u;
			v=a[j].v;
			if(dp[o][u]&gt;=0 &amp;&amp; (dp[p][v]==-1 || dp[o][u]+a[j].k&lt;dp[p][v]))dp[p][v]=dp[o][u]+a[j].k;
			if(dp[o][v]&gt;=0 &amp;&amp; (dp[p][u]==-1 || dp[o][v]+a[j].k&lt;dp[p][u]))dp[p][u]=dp[o][v]+a[j].k;
		}
		swap(o,p);
	}
	printf("%d\n",dp[o][maa[e]]);
	return 0;
}<pre><h2>Problem1707</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,l;
struct size1
{
	int mi,ma;
	inline friend bool operator&lt;(const size1&amp;a,const size1&amp;b)
	{
		return a.ma&lt;b.ma||a.ma==b.ma&amp;&amp;a.mi&gt;b.mi;
	}
}c[2510];
struct size2
{
	int spf,num;
}s[2510];

int main()
{
	scanf("%d%d",&amp;n,&amp;l);
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;c[i].mi,&amp;c[i].ma);
	for(int i=1;i&lt;=l;i++)
		scanf("%d%d",&amp;s[i].spf,&amp;s[i].num);
	
	sort(c+1,c+n+1);
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		int temp=-1;
		for(int j=1;j&lt;=l;j++)
			if(s[j].num&amp;&amp;c[i].mi&lt;=s[j].spf&amp;&amp;s[j].spf&lt;=c[i].ma)
				if(temp==-1)
					temp=j;
				else
					if(s[j].spf&lt;s[temp].spf)
						temp=j;
		if(temp!=-1)
		{
			ans++;
			s[temp].num--;
		}
	}
	
	printf("%d\n",ans);
	
	return 0;
} <pre><h2>Problem1708</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m;
int a[30];
long long f[10010];

int main()
{
    scanf("%d%d",&amp;m,&amp;n);
    for(int i=1;i&lt;=m;i++)scanf("%d",a+i);

    f[0]=1;
    for(int j=1;j&lt;=m;j++)
        for(int i=a[j];i&lt;=n;i++)
            f[i]+=f[i-a[j]];

    printf("%lld\n",f[n]);

    return 0;
}
<pre><h2>Problem1709</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,k,ans;
bool m[110][110];

inline bool check(int x,int y)
{
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(m[i][j])
				if(x!=i&amp;&amp;y!=j&amp;&amp;x+y!=i+j&amp;&amp;x-y!=i-j)
					return false;
	return true;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;=k;i++)
	{
		int x,y;
		scanf("%d%d",&amp;x,&amp;y);
		m[x][y]=true;
	}
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(check(i,j))
				ans++;
	printf("%d\n",ans);
	
	return 0;
} <pre><h2>Problem1711</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

int n,f,d,siz=-1;
int ch[510];
int vh[510],dis[510],pre[510],di[510],his[510];

vector&lt;int&gt; g[510];

struct size
{
    int t,c;
}edge[1000000];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    edge[++siz].t=y;
    edge[siz].c=z;
    ch[x]++;
    g[x].push_back(siz);

    edge[++siz].t=x;
    edge[siz].c=0;
    ch[y]++;
    g[y].push_back(siz);
}

inline int isap()
{
    vh[0]=n;
    int flow=0,aug=inf,i=1;

    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[i]=aug;

        for(int x=di[i];x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]+1==dis[i])
            {
                di[i]=x;
                aug=min(aug,edge[g[i][x]].c);
                flag=true;
                pre[edge[g[i][x]].t]=g[i][x]^1;
                i=edge[g[i][x]].t;

                if(i==n)
                {
                    flow+=aug;

                    while(i!=1)
                    {
                        edge[pre[i]].c+=aug;
                        edge[pre[i]^1].c-=aug;
                        i=edge[pre[i]].t;
                    }

                    aug=inf;
                }

                break;
            }

        if(flag)continue;

        int mi=n,mii;

        for(int x=0;x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]&lt;mi)
                mi=dis[edge[g[i][x]].t],mii=x;

        vh[dis[i]]--;
        if(vh[dis[i]]==0)break;
        dis[i]=mi+1;

        vh[dis[i]]++;
        di[i]=mii;

        if(i!=1)
        {
            i=edge[pre[i]].t;
            aug=his[i];
        }
    }

    return flow;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;f,&amp;d);
    for(int i=1;i&lt;=f;i++)
        add_edge(1,i+1,1);
    for(int i=1;i&lt;=d;i++)
        add_edge(1+f+n+n+i,1+f+n+n+d+1,1);
    for(int i=1;i&lt;=n;i++)
    {
        int x,y,z;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(1+f+i,1+f+n+i,1);
        for(int j=1;j&lt;=x;j++)
        {
            scanf("%d",&amp;z);
            add_edge(1+z,1+f+i,1);
        }
        for(int j=1;j&lt;=y;j++)
        {
            scanf("%d",&amp;z);
            add_edge(1+f+n+i,1+f+n+n+z,1);
        }
    }
    n=1+f+n+n+d+1;

    printf("%d\n",isap());

    return 0;
}
<pre><h2>Problem1715</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int t,n,m,w;
int dist[510];

struct size
{
    int s,t,c;
}e[6000];

inline bool bellman_ford(int x)
{
    for(int i=1;i&lt;=n;i++)
        dist[i]=inf;
    dist[x]=0;
    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++)
            if(dist[e[j].s]+e[j].c&lt;dist[e[j].t])
                dist[e[j].t]=dist[e[j].s]+e[j].c;
    for(int j=1;j&lt;=m;j++)
            if(dist[e[j].s]+e[j].c&lt;dist[e[j].t])
                return true;
    return false;
}

int main()
{
    scanf("%d",&amp;t);

    for(int i=1;i&lt;=t;i++)
    {
        scanf("%d%d%d",&amp;n,&amp;m,&amp;w);

        for(int i=1;i&lt;=m;i++)
            scanf("%d%d%d",&amp;e[i].s,&amp;e[i].t,&amp;e[i].c);

        for(int i=m+1;i&lt;=m+m;i++)
        {
            e[i].s=e[i-m].t;
            e[i].t=e[i-m].s;
            e[i].c=e[i-m].c;
        }

        for(int i=(m&lt;&lt;1)+1;i&lt;=(m&lt;&lt;1)+w;i++)
        {
            scanf("%d%d%d",&amp;e[i].s,&amp;e[i].t,&amp;e[i].c);
            e[i].c=-e[i].c;
        }

        m=m+m+w;

        bool flag=false;
        int ma=n;
        if(10&lt;ma)ma=10;
        for(int i=1;i&lt;=ma;i++)
        {
            if(bellman_ford(i))
            {
                flag=true;
                break;
            }
        }

        if(flag)
            printf("YES\n");
        else
            printf("NO\n");
    }

    return 0;
}
<pre><h2>Problem1715</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int t,n,m,w;
int dist[510];

struct size
{
    int s,t,c;
}e[6000];

inline bool bellman_ford(int x)
{
    for(int i=1;i&lt;=n;i++)
        dist[i]=inf;
    dist[x]=0;
    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++)
            if(dist[e[j].s]+e[j].c&lt;dist[e[j].t])
                dist[e[j].t]=dist[e[j].s]+e[j].c;
    for(int j=1;j&lt;=m;j++)
            if(dist[e[j].s]+e[j].c&lt;dist[e[j].t])
                return true;
    return false;
}

int main()
{
    scanf("%d",&amp;t);

    for(int i=1;i&lt;=t;i++)
    {
        scanf("%d%d%d",&amp;n,&amp;m,&amp;w);

        for(int i=1;i&lt;=m;i++)
            scanf("%d%d%d",&amp;e[i].s,&amp;e[i].t,&amp;e[i].c);

        for(int i=m+1;i&lt;=m+m;i++)
        {
            e[i].s=e[i-m].t;
            e[i].t=e[i-m].s;
            e[i].c=e[i-m].c;
        }

        for(int i=(m&lt;&lt;1)+1;i&lt;=(m&lt;&lt;1)+w;i++)
        {
            scanf("%d%d%d",&amp;e[i].s,&amp;e[i].t,&amp;e[i].c);
            e[i].c=-e[i].c;
        }

        m=m+m+w;
        
        if(bellman_ford(1))
            printf("YES\n");
        else
            printf("NO\n");
    }

    return 0;
}
<pre><h2>Problem1715</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int t,n,m,w;
int dist[510];

struct size
{
    int s,t,c;
}e[6000];

inline bool bellman_ford()
{
    memset(dist,0,sizeof(dist));

    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++)
            if(dist[e[j].s]+e[j].c&lt;dist[e[j].t])
                dist[e[j].t]=dist[e[j].s]+e[j].c;
    for(int j=1;j&lt;=m;j++)
            if(dist[e[j].s]+e[j].c&lt;dist[e[j].t])
                return true;
    return false;
}

int main()
{
    scanf("%d",&amp;t);

    for(int i=1;i&lt;=t;i++)
    {
        scanf("%d%d%d",&amp;n,&amp;m,&amp;w);

        for(int i=1;i&lt;=m;i++)
        {
            scanf("%d%d%d",&amp;e[i].s,&amp;e[i].t,&amp;e[i].c);
            e[i+m].s=e[i].t;
            e[i+m].t=e[i].s;
            e[i+m].c=e[i].c;
        }

        m&lt;&lt;=1;
        for(int i=m+1;i&lt;=m+w;i++)
        {
            scanf("%d%d%d",&amp;e[i].s,&amp;e[i].t,&amp;e[i].c);
            e[i].c=-e[i].c;
        }

        m+=w;

        if(bellman_ford())
            printf("YES\n");
        else
            printf("NO\n");
    }

    return 0;
}
<pre><h2>Problem1717</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,K;
int sa[20010],rank[20010],height[20010];
int x[40010],y[40010],sum[20010];
int str[20010];
map&lt;int,int&gt;h;

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}
inline int Min(int a,int b)
{
	return a&lt;b?a:b;
}
inline int Max(int a,int b)
{
	return a&gt;b?a:b;
}

struct seg
{
	int l,r,val;
}seg[80010];
inline void build(int p,int l,int r)
{
	seg[p].l=l;seg[p].r=r;
	if(l==r)
	{
		seg[p].val=height[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(p&lt;&lt;1,l,mid);
	build(p&lt;&lt;1|1,mid+1,r);
	seg[p].val=Min(seg[p&lt;&lt;1].val,seg[p&lt;&lt;1|1].val);
}
inline int query(int p,int l,int r)
{
	if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)
		return seg[p].val;
	int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
	
	if(r&lt;=mid)
		return query(p&lt;&lt;1,l,r);
	else
		if(l&gt;mid)
			return query(p&lt;&lt;1|1,l,r);
		else
			return Min(query(p&lt;&lt;1,l,mid),query(p&lt;&lt;1|1,mid+1,r));
}

inline void build_sa()
{
	for(int i=1;i&lt;=m;i++)
		sum[i]=0;
	for(int i=1;i&lt;=n;i++)
		sum[x[i]=str[i]]++;
	for(int i=2;i&lt;=m;i++)
		sum[i]+=sum[i-1];
	for(int i=n;i;i--)
		sa[sum[x[i]]--]=i;
	
	for(int k=1;k&lt;n;k++)
	{
		int temp=0;
		for(int i=n-k+1;i&lt;=n;i++)
			y[++temp]=i;
		for(int i=1;i&lt;=n;i++)
			if(sa[i]&gt;k)
				y[++temp]=sa[i]-k;
		
		for(int i=1;i&lt;=m;i++)
			sum[i]=0;
		for(int i=1;i&lt;=n;i++)
			sum[x[i]]++;
		for(int i=1;i&lt;=m;i++)
			sum[i]+=sum[i-1];
		for(int i=n;i;i--)
			sa[sum[x[y[i]]]--]=y[i];
		swap(x,y);temp=1;x[sa[1]]=1;
		for(int i=2;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?temp:++temp;
		m=temp;if(n==m)break;
	}
}
inline void get_height()
{
	for(int i=1;i&lt;=n;i++)
		rank[sa[i]]=i;
	
	int k=0;
	for(int i=1;i&lt;=n;i++)
	{
		if(k)k--;
		
		int j=sa[rank[i]-1];
		while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;str[i+k]==str[j+k])k++;
		
		height[rank[i]]=k;
	}
}
		
int main()
{
	n=read();K=read()-1;
	for(int i=1;i&lt;=n;i++)
	{
		int x=read();
		if(h[x])
			str[i]=h[x];
		else
			str[i]=h[x]=++m;
	}
	
	build_sa();
	get_height();
	build(1,1,n);
	
	int ans=0;
	for(int i=2;i+K-1&lt;=n;i++)
		ans=Max(ans,query(1,i,i+K-1));
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1724</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;
long long ans=0;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        q.push(x);
    }
    for(int i=1;i&lt;n;i++)
    {
        int temp=q.top();
        q.pop();
        ans+=(temp=q.top()+temp);
        q.pop();
        q.push(temp);
    }

    printf("%lld\n",ans);

    return 0;
}
<pre><h2>Problem1725</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int P=100000000;

int n,m;
int v[20];
int num[400];
int f[20][400];

inline void initialize()
{
    int temp=1&lt;&lt;m;
    for(int i=0;i&lt;temp;i++)
        if(!(i&amp;(i&lt;&lt;1)))num[++num[0]]=i;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    initialize();
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x;
            scanf("%d",&amp;x);
            v[i]&lt;&lt;=1;
            if(!x)v[i]|=1;
        }

    f[0][1]=1;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=num[0];j++)
            if(f[i-1][j])
                for(int k=1;k&lt;=num[0];k++)
                    if((num[k]&amp;v[i])==0)
                        if((num[j]&amp;num[k])==0)
                            f[i][k]=(f[i][k]+f[i-1][j])%P;

    int ans=0;
    for(int i=1;i&lt;=num[0];i++)
        ans=(ans+f[n][i])%P;
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1726</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1000000100;

int n,m,cnt;
int g[5010];
int q[5010],dist1[5010],dist2[5010];
bitset&lt;5010&gt;inque;
struct edge
{
    int t,c,next;
}e[200010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline bool update(int x,int i)
{
    if(dist1[x]+e[i].c&lt;dist1[e[i].t])
    {
        dist2[e[i].t]=min(dist1[e[i].t],dist2[x]+e[i].c);
        dist1[e[i].t]=dist1[x]+e[i].c;
        return true;
    }
    if(dist1[x]+e[i].c&lt;dist2[e[i].t]&amp;&amp;dist1[x]+e[i].c&gt;dist1[e[i].t])
    {
        dist2[e[i].t]=dist1[x]+e[i].c;
        return true;
    }
    if(dist2[x]+e[i].c&lt;dist2[e[i].t])
    {
        dist2[e[i].t]=dist2[x]+e[i].c;
        return true;
    }
    return false;
}

inline void spfa()
{
    inque.reset();
    for(int i=1;i&lt;=n;i++)
        dist1[i]=dist2[i]=inf;
    dist1[1]=0;
    inque.set(1);
    int h=0,t=1;
    q[1]=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        inque.reset(x);

        for(int i=g[x];i;i=e[i].next)
            if(update(x,i)&amp;&amp;!inque.test(e[i].t))
            {
                t=t%n+1;
                q[t]=e[i].t;
                inque.set(e[i].t);
            }
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
        add_edge(y,x,z);
    }

    spfa();

    printf("%d\n",dist2[n]);

    return 0;
}
<pre><h2>Problem1729</h2><pre>    #include&lt;cstdio&gt;
    #include&lt;cstring&gt;

    using namespace std;

    int n,k,s;
    int a[500010],b[500010];
    int next[500010],ans[500010];
    int tr1[10010],tr2[10010];

    inline int lowbit(int x)
    {
        return x&amp;-x;
    }

    inline void add1(int x)
    {
        for(;x&lt;=s;x+=lowbit(x))
            tr1[x]++;
    }
    inline void add2(int x)
    {
        for(;x&lt;=s;x+=lowbit(x))
            tr2[x]++;
    }

    inline void dec1(int x)
    {
        for(;x&lt;=s;x+=lowbit(x))
            tr1[x]--;
    }
    inline void dec2(int x)
    {
        for(;x&lt;=s;x+=lowbit(x))
            tr2[x]--;
    }

    inline int query1(int x)
    {
        int temp=0;
        for(;x;x-=lowbit(x))
            temp+=tr1[x];
        return temp;
    }
    inline int query2(int x)
    {
        int temp=0;
        for(;x;x-=lowbit(x))
            temp+=tr2[x];
        return temp;
    }

    inline bool same1(int x,int y)
    {
        return query1(a[x]-1)==query2(b[y]-1)&amp;&amp;query1(a[x])==query2(b[y]);
    }
    inline bool same2(int x,int y)
    {
        return query1(b[x]-1)==query2(b[y]-1)&amp;&amp;query1(b[x])==query2(b[y]);
    }

    inline void get_next()
    {
        next[1]=0;
        int j=0;
        for(int i=2;i&lt;=k;i++)
        {
            while(j!=0&amp;&amp;!same2(i,j+1))
            {
                for(int kk=j;kk&gt;next[j];kk--)
                {
                    dec2(b[kk]);
                    dec1(b[i-kk]);
                }
                j=next[j];
            }
            j++;
            next[i]=j;
            add1(b[i]);
            add2(b[j]);
        }
    }

    inline void kmp()
    {
        int j=0;
        for(int i=1;i&lt;=n;i++)
        {
            while(j!=0&amp;&amp;!same1(i,j+1))
            {
                //printf("##%d %d\n",i,j);
                //printf("###%d %d %d %d\n",query1(a[i]),query1(a[i]-1),query2(b[j+1]),query2(b[j+1]-1));
                for(int kk=j;kk&gt;next[j];kk--)
                {
                    dec2(b[kk]);
                    dec1(a[i-kk]);
                }
                j=next[j];
            }
            j++;
            add2(b[j]);

            if(j==k)
            {
                ans[++ans[0]]=i-k+1;

                for(int kk=j;kk&gt;next[j];kk--)
                {
                    dec2(b[kk]);
                    dec1(a[i-kk+1]);
                }
                j=next[j];
            }

            add1(a[i]);
        }
    }

    int main()
    {
        scanf("%d%d%d",&amp;n,&amp;k,&amp;s);

        for(int i=1;i&lt;=n;i++)scanf("%d",a+i);
        for(int i=1;i&lt;=k;i++)scanf("%d",b+i);

        get_next();

        memset(tr1,0,sizeof(tr1));
        memset(tr2,0,sizeof(tr2));

        kmp();

        for(int i=0;i&lt;=ans[0];i++)
            printf("%d\n",ans[i]);

        return 0;
    }
<pre><h2>Problem1739</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;
int f[40010];

struct size
{
    int h,a,c;
}b[410];

inline bool cmp(size a,size b)
{
    return a.a&lt;b.a;
}

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
        scanf("%d%d%d",&amp;b[i].h,&amp;b[i].a,&amp;b[i].c);
    sort(b+1,b+n+1,cmp);

    f[0]=1;
    for(int i=1;i&lt;=n;i++)
    {
        for(int p=1;b[i].c;p&lt;&lt;=1)
        {
            if(b[i].c&lt;p)p=b[i].c;
            b[i].c-=p;
            for(int j=b[i].a;j&gt;=b[i].h*p;j--)
                if(f[j-b[i].h*p])
                    f[j]=1;
        }
    }

    for(int i=40000;i&gt;=0;i--)
        if(f[i])
        {
            printf("%d\n",i);
            break;
        }

    return 0;
}
<pre><h2>Problem1741</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,k;
int mat[510];
bitset&lt;510&gt;v;
int a[510][510];

inline bool find(int x)
{
    for(int i=1;i&lt;=n;i++)
        if(a[x][i]&amp;&amp;!v.test(i))
        {
            v.set(i);
            if(!mat[i])
            {
                mat[i]=x;
                return true;
            }
            else
                if(find(mat[i]))
                {
                    mat[i]=x;
                    return true;
                }
        }
    return false;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;k);
    for(int i=1;i&lt;=k;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        a[x][y]=1;
    }

    int ans=0;
    for(int i=1;i&lt;=n;i++)
    {
        v.reset();
        if(find(i))ans++;
    }

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1752</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

struct size
{
    int t,c;

    size(int A,int B):t(A),c(B){};
    friend bool operator&lt;(const size&amp;a,const size&amp;b){return a.c&gt;b.c;}
};

struct edg
{
    int t,c,next;
}edge[4010];

int n,m,cnt;
int g[1010],v[1010],dist[1010];
priority_queue&lt;size&gt;q;

inline void add_edge(int x,int y,int z)
{
    edge[++cnt].t=y;
    edge[cnt].c=z;
    edge[cnt].next=g[x];
    g[x]=cnt;
}

inline void dijkstra()
{
    memset(v,0,sizeof(v));
    for(int i=1;i&lt;=n;i++)
        dist[i]=inf;
    while(!q.empty())q.pop();

    q.push(size(1,0));
    dist[1]=0;

    while(!q.empty())
    {
        int x=q.top().t;
        q.pop();

        if(x==n)return;
        if(v[x])continue;

        for(int i=g[x];i;i=edge[i].next)
        {
            int t=edge[i].t;
            int c=edge[i].c;
            if(dist[x]+c&lt;dist[t])
            {
                dist[t]=dist[x]+c;
                q.push(size(t,dist[t]));
            }
        }
        v[x]=1;
    }
}

int main()
{
    scanf("%d%d",&amp;m,&amp;n);
    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
        add_edge(y,x,z);
    }

    dijkstra();

    printf("%d\n",dist[n]);

    return 0;
}
<pre><h2>Problem1752</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;

struct size
{
    int t,c;

    size(int A,int B):t(A),c(B){};
    friend bool operator&lt;(const size&amp;a,const size&amp;b){return a.c&gt;b.c;}
};

struct edg
{
    int t,c,next;
}edge[4010];

int n,m,cnt;
int g[1010],v[1010],dist[1010];
priority_queue&lt;size&gt;q;

inline void add_edge(int x,int y,int z)
{
    edge[++cnt].t=y;
    edge[cnt].c=z;
    edge[cnt].next=g[x];
    g[x]=cnt;
}

inline void dijkstra()
{
    memset(v,0,sizeof(v));
    for(int i=1;i&lt;=n;i++)
        dist[i]=inf;
    while(!q.empty())q.pop();

    q.push(size(1,0));
    dist[1]=0;

    while(!q.empty())
    {
        int x=q.top().t;
        q.pop();

        if(x==n)return;
        if(v[x])continue;

        for(int i=g[x];i;i=edge[i].next)
        {
            int t=edge[i].t;
            int c=edge[i].c;
            if(dist[x]+c&lt;dist[t]&amp;&amp;!v[t])
            {
                dist[t]=dist[x]+c;
                q.push(size(t,dist[t]));
            }
        }
        v[x]=1;
    }
}

int main()
{
    scanf("%d%d",&amp;m,&amp;n);
    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
        add_edge(y,x,z);
    }

    dijkstra();

    printf("%d\n",dist[n]);

    return 0;
}
<pre><h2>Problem1754</h2><pre>a,b=input(),input()
print a*b<pre><h2>Problem1756</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,q;

inline void swap(int&amp;a,int&amp;b)
{
	a^=b^=a^=b;
}
inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

struct seg_tree
{
	int l,r,lm,rm,ans,sum;
	
	inline friend seg_tree operator+(const seg_tree&amp;a,const seg_tree&amp;b)
	{
		seg_tree p;
		p.l=a.l;p.r=b.r;
		p.sum=a.sum+b.sum;
		p.lm=max(a.lm,a.sum+b.lm);
		p.rm=max(b.rm,a.rm+b.sum);
		p.ans=max(max(a.ans,b.ans),a.rm+b.lm);
		return p;
	}
}seg[2000000];

inline void build(int p,int l,int r)
{
	if(l==r)
	{
		int x;
		scanf("%d",&amp;x);
		seg[p].l=l;
		seg[p].r=r;
		seg[p].sum=x;
		seg[p].lm=x;
		seg[p].rm=x;
		seg[p].ans=x;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(p&lt;&lt;1,l,mid);
	build(p&lt;&lt;1|1,mid+1,r);
	seg[p]=seg[p&lt;&lt;1]+seg[p&lt;&lt;1|1];
}
inline void update(int p,int pos,int val)
{
	if(seg[p].l==seg[p].r)
	{
		seg[p].sum=val;
		seg[p].lm=val;
		seg[p].rm=val;
		seg[p].ans=val;
		return;
	}
	int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
	if(pos&lt;=mid)
		update(p&lt;&lt;1,pos,val);
	else
		update(p&lt;&lt;1|1,pos,val);
	seg[p]=seg[p&lt;&lt;1]+seg[p&lt;&lt;1|1];
}
inline seg_tree query(int p,int l,int r)
{
	if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p];
	int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
	if(r&lt;=mid)
		return query(p&lt;&lt;1,l,r);
	else
		if(l&gt;mid)
			return query(p&lt;&lt;1|1,l,r);
		else
			return query(p&lt;&lt;1,l,mid)+query(p&lt;&lt;1|1,mid+1,r);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;q);
	build(1,1,n);
	
	for(;q;q--)
	{
		int x,y,z;
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		if(x==1)if(y&gt;z)swap(y,z);
		if(x==1)
			printf("%d\n",query(1,y,z).ans);
		else
			update(1,y,z);
	}
	
	return 0;
}<pre><h2>Problem1758</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,cnt,sum,root,L,U,N,tot;
int g[100010],siz[100010],f[100010];
int v[100010],rt[100010],pos[100010];
double ans;
bool flag;
struct edge
{
    int t,c,next;
}e[200010];
struct seg_tree
{
    int l,r,tag;
    double v;
}seg[400010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}
inline double Max(const double&amp;a,const double&amp;b)
{
    return a&gt;b?a:b;
}

inline void Build(int p,int l,int r)
{
    seg[p].l=l;
    seg[p].r=r;
    seg[p].v=-100000000.0;
    if(l==r)
    {
        pos[l]=p;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    Build(p&lt;&lt;1,l,mid);
    Build(p&lt;&lt;1|1,mid+1,r);
}
inline void build(int p)
{
    if(seg[p].v==-100000000.0)return;
    seg[p].v=-100000000.0;
    if(seg[p].l==seg[p].r)return;
    build(p&lt;&lt;1);
    build(p&lt;&lt;1|1);
}
inline double query(int p,int l,int r)
{
    if(seg[p].v==-100000000.0)return -100000000.0;
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p].v;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        return query(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            return query(p&lt;&lt;1|1,l,r);
        else
            return Max(query(p&lt;&lt;1,l,mid),query(p&lt;&lt;1|1,mid+1,r));
}
inline void modify(int P,double val)
{
    int p=pos[P];
    while(val&gt;seg[p].v&amp;&amp;p)
    {
        seg[p].v=val;
        p&gt;&gt;=1;
    }
}

inline void get_root(int x,int fa)
{
    siz[x]=1;f[x]=0;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
        {
            get_root(e[i].t,x);
            siz[x]+=siz[e[i].t];
            f[x]=Max(f[x],siz[e[i].t]);
        }
    f[x]=Max(f[x],sum-siz[x]);
    if(f[x]&lt;f[root])root=x;
}
inline void dfs(int x,int fa)
{
    tot++;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs(e[i].t,x);
}
inline void work1(int x)
{
    rt[++N]=x;
    v[x]=1;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            tot=0;
            dfs(e[i].t,x);
            root=0;sum=tot;
            get_root(e[i].t,0);
            work1(root);
        }
}

inline void dfs1(int x,double y,int z,int fa)
{
    if(L&lt;=z&amp;&amp;z&lt;=U)if(y&gt;0.0)
    {flag=true;return;}
    if(z&gt;=U)return;
    int l=L-z,r=U-z;l=Max(l,1);
    if(query(1,l,r)+y&gt;0.0)
    {flag=true;return;}

    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs1(e[i].t,y+e[i].c-ans,z+1,x);
}
inline void add(int x,double y,int z,int fa)
{
    if(z&gt;=U)return;
    modify(z,y);

    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            add(e[i].t,y+e[i].c-ans,z+1,x);
}
inline void calc(int x)
{
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            dfs1(e[i].t,(double)e[i].c-ans,1,x);
            if(flag)return;
            add(e[i].t,(double)e[i].c-ans,1,x);
        }
}

int main()
{
    n=read();
    L=read();U=read();
    int ma=0,mi=1000000;
    for(int i=1;i&lt;n;i++)
    {
        int x=read(),y,z;y=read();z=read();
        add_edge(x,y,z);
        add_edge(y,x,z);
        ma=Max(ma,z);
        mi=Min(mi,z);
    }
    f[0]=n;sum=n;ans=n;
    get_root(1,0);
    work1(root);
    Build(1,1,U-1);

    double l=(double)mi,r=(double)ma;
    while((int)(l*1000+0.5)!=(int)(r*1000+0.5))
    {
        double mid=(double)(l+r)/2.0;
        ans=mid;

        memset(v,0,sizeof(v));

        flag=false;
        for(int i=1;i&lt;=n;i++)
        {
            build(1);
            v[rt[i]]=1;
            calc(rt[i]);
            if(flag)break;
        }
        if(flag)l=mid;else r=mid;
    }

    printf("%.3lf\n",l);

    return 0;
}
<pre><h2>Problem1782</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt,num;
int g[100010],s[100010],t[100010];
int tr[200010];

struct edge
{
    int t,next;
}e[200010];

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void dfs(int x)
{
    s[x]=++num;
    for(int i=g[x];i;i=e[i].next)
        if(!s[e[i].t])
            dfs(e[i].t);
    t[x]=++num;
}

inline int lowbit(int x)
{
    return x&amp;-x;
}
inline void update(int x,int val)
{
    for(;x&lt;=num;x+=lowbit(x))
        tr[x]+=val;
}
inline int query(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp+=tr[x];
    return temp;
}

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;n;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(x,y);
        add_edge(y,x);
    }

    dfs(1);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        printf("%d\n",query(s[x]));
        update(s[x],1);
        update(t[x],-1);
    }

    return 0;
}
<pre><h2>Problem1787</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,q,cnt;
int g[500010];
int dep[500010];
int fa[500010][20];

struct edge
{
	int t,next;
}e[1000010];

inline int abs(int x)
{
	return x&lt;0?-x:x;
}
inline void swap(int&amp;x,int&amp;y)
{
	x^=y^=x^=y;
}

inline void add_edge(int x,int y)
{
	e[++cnt].t=y;
	e[cnt].next=g[x];
	g[x]=cnt;
}

inline void dfs(int x)
{
	for(int i=1;i&lt;20;i++)
		fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=g[x];i;i=e[i].next)
		if(!fa[e[i].t][0])
		{
			dep[e[i].t]=dep[x]+1;
			fa[e[i].t][0]=x;
			dfs(e[i].t);
		}
}

inline void swim(int&amp;x,int h)
{
	for(int i=0;h;i++)
	{
		if(h&amp;1)x=fa[x][i];
		h&gt;&gt;=1;
	}
}
inline int lca(int x,int y)
{
	if(dep[x]&lt;dep[y])swap(x,y);
	swim(x,dep[x]-dep[y]);
	
	while(x!=y)
	{
		int i;
		for(i=0;fa[x][i]!=fa[y][i];i++);
		if(i==0)return fa[x][0];
		x=fa[x][i-1];
		y=fa[y][i-1];
	}
	return x;
}

inline int dis(int x,int y)
{
	int t=lca(x,y);
	return dep[x]+dep[y]-(dep[t]&lt;&lt;1);
}
inline void calc(int x,int y,int z)
{
	int p1=lca(x,y),p2=lca(x,z),p3=lca(y,z),t;
	if(p1==p2)
		t=p3;
	else 
		if(p2==p3)
			t=p1;
		else
			t=p2;
	printf("%d %d\n",t,dis(x,t)+dis(y,t)+dis(z,t));
}

int main()
{
	scanf("%d%d",&amp;n,&amp;q);
	for(int i=1;i&lt;n;i++)
	{
		int x,y;
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(x,y);
		add_edge(y,x);
	}
	fa[1][0]=1;
	dfs(1);
	
	for(;q;q--)
	{
		int x,y,z;
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		calc(x,y,z);
	}
	
	return 0;
}<pre><h2>Problem1797</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,S,T,cnt;
int g[4010];
int idx,num,h;
int dfn[4010],low[4010],bel[4010],stack[4010],instack[4010];
int vh[4010],di[4010],dis[4010],his[4010],pre[4010];

struct size
{
    int t,c,next;
}e[150000];

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int rev(int x)
{
    return x&amp;1?x+1:x-1;
}

inline void isap()
{
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)di[i]=g[i];
    int i=S,aug=inf;

    while(dis[S]&lt;n)
    {
        bool flag=false;
        his[i]=aug;
        for(int p=di[i];p;p=e[p].next)
            if(e[p].c&amp;&amp;dis[e[p].t]+1==dis[i])
            {
                flag=true;
                aug=min(aug,e[p].c);
                di[i]=p;
                pre[e[p].t]=rev(p);
                i=e[p].t;

                if(i==T)
                {
                    while(i!=S)
                    {
                        e[pre[i]].c+=aug;
                        e[rev(pre[i])].c-=aug;
                        i=e[pre[i]].t;
                    }
                    aug=inf;
                }
                break;
            }
        if(flag)continue;

        vh[dis[i]]--;
        if(!vh[dis[i]])break;

        int mi=n,mii=0;
        for(int p=g[i];p;p=e[p].next)
            if(e[p].c&amp;&amp;dis[e[p].t]&lt;mi)
            {
                mi=dis[e[p].t];
                mii=p;
            }
        dis[i]=mi+1;
        di[i]=mii;
        vh[dis[i]]++;

        if(i!=S)
        {
            i=e[pre[i]].t;
            aug=his[i];
        }
    }
}

inline void tarjan_dcc(int x)
{
    dfn[x]=low[x]=++idx;
    stack[++h]=x;
    instack[x]=1;

    for(int i=g[x];i;i=e[i].next)
        if(e[i].c)
        {
            if(!dfn[e[i].t])
            {
                tarjan_dcc(e[i].t);
                low[x]=min(low[x],low[e[i].t]);
            }
            else
                if(instack[e[i].t])
                    low[x]=min(low[x],dfn[e[i].t]);
        }

    if(dfn[x]==low[x])
    {
        ++num;
        while(stack[h]!=x)
        {
            instack[stack[h]]=0;
            bel[stack[h--]]=num;
        }
        instack[stack[h]]=0;
        bel[stack[h--]]=num;
    }
}

int main()
{
    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
        add_edge(y,x,0);
    }

    isap();

    for(int i=1;i&lt;=n;i++)
        if(!dfn[i])
            tarjan_dcc(i);

    for(int i=1;i&lt;=m;i++)
    {
        if(e[(i&lt;&lt;1)-1].c!=0)
            printf("0 0\n");
        else
        {
            int x=e[i&lt;&lt;1].t,y=e[(i&lt;&lt;1)-1].t;
            printf("%d %d\n",bel[x]!=bel[y],bel[x]==bel[S]&amp;&amp;bel[y]==bel[T]);
        }
    }

    return 0;
}
<pre><h2>Problem1798</h2><pre>#include&lt;cstdio&gt;
	
using namespace std;

long long n,m,mo;

struct size
{
	long long l,r,sum,a,b;
	size *left,*right;
}*root;

size *build(long long l,long long r)
{
	size *x=new size;
	x-&gt;l=l,x-&gt;r=r;
	x-&gt;a=1,x-&gt;b=0;
	
	if(l!=r)
	{
		long long mid=(l+r)/2;
		x-&gt;left=build(l,mid);
		x-&gt;right=build(mid+1,r);
		x-&gt;sum=(x-&gt;left-&gt;sum+x-&gt;right-&gt;sum)%mo;
	}
	else
		x-&gt;left=NULL,x-&gt;right=NULL,scanf("%lld",&amp;x-&gt;sum);
	
	x-&gt;sum%=mo;
	
	return x;
}

inline void update(size *x)
{
	if(x-&gt;left!=NULL)
	{
		x-&gt;left-&gt;a=x-&gt;left-&gt;a*x-&gt;a%mo;
		x-&gt;left-&gt;b=(x-&gt;left-&gt;b*x-&gt;a%mo+x-&gt;b)%mo;
		x-&gt;left-&gt;sum=(x-&gt;left-&gt;sum*x-&gt;a%mo+x-&gt;b*(x-&gt;left-&gt;r-x-&gt;left-&gt;l+1)%mo)%mo;
	}
	
	if(x-&gt;right!=NULL)
	{
		x-&gt;right-&gt;a=x-&gt;right-&gt;a*x-&gt;a%mo;
		x-&gt;right-&gt;b=(x-&gt;right-&gt;b*x-&gt;a%mo+x-&gt;b)%mo;
		x-&gt;right-&gt;sum=(x-&gt;right-&gt;sum*x-&gt;a%mo+x-&gt;b*(x-&gt;right-&gt;r-x-&gt;right-&gt;l+1)%mo)%mo;
	}
	
	x-&gt;a=1,x-&gt;b=0;
}

void alter(size *x,long long l,long long r,long long a,long long b)
{
	if(l&lt;=x-&gt;l&amp;&amp;x-&gt;r&lt;=r)
	{
		x-&gt;a=x-&gt;a*a%mo;
		x-&gt;b=(x-&gt;b*a+b)%mo;
		x-&gt;sum=(x-&gt;sum*a+b*(x-&gt;r-x-&gt;l+1)%mo)%mo;
		return;	
	}
	
	update(x);
	long long mid=(x-&gt;l+x-&gt;r)/2;
	
	if(l&lt;=mid)alter(x-&gt;left,l,r,a,b);
	
	if(r&gt;mid)alter(x-&gt;right,l,r,a,b);
	
	x-&gt;sum=(x-&gt;left-&gt;sum+x-&gt;right-&gt;sum)%mo;
}

long long query(size *x,long long l,long long r)
{
	
	if(l&lt;=x-&gt;l&amp;&amp;x-&gt;r&lt;=r)return x-&gt;sum%mo;
	
	update(x);
	long long mid=(x-&gt;l+x-&gt;r)/2;
	
	if(r&lt;=mid)
		return query(x-&gt;left,l,r)%mo;
	else
		if(l&gt;mid)
			return query(x-&gt;right,l,r)%mo;
		else
			return (query(x-&gt;left,l,mid)+query(x-&gt;right,mid+1,r))%mo;
}

int main()
{
	scanf("%lld%lld",&amp;n,&amp;mo);
	
	root=build(1,n);
	
	scanf("%lld",&amp;m);
	
	for(;m;m--)
	{
		long long p,l,r,num;
		
		scanf("%lld%lld%lld",&amp;p,&amp;l,&amp;r);
		
		if(p==1)
		{
			scanf("%lld",&amp;num);
			alter(root,l,r,num,0);
		}
		else
			if(p==2)
			{
				scanf("%lld",&amp;num);
				alter(root,l,r,1,num);
			}
			else
				printf("%lld\n",query(root,l,r)%mo);
	}
	
	return 0;
}<pre><h2>Problem1800</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,a[100],sum,sum1,h=1,ans;

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",a+i);
		sum+=a[i];
	}
	
	for(int i=1;i&lt;n;i++)
	{
		sum1+=a[i];
		while(sum1*2&gt;sum)sum1-=a[h++];
		if(sum1*2==sum)ans++;
	}
	
	printf("%d\n",ans*(ans-1)/2);
	
	return 0;
}<pre><h2>Problem1811</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,l,r,last,nl,nr;
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
int main()
{
    n=read();
    l=read();r=read();last=r;nl=l;nr=r;
    for(int i=3;i&lt;=n;i++)
    {
        int x=read();
        if(i&amp;1)
        {
            nl=nr-x+last;
            if(nl&gt;l)l=nl;
        }
        else
        {
            nr=nl+x-last;
            if(nr&lt;r)r=nr;
        }
        last=x;
    }
    printf("%d\n",r-l+1&gt;=0?r-l+1:0);
    return 0;
}
<pre><h2>Problem1816</h2><pre>#include&lt;stdio.h&gt;

#define inf 2000000000;

int n,a[55],ans=0;
int i;

int main(void)
{
	scanf("%d",&amp;n);
	
	for(i=0;i&lt;=n;i++)
		scanf("%d",a+i);
	
	int l=0,r=inf;
	
	while(l&lt;=r)
	{
		int mid=(l+r)/2,temp=0;
		
		for(i=0;i&lt;=n;i++)
		{
			temp+=a[i]&lt;mid?mid-a[i]:0;
			if(temp&gt;mid)break;
		}
		
		if(temp&lt;=mid)
			ans=mid,l=mid+1;
		else
			r=mid-1;
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1820</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int INF=2139062143;

int n;
int d[210][210];
int f[210][210],g[210][210];

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            d[i][j]=read();

    int x=read(),t=1,last;last=x;
    memset(f,127,sizeof(f));
    f[2][3]=d[1][x];
    f[1][3]=d[2][x];
    f[1][2]=d[3][x];
    while(scanf("%d",&amp;x)!=EOF)
    {
        if(t==1)
        {
            memset(g,127,sizeof(g));
            for(int i=1;i&lt;n;i++)
                for(int j=i+1;j&lt;=n;j++)
                    if(f[i][j]!=INF)
                    {
                        int a,b;
                        g[i][j]=Min(g[i][j],f[i][j]+d[last][x]);
                        a=Min(last,j);b=Max(last,j);
                        g[a][b]=Min(g[a][b],f[i][j]+d[i][x]);
                        a=Min(last,i);b=Max(last,i);
                        g[a][b]=Min(g[a][b],f[i][j]+d[j][x]);
                    }
        }
        else
        {
            memset(f,127,sizeof(f));
            for(int i=1;i&lt;n;i++)
                for(int j=i+1;j&lt;=n;j++)
                    if(g[i][j]!=INF)
                    {
                        int a,b;
                        f[i][j]=Min(f[i][j],g[i][j]+d[last][x]);
                        a=Min(last,j);b=Max(last,j);
                        f[a][b]=Min(f[a][b],g[i][j]+d[i][x]);
                        a=Min(last,i);b=Max(last,i);
                        f[a][b]=Min(f[a][b],g[i][j]+d[j][x]);
                    }
        }
        t^=1;
        last=x;
    }

    int ans=INF;
    if(t==1)
        for(int i=1;i&lt;n;i++)
            for(int j=i+1;j&lt;=n;j++)
                ans=Min(ans,f[i][j]);
    else
        for(int i=1;i&lt;n;i++)
            for(int j=i+1;j&lt;=n;j++)
                ans=Min(ans,g[i][j]);
    printf("%d\n",ans);

    return 0;
}<pre><h2>Problem1821</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;

using namespace std;

int n,k,tot;
int x[1010],y[1010],fa[1000];

struct size
{
	int x,y,c;
}edge[500010];

inline bool cmp(size a,size b)
{
	return a.c&lt;b.c;
}

int find(int x)
{
	return fa[x]=x==fa[x]?x:find(fa[x]);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;k);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d%d",x+i,y+i);
		fa[i]=i;
		for(int j=1;j&lt;i;j++)
		{
			edge[++tot].x=i;
			edge[tot].y=j;
			edge[tot].c=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
		}
	}
	
	sort(edge+1,edge+tot+1,cmp);
	
	for(int i=1;i&lt;=tot;i++)
		if(find(edge[i].x)!=find(edge[i].y))
		{
			n--;
			if(n&lt;k)
			{
				n=i;
				break;
			}
			fa[find(edge[i].x)]=fa[find(edge[i].y)];
		}
	
	printf("%.2lf\n",sqrt(edge[n].c));
	
	return 0;
}<pre><h2>Problem1822</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;

using namespace std;

const int inf=1000000000;

int n,m,kk,siz=-1;
int ch[610];
int vh[610],dis[610],pre[610],di[610],his[610];

vector&lt;int&gt; g[610];

struct lich
{
    int x,y,r,t;
}a[610];

struct fairy
{
    int x,y;
}b[610];

struct tree
{
    int x,y,r;
}c[610];

struct size
{
    int t,c;
}edge[100000];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    edge[++siz].t=y;
    edge[siz].c=z;
    ch[x]++;
    g[x].push_back(siz);

    edge[++siz].t=x;
    edge[siz].c=0;
    ch[y]++;
    g[y].push_back(siz);
}

inline int isap()
{
    memset(vh,0,sizeof(vh));
    memset(dis,0,sizeof(dis));
    memset(di,0,sizeof(di));
    vh[0]=n;
    int flow=0,aug=inf,i=1;

    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[i]=aug;

        for(int x=di[i];x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]+1==dis[i])
            {
                di[i]=x;
                aug=min(aug,edge[g[i][x]].c);
                flag=true;
                pre[edge[g[i][x]].t]=g[i][x]^1;
                i=edge[g[i][x]].t;

                if(i==n)
                {
                    flow+=aug;

                    while(i!=1)
                    {
                        edge[pre[i]].c+=aug;
                        edge[pre[i]^1].c-=aug;
                        i=edge[pre[i]].t;
                    }

                    aug=inf;
                }

                break;
            }

        if(flag)continue;

        int mi=n,mii;

        for(int x=0;x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]&lt;mi)
                mi=dis[edge[g[i][x]].t],mii=x;

        vh[dis[i]]--;
        if(vh[dis[i]]==0)break;

        dis[i]=mi+1;
        vh[dis[i]]++;
        di[i]=mii;

        if(i!=1)
        {
            i=edge[pre[i]].t;
            aug=his[i];
        }
    }

    return flow;
}

inline bool calc(int x,int y,int z)
{
    double aa=(double)sqrt((a[x].x-b[y].x)*(a[x].x-b[y].x)+(a[x].y-b[y].y)*(a[x].y-b[y].y));
    double bb=(double)sqrt((a[x].x-c[z].x)*(a[x].x-c[z].x)+(a[x].y-c[z].y)*(a[x].y-c[z].y));
    double cc=(double)sqrt((b[y].x-c[z].x)*(b[y].x-c[z].x)+(b[y].y-c[z].y)*(b[y].y-c[z].y));
    double p=(double)(aa+bb+cc)/2;
    double S1=(double)sqrt(p*(p-aa)*(p-bb)*(p-cc));
    double S2=(double)aa*c[z].r/2;
    return S1&gt;=S2;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;kk);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].r,&amp;a[i].t);
        add_edge(1,i+1,0);
    }

    for(int i=1;i&lt;=m;i++)
    {
        scanf("%d%d",&amp;b[i].x,&amp;b[i].y);
        add_edge(i+1+n,n+m+2,1);
    }

    for(int i=1;i&lt;=kk;i++)
        scanf("%d%d%d",&amp;c[i].x,&amp;c[i].y,&amp;c[i].r);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            if((b[j].x-a[i].x)*(b[j].x-a[i].x)+(b[j].y-a[i].y)*(b[j].y-a[i].y)&lt;=a[i].r*a[i].r)
            {
                bool bo=true;
                for(int k=1;k&lt;=kk;k++)
                    if(!calc(i,j,k))
                    {
                        bo=false;
                        break;
                    }
                if(bo)add_edge(1+i,1+n+j,1);
            }
        }

    int l=0,r=4000010;
    n=n+m+2;
    while(l!=r)
    {
        int mid=(l+r)&gt;&gt;1;

        for(int i=0;i&lt;siz;i+=2)
        {
            edge[i].c+=edge[i|1].c;
            edge[i|1].c=0;
        }

        for(int i=0;i&lt;ch[1];i++)
            edge[g[1][i]].c=(int)(mid/a[edge[g[1][i]].t-1].t)+1;
        if(isap()==m)
            r=mid;
        else
            l=mid+1;
    }

    printf("%d\n",l==4000010?-1:l);

    return 0;
}
/*
2 3 1
-100 0 100 3
100 0 100 5
-100 -10
100 10
110 11
5 5 10

2 3 1
-100 0 100 3
100 0 100 6
-100 -10
100 10
110 11
5 5 10
*/
<pre><h2>Problem1823</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;

using namespace std;

int t,n,m,idex,cnt;
int dfn[210],low[210],belong[210],stack[210];
bool instack[210];
char c1,c2;

struct size
{
	int ch;
	size *next;
}*g[210];

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=g[x];
	g[x]=p;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

void tarjan(int x)
{
	dfn[x]=low[x]=++idex;
	instack[x]=true;
	stack[++stack[0]]=x;
	
	for(size *p=g[x];p!=NULL;p=p-&gt;next)
		if(!dfn[p-&gt;ch])
		{
			tarjan(p-&gt;ch);
			low[x]=min(low[x],low[p-&gt;ch]);
		}
		else
			if(instack[p-&gt;ch])
				low[x]=min(low[x],dfn[p-&gt;ch]);
	
	if(low[x]==dfn[x])
	{
		cnt++;
		while(stack[stack[0]+1]!=x)
		{
			belong[stack[stack[0]]]=cnt;
			instack[stack[stack[0]--]]=false;
		}
	}
}

int main()
{
	scanf("%d",&amp;t);
	
	for(;t;t--)
	{
		scanf("%d%d\n",&amp;n,&amp;m);
		
		idex=0;
		memset(dfn,0,sizeof(dfn));
		memset(low,0,sizeof(low));
		for(int i=1;i&lt;=n*2;i++)g[i]=NULL;
		
		for(int i=1;i&lt;=m;i++)
		{
			int x1,x2,y1,y2;
			
			cin&gt;&gt;c1&gt;&gt;x1&gt;&gt;c2&gt;&gt;x2;
			
			if(c1=='h')x1+=n;
			if(c2=='h')x2+=n;
			
			if(c1=='m')
				y1=x1+n;
			else
				y1=x1-n;
			if(c2=='m')
				y2=x2+n;
			else
				y2=x2-n;
			
			add_edge(y1,x2);
			add_edge(y2,x1);
		}
		
		for(int i=1;i&lt;=n*2;i++)
			if(!dfn[i])
				tarjan(i);
		
		bool flag=true;
		for(int i=1;i&lt;=n;i++)
			if(belong[i]==belong[i+n])
			{
				flag=false;
				break;
			}
		
		if(flag)
			printf("GOOD\n");
		else
			printf("BAD\n");
	}
	
	return 0;
}<pre><h2>Problem1826</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;set&gt;

using namespace std;

int n,k,ans=0,num=0,cnt=0;
int data[100010],nxt[100010];
set&lt;int&gt; s;
map&lt;int,int&gt; m;

inline void ins(int x)
{
    if(x==n+1)
    {
        cnt++;
        if(cnt&gt;1)return;
    }
    s.insert(x);
}

int main()
{
    scanf("%d%d",&amp;n,&amp;k);

    for(int i=1;i&lt;=n;i++)scanf("%d",data+i),m[data[i]]=0;

    for(int i=n;i&gt;=1;i--)
    {
        nxt[i]=m[data[i]]==0?n+1:m[data[i]];
        m[data[i]]=i;
    }

    s.clear();

    for(int i=1;i&lt;=n;i++)
        if(s.find(i)!=s.end())
        {
            s.erase(i);
            ins(nxt[i]);
        }
        else
        {
            ans++;

            if(num&lt;k)
                num++;
            else
            {
                set&lt;int&gt;::iterator it=s.end();

                if(*--it==n+1)
                {
                    cnt--;
                    if(cnt==0)s.erase(it);
                }
                else
                    s.erase(it);
            }
            ins(nxt[i]);
        }

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem1827</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt,sum;
int g[100010],c[100010];
long long ans;
struct edge
{
    int t,c,next;
}e[200010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline long long get_ans(int x,int fa)
{
    long long temp=0;
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa)
        {
            temp+=get_ans(e[i].t,x);
            temp+=(long long)c[e[i].t]*e[i].c;
            c[x]+=c[e[i].t];
        }
    return temp;
}
inline void dfs(int x,int fa)
{
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa&amp;&amp;(c[e[i].t]&lt;&lt;1)&gt;sum)
        {
            ans+=(long long)(sum-(c[e[i].t]&lt;&lt;1))*e[i].c;
            dfs(e[i].t,x);
            return;
        }
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
    {
        c[i]=read();
        sum+=c[i];
    }
    for(int i=1;i&lt;n;i++)
    {
        int x,y,z;
        x=read();y=read();z=read();
        add_edge(x,y,z);add_edge(y,x,z);
    }

    ans=get_ans(1,0);
    dfs(1,0);
    printf("%lld\n",ans);

    return 0;
}
<pre><h2>Problem1834</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1e9;

int n,m,kk,size=-1,ans=0;
int vh[1010],dis[1010],his[1010],pre[1010];
int que[1010],dist[1010],flow[1010];

bitset&lt;1010&gt; inque;

struct size
{
	int y,c,fe;
}edge[25010];

struct size1
{
	int num;
	size1 *next;
}*g[1010],*di[1010];

struct size2
{
	int x,y,fe;
}temp[5010];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z,int num)
{
	edge[++size].y=y;
	edge[size].c=z;
	edge[size].fe=num;
	
	size1 *p=new size1;
	p-&gt;num=size;
	p-&gt;next=g[x];
	g[x]=p;
	
	edge[++size].y=x;
	edge[size].c=0;
	edge[size].fe=-num;
	
	p=new size1;
	p-&gt;num=size;
	p-&gt;next=g[y];
	g[y]=p;
}

inline int isap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)di[i]=g[i];
	int i=1,aug=inf,flow=0;
	
	while(dis[1]&lt;n)
	{
		his[i]=aug;
		bool flag=false;
		
		for(size1 *p=di[i];p;p=p-&gt;next)
			if(edge[p-&gt;num].c&amp;&amp;dis[edge[p-&gt;num].y]+1==dis[i])
			{
				flag=true;
				di[i]=p;
				aug=min(aug,edge[p-&gt;num].c);
				pre[edge[p-&gt;num].y]=p-&gt;num^1;
				i=edge[p-&gt;num].y;
				if(i==n)
				{
					flow+=aug;
					while(i!=1)
					{
						edge[pre[i]].c+=aug;
						edge[pre[i]^1].c-=aug;
						i=edge[pre[i]].y;
					}
					aug=inf;
				}
				break;
			}
		
		if(flag)continue;
		
		int mi=n-1;
		size1 *p1;
		
		for(size1 *p=g[i];p;p=p-&gt;next)
			if(edge[p-&gt;num].c&gt;0&amp;&amp;dis[edge[p-&gt;num].y]&lt;mi)
				p1=p,mi=dis[edge[p-&gt;num].y];
		
		di[i]=p1;
		vh[dis[i]]--;
		if(vh[dis[i]]==0)break;
		
		dis[i]=mi+1;
		vh[dis[i]]++;
		if(i!=1)
		{
			i=edge[pre[i]].y;
			aug=his[i];
		}
	}
	
	return flow;
}

inline bool spfa()
{
	int h=0,t=1;
	que[1]=n+1;
	flow[n+1]=inf;
	dist[n+1]=0;
	inque.reset();
	inque.set(n+1);
	
	for(int i=1;i&lt;=n;i++)
		dist[i]=flow[i]=inf;
	
	while(h!=t)
	{
		h=h%(n+1)+1;
		int x=que[h];
		inque.flip(x);
		
		for(size1 *p=g[x];p;p=p-&gt;next)
			if(edge[p-&gt;num].c&amp;&amp;dist[x]+edge[p-&gt;num].fe&lt;dist[edge[p-&gt;num].y])
			{
				dist[edge[p-&gt;num].y]=dist[x]+edge[p-&gt;num].fe;
				pre[edge[p-&gt;num].y]=1^p-&gt;num;
				flow[edge[p-&gt;num].y]=min(flow[x],edge[p-&gt;num].c);
				
				if(!inque.test(edge[p-&gt;num].y))
				{
					inque.set(edge[p-&gt;num].y);
					t=t%(n+1)+1;
					que[t]=edge[p-&gt;num].y;
				}
			}
	}
	
	return dist[n]!=inf;
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;kk);
	
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,z,num;
		
		scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;num);
		temp[i].x=x;
		temp[i].y=y;
		temp[i].fe=num;
		
		add_edge(x,y,z,0);
	}
	
	printf("%d ",isap());
	
	for(int i=1;i&lt;=m;i++)
		add_edge(temp[i].x,temp[i].y,inf,temp[i].fe);
	add_edge(n+1,1,kk,0);
	
	while(spfa())
	{
		ans+=dist[n]*flow[n];
		
		for(int i=n;i!=n+1;i=edge[pre[i]].y)
		{
			edge[pre[i]].c+=flow[n];
			edge[pre[i]^1].c-=flow[n];
		}
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1854</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

struct size
{
	int ch;
	size *next;
}*g[1500000];

int n,x,y,ans,ma;
int bel[1500000];

bitset&lt;1500000&gt; v;

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline void add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=g[x];
	g[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;next=g[y];
	g[y]=p;
}

bool hungary(int x)
{
	for(size *p=g[x];p!=NULL;p=p-&gt;next)
		if(!v[p-&gt;ch])
		{
			v[p-&gt;ch]=1;
			if(bel[p-&gt;ch]==0||hungary(bel[p-&gt;ch]))
			{
				bel[p-&gt;ch]=x;
				return true;
			}
		}
	return false;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		
		add_edge(i,n+x);
		add_edge(i,n+y);
		ma=max(ma,max(x,y));
	}
	
	for(int i=n+1;i&lt;=n+ma;i++)
	{
		v.reset();
		if(hungary(i))
			ans++;
		else
			break;
	}
	
	printf("%d\n",ans);
	
	return 0;
}<pre><h2>Problem1864</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,fa,h;
int stack[500010],a[500010],num[500010];
int edge[500010][3];
int f[500010][3],g[500010][3];

inline int read()
{
	char c=getchar();
	return (int)(c-'0');
}

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

int main()
{
	a[n=1]=read();
	stack[1]=1;
	h=1;
	fa=1;
	if(a[1]==0)f[1][0]=g[1][0]=1;
	
	while(a[1])
	{
		a[++n]=read();
		if(!a[n])f[n][0]=g[n][0]=1;
		
		stack[++h]=n;
		
		edge[fa][++num[fa]]=n;
		
		if(a[stack[h]])
			a[fa=stack[h]]--;
		else
		{
			while(!a[stack[h]])
			{
				h--;
				if(num[stack[h]]==1)
				{
					f[stack[h]][0]=max(f[edge[stack[h]][1]][1],f[edge[stack[h]][1]][2])+1;
					f[stack[h]][1]=max(f[edge[stack[h]][1]][0],f[edge[stack[h]][1]][2]);
					f[stack[h]][2]=max(f[edge[stack[h]][1]][0],f[edge[stack[h]][1]][1]);
					
					g[stack[h]][0]=min(g[edge[stack[h]][1]][1],g[edge[stack[h]][1]][2])+1;
					g[stack[h]][1]=min(g[edge[stack[h]][1]][0],g[edge[stack[h]][1]][2]);
					g[stack[h]][2]=min(g[edge[stack[h]][1]][0],g[edge[stack[h]][1]][1]);
				}
				else
					if(num[stack[h]]==2)
					{
						f[stack[h]][0]=max(f[edge[stack[h]][1]][1]+f[edge[stack[h]][2]][2],f[edge[stack[h]][1]][2]+f[edge[stack[h]][2]][1])+1;
						f[stack[h]][1]=max(f[edge[stack[h]][1]][0]+f[edge[stack[h]][2]][2],f[edge[stack[h]][1]][2]+f[edge[stack[h]][2]][0]);
						f[stack[h]][2]=max(f[edge[stack[h]][1]][1]+f[edge[stack[h]][2]][0],f[edge[stack[h]][1]][0]+f[edge[stack[h]][2]][1]);
						
						g[stack[h]][0]=min(g[edge[stack[h]][1]][1]+g[edge[stack[h]][2]][2],g[edge[stack[h]][1]][2]+g[edge[stack[h]][2]][1])+1;
						g[stack[h]][1]=min(g[edge[stack[h]][1]][0]+g[edge[stack[h]][2]][2],g[edge[stack[h]][1]][2]+g[edge[stack[h]][2]][0]);
						g[stack[h]][2]=min(g[edge[stack[h]][1]][1]+g[edge[stack[h]][2]][0],g[edge[stack[h]][1]][0]+g[edge[stack[h]][2]][1]);
					}
			}
			
			a[fa=stack[h]]--;
		}
	}
	
		
	printf("%d %d\n",max(max(f[1][0],f[1][1]),f[1][2]),min(min(g[1][0],g[1][1]),g[1][2]));
	
	return 0;
}<pre><h2>Problem1876</h2><pre>import java.util.*;
import java.math.*;

public class Main
{
	public static void main(String[] args)
	{
		Scanner cin=new Scanner(System.in);
		
		BigInteger a=cin.nextBigInteger(),b=cin.nextBigInteger();
		
		System.out.println(a.gcd(b).toString());
		
		cin.close();
	}

}<pre><h2>Problem1877</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,cnt,S,T;
int g[510],que[510],dist[510],pre[510];
bool inque[510];

struct size
{
    int t,c,f,next;
}e[50000];

inline void add_edge(int x,int y,int z,int f)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].f=f;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].f=-f;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline bool spfa()
{
    for(int i=1;i&lt;=n;i++)dist[i]=inf;
    dist[S]=0;
    que[1]=S;
    inque[S]=true;
    int h=0,t=1;

    while(h!=t)
    {
        h=h%n+1;
        int x=que[h];
        inque[x]=false;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dist[x]+e[i].f&lt;dist[e[i].t])
        {
            dist[e[i].t]=dist[x]+e[i].f;
            pre[e[i].t]=i&amp;1?i+1:i-1;

            if(!inque[e[i].t])
            {
                t=t%n+1;
                que[t]=e[i].t;
                inque[e[i].t]=true;
            }
        }
    }

    return dist[T]!=inf;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
        add_edge(i*2-1,i*2,1,0);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x*2,y*2-1,1,z);
    }
    S=2;
    T=n*2-1;
    n&lt;&lt;=1;

    int flow=0,F=0;

    while(spfa())
    {
        flow++;
        F+=dist[T];

        for(int i=T;i!=S;i=e[pre[i]].t)
        {
            e[pre[i]].c++;
            e[pre[i]&amp;1?pre[i]+1:pre[i]-1].c--;
        }
    }

    printf("%d %d\n",flow,F);

    return 0;
}
<pre><h2>Problem1878</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,s[1000010],tr[100010],a[100010];

struct size
{
	int l,r,p,ans;
}q[200010];

inline bool cmp1(size a,size b)
{
	return a.r&lt;b.r;
}

inline bool cmp2(size a,size b)
{
	return a.p&lt;b.p;
}

inline int lowbit(int x)
{
	return x&amp;-x;
}

inline void add(int pl)
{
	for(;pl&lt;=n;pl+=lowbit(pl))tr[pl]++;
}

inline void dec(int pl)
{
	for(;pl&lt;=n;pl+=lowbit(pl))tr[pl]--;
}

inline int query(int pl)
{
	int ans=0;
	for(;pl;pl-=lowbit(pl))ans+=tr[pl];
	return ans;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)scanf("%d",a+i);
	
	scanf("%d",&amp;m);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;q[i].l,&amp;q[i].r);
		q[i].p=i;
	}
	
	sort(q+1,q+m+1,cmp1);
	
	int pp=0;
	
	for(int i=1;i&lt;=m;i++)
	{
		while(pp&lt;q[i].r)
		{
			add(++pp);
			if(s[a[pp]])dec(s[a[pp]]);
			s[a[pp]]=pp;
		}
		q[i].ans=query(q[i].r)-query(q[i].l-1);
	}
	
	sort(q+1,q+m+1,cmp2);
	
	for(int i=1;i&lt;=m;i++)printf("%d\n",q[i].ans);
	
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;

using namespace std;

int n,k,t,x,y;
int a[10010],b[10010];

char c;

inline void swap(int &amp;x,int &amp;y)
{
	int temp=x;
	x=y,y=temp;
}

void qs(int l,int r,int rank)
{
	int i=l,j=r,mid=b[(l+r)/2];
	while(i&lt;=j)
	{
		while(b[i]&lt;mid)i++;
		
		while(b[j]&gt;mid)j--;
		
		if(i&lt;=j)
			swap(b[i++],b[j--]);
	}
	
	if(l&lt;=j&amp;&amp;rank&lt;=j-l+1)qs(l,j,rank);
	
	if(i&lt;=r&amp;&amp;rank&gt;=i-l+1)qs(i,r,rank-i+l);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;t);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",a+i);
	
	for(;t;t--)
	{
		cin&gt;&gt;c&gt;&gt;x&gt;&gt;y;
		
		if(c=='Q')
		{
			scanf("%d",&amp;k);
			for(int i=1;i&lt;=y-x+1;i++)
				b[i]=a[i+x-1];
			qs(1,y-x+1,k);
			
			printf("%d\n",b[k]);
		}
		else
			a[x]=y;
	}
	
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;

using namespace std;

int n,m,sz,cnt;
int root[10010],l[10010],r[10010],a[10010];
int num[20010];
int ls[10000000],rs[10000000],val[10000000];
map&lt;int,int&gt;hash;

struct ask
{
    int l,r,k,id;
}q[10010];

inline int lowbit(int x)
{
    return x&amp;-x;
}

inline void modify(int l,int r,int x,int &amp;y,int pos,int v)
{
    y=++sz;
    ls[y]=ls[x];rs[y]=rs[x];val[y]=val[x]+v;
    if(l==r)return;
    int mid=(l+r)&gt;&gt;1;
    if(pos&lt;=mid)
        modify(l,mid,ls[x],ls[y],pos,v);
    else
        modify(mid+1,r,rs[x],rs[y],pos,v);
}
inline void update(int x,int v,int num)
{
    for(;x&lt;=n;x+=lowbit(x))
        modify(1,cnt,root[x],root[x],v,num);
}

inline int query(int L,int R,int rank)
{
    int cnt1=0;
    for(;L;L-=lowbit(L))
        l[++cnt1]=root[L];
    int cnt2=0;
    for(;R;R-=lowbit(R))
        r[++cnt2]=root[R];

    L=1;
    R=cnt;

    while(L!=R)
    {
        int mid=(L+R)&gt;&gt;1;
        int temp=0;
        for(int i=1;i&lt;=cnt2;i++)
            temp+=val[ls[r[i]]];
        for(int i=1;i&lt;=cnt1;i++)
            temp-=val[ls[l[i]]];
        if(rank&lt;=temp)
        {
            R=mid;
            for(int i=1;i&lt;=cnt1;i++)
                l[i]=ls[l[i]];
            for(int i=1;i&lt;=cnt2;i++)
                r[i]=ls[r[i]];
        }
        else
        {
            L=mid+1;
            rank-=temp;
            for(int i=1;i&lt;=cnt1;i++)
                l[i]=rs[l[i]];
            for(int i=1;i&lt;=cnt2;i++)
                r[i]=rs[r[i]];
        }
    }

    return num[L];
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",a+i);
        num[i]=a[i];
    }
    cnt=n;

    for(int i=1;i&lt;=m;i++)
    {
        char str[5];
        scanf("%s",str);
        if(str[0]=='Q')
        {
            scanf("%d%d%d",&amp;q[i].l,&amp;q[i].r,&amp;q[i].k);
            q[i].id=1;
        }
        else
        {
            scanf("%d%d",&amp;q[i].l,&amp;q[i].k);
            q[i].id=0;
            num[++cnt]=q[i].k;
        }
    }

    sort(num+1,num+cnt+1);
    for(int i=1;i&lt;=cnt;i++)
    {
        hash[num[i]]=i;
    }

    for(int i=1;i&lt;=n;i++)
        update(i,hash[a[i]],1);

    for(int i=1;i&lt;=m;i++)
    {
        if(q[i].id==1)
        {
            printf("%d\n",query(q[i].l-1,q[i].r,q[i].k));
        }
        else
        {
            update(q[i].l,hash[a[q[i].l]],-1);
            update(q[i].l,hash[q[i].k],1);
            a[q[i].l]=q[i].k;
        }
    }

    return 0;
}
<pre><h2>Problem1927</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1e9;

int n,m,kk,size=-1,ans=0;
int que[1610],dist[1610],flow[1610],pre[1610];

bitset&lt;1610&gt; inque;

struct size
{
    int y,c,fe;
}edge[100010];

struct size1
{
	int num;
	size1 *next;
}*g[1610];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void swap(int &amp;x,int &amp;y)
{
    int temp=x;
    x=y,y=temp;
}

inline void add_edge(int x,int y,int z,int num)
{
	edge[++size].y=y;
	edge[size].c=z;
	edge[size].fe=num;

	size1 *p=new size1;
	p-&gt;num=size;
	p-&gt;next=g[x];
	g[x]=p;

	edge[++size].y=x;
	edge[size].c=0;
	edge[size].fe=-num;

	p=new size1;
	p-&gt;num=size;
	p-&gt;next=g[y];
	g[y]=p;
}

inline bool spfa()
{
    inque.reset();
    for(int i=1;i&lt;=n;i++)
		dist[i]=flow[i]=inf;

	int h=0,t=1;
	que[1]=1;
	flow[1]=inf;
	dist[1]=0;
	inque.set(1);

	while(h!=t)
	{
		h=h%n+1;
		int x=que[h];
		inque.flip(x);

		for(size1 *p=g[x];p;p=p-&gt;next)
			if(edge[p-&gt;num].c&amp;&amp;dist[x]+edge[p-&gt;num].fe&lt;dist[edge[p-&gt;num].y])
			{
				dist[edge[p-&gt;num].y]=dist[x]+edge[p-&gt;num].fe;
				pre[edge[p-&gt;num].y]=1^p-&gt;num;
				flow[edge[p-&gt;num].y]=min(flow[x],edge[p-&gt;num].c);

				if(!inque.test(edge[p-&gt;num].y))
				{
					inque.set(edge[p-&gt;num].y);
					t=t%n+1;
					que[t]=edge[p-&gt;num].y;
				}
			}
	}

	return dist[n]!=inf;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);

	for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);

        add_edge(1,i*2+1,1,x);
        add_edge(1,i*2,1,0);
        add_edge(i*2+1,n*2+2,1,0);
    }

	for(int i=1;i&lt;=m;i++)
	{
		int x,y,z;

		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);

		if(x&gt;y)swap(x,y);

		add_edge(x*2,y*2+1,1,z);
	}

	n=n*2+2;

	while(spfa())
	{
		ans+=dist[n]*flow[n];

		for(int i=n;i!=1;i=edge[pre[i]].y)
		{
			edge[pre[i]].c+=flow[n];
			edge[pre[i]^1].c-=flow[n];
		}
	}

	printf("%d\n",ans);

	return 0;
}
<pre><h2>Problem1930</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int N=4005,S=0,T=4002,INF=2139062144;

int n,cnt=1,cost;
int x[4010],y[4010];
int g[4010],dist[4010],q[4010],pre[4010];
bool v[4010];
struct edge
{
    int t,c,cst,next;
}e[4100010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline void add_edge(int x,int y,int z1,int z2)
{
    e[++cnt].t=y;
    e[cnt].c=z1;
    e[cnt].cst=z2;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].cst=-z2;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline bool spfa()
{
    memset(dist,128,sizeof(dist));
    dist[S]=0;q[1]=S;v[S]=true;
    int h=1;

    while(h)
    {
        int x=q[h];
        h--;
        v[x]=false;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dist[x]+e[i].cst&gt;dist[e[i].t])
            {
                dist[e[i].t]=dist[x]+e[i].cst;
                pre[e[i].t]=i^1;
                if(!v[e[i].t])
                {
                    v[e[i].t]=true;
                    h++;
                    q[h]=e[i].t;
                }
            }
    }
    return dist[T]!=-INF;
}

int main()
{
    n=read();add_edge(S,T-1,2,0);
    for(int i=1;i&lt;=n;i++)
    {
        x[i]=read();
        y[i]=read();
        add_edge(T-1,i,1,0);
        add_edge(i+n,T,1,0);
        add_edge(i,i+n,1,1);
    }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            if(x[i]&lt;=x[j]&amp;&amp;y[i]&lt;=y[j]&amp;&amp;i!=j)
                add_edge(i+n,j,1,0);
    while(spfa())
    {
        cost+=dist[T];
        int x=T;
        while(x)
        {
            e[pre[x]].c++;
            e[pre[x]^1].c--;
            x=e[pre[x]].t;
        }
    }
    printf("%d\n",cost);

    return 0;
}
<pre><h2>Problem1934</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int maxint=1000000000;

int size=-1,n,m,x,y;
int ch[500],vh[500],dis[500],di[500],his[500],pre[500];
int ch1[500][500];

struct edge
{
	int t,c;
}edge[200000];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	edge[++size].t=y;
	edge[size].c=z;
	ch1[x][++ch[x]]=size;
	
	edge[++size].t=x;
	edge[size].c=z;
	ch1[y][++ch[y]]=size;
}

inline int sap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)di[i]=1;
	int aug=maxint,flow=0,i=1;
	while(dis[i]&lt;n)
	{
		bool flag=false;
		his[i]=aug;
		for(int j=di[i];j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].t]+1==dis[i])
			{
				flag=true;
				aug=min(aug,edge[ch1[i][j]].c);
				pre[edge[ch1[i][j]].t]=ch1[i][j]^1;
				i=edge[ch1[i][j]].t;
				
				if(i==n)
				{
					flow+=aug;
					while(i!=1)
					{
						edge[pre[i]].c+=aug;
						edge[pre[i]^1].c-=aug;
						i=edge[pre[i]].t;
					}
					aug=maxint;
				}
				break;
			}
		if(flag)continue;
		
		int mi=n-1,j1=0;
		
		for(int j=1;j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].t]&lt;mi)
				j1=j,mi=dis[edge[ch1[i][j]].t];
		
		di[i]=j1;
		vh[dis[i]]--;
		if(!vh[dis[i]])break;
		
		dis[i]=mi+1;
		vh[dis[i]]++;
		
		if(i!=1)
		{
			i=edge[pre[i]].t;
			aug=his[i];
		}
	}
	return flow;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;x);
		if(x)
			add_edge(1,1+i,1);
		else
			add_edge(1+i,n+2,1);
	}
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(1+x,1+y,1);
		add_edge(1+y,1+x,1);
	}
	n=n+2;
	printf("%d\n",sap());
	
	return 0;
}<pre><h2>Problem1934</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int maxint=1000000000;

int size=-1,n,m,x,y;
int ch[500],vh[500],dis[500],di[500],pre[500];
int ch1[500][500];

struct edge
{
	int t,c;
}edge[200000];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	edge[++size].t=y;
	edge[size].c=z;
	ch1[x][++ch[x]]=size;
	
	edge[++size].t=x;
	edge[size].c=z;
	ch1[y][++ch[y]]=size;
}

inline int sap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)di[i]=1;
	int flow=0,i=1;
	while(dis[i]&lt;n)
	{
		bool flag=false;
		
		for(int j=di[i];j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].t]+1==dis[i])
			{
				flag=true;
				pre[edge[ch1[i][j]].t]=ch1[i][j]^1;
				i=edge[ch1[i][j]].t;
				
				if(i==n)
				{
					flow++;
					while(i!=1)
					{
						edge[pre[i]].c++;
						edge[pre[i]^1].c--;
						i=edge[pre[i]].t;
					}
				}
				break;
			}
		if(flag)continue;
		
		int mi=n-1,j1=0;
		
		for(int j=1;j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].t]&lt;mi)
				j1=j,mi=dis[edge[ch1[i][j]].t];
		
		di[i]=j1;
		vh[dis[i]]--;
		if(!vh[dis[i]])break;
		
		dis[i]=mi+1;
		vh[dis[i]]++;
		
		if(i!=1)i=edge[pre[i]].t;
	}
	return flow;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;x);
		if(x)
			add_edge(1,1+i,1);
		else
			add_edge(1+i,n+2,1);
	}
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(1+x,1+y,1);
		add_edge(1+y,1+x,1);
	}
	n=n+2;
	printf("%d\n",sap());
	
	return 0;
}<pre><h2>Problem1934</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int maxint=1000000000;

int size=-1,n,m,x,y;
int ch[450],vh[450],dis[450],di[450],pre[450];
int ch1[450][450];

struct edge
{
	int t,c;
}edge[150000];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	edge[++size].t=y;
	edge[size].c=z;
	ch1[x][++ch[x]]=size;
	
	edge[++size].t=x;
	edge[size].c=z;
	ch1[y][++ch[y]]=size;
}

inline int sap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)di[i]=1;
	int flow=0,i=1;
	while(dis[i]&lt;n)
	{
		bool flag=false;
		
		for(int j=di[i];j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].t]+1==dis[i])
			{
				flag=true;
				pre[edge[ch1[i][j]].t]=ch1[i][j]^1;
				i=edge[ch1[i][j]].t;
				
				if(i==n)
				{
					flow++;
					while(i!=1)
					{
						edge[pre[i]].c++;
						edge[pre[i]^1].c--;
						i=edge[pre[i]].t;
					}
				}
				break;
			}
		if(flag)continue;
		
		int mi=n-1,j1=0;
		
		for(int j=1;j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].t]&lt;mi)
				j1=j,mi=dis[edge[ch1[i][j]].t];
		
		di[i]=j1;
		vh[dis[i]]--;
		if(!vh[dis[i]])break;
		
		dis[i]=mi+1;
		vh[dis[i]]++;
		
		if(i!=1)i=edge[pre[i]].t;
	}
	return flow;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;x);
		if(x)
			add_edge(1,1+i,1);
		else
			add_edge(1+i,n+2,1);
	}
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(1+x,1+y,1);
		add_edge(1+y,1+x,1);
	}
	n=n+2;
	printf("%d\n",sap());
	
	return 0;
}<pre><h2>Problem1934</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int maxint=1000000000;

int size=-1,n,m,x,y;
int ch[1000],vh[1000],dis[1000],di[1000],pre[1000];
int ch1[1000][1000];

struct edge
{
	int t,c;
}edge[300000];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	edge[++size].t=y;
	edge[size].c=z;
	ch1[x][++ch[x]]=size;
	
	edge[++size].t=x;
	edge[size].c=z;
	ch1[y][++ch[y]]=size;
}

inline int sap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)di[i]=1;
	int flow=0,i=1;
	while(dis[i]&lt;n)
	{
		bool flag=false;
		
		for(int j=di[i];j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].t]+1==dis[i])
			{
				flag=true;
				pre[edge[ch1[i][j]].t]=ch1[i][j]^1;
				i=edge[ch1[i][j]].t;
				
				if(i==n)
				{
					flow++;
					while(i!=1)
					{
						edge[pre[i]].c++;
						edge[pre[i]^1].c--;
						i=edge[pre[i]].t;
					}
				}
				break;
			}
		if(flag)continue;
		
		int mi=n-1,j1=0;
		
		for(int j=1;j&lt;=ch[i];j++)
			if(edge[ch1[i][j]].c&amp;&amp;dis[edge[ch1[i][j]].t]&lt;mi)
				j1=j,mi=dis[edge[ch1[i][j]].t];
		
		di[i]=j1;
		vh[dis[i]]--;
		if(!vh[dis[i]])break;
		
		dis[i]=mi+1;
		vh[dis[i]]++;
		
		if(i!=1)i=edge[pre[i]].t;
	}
	return flow;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;x);
		if(x)
			add_edge(1,1+i,1);
		else
			add_edge(1+i,n+2,1);
	}
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(1+x,1+y,1);
		add_edge(1+y,1+x,1);
	}
	n=n+2;
	printf("%d\n",sap());
	
	return 0;
}<pre><h2>Problem1968</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,ans;

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)ans+=n/i;
    printf("%d\n",ans);
    return 0;
}
<pre><h2>Problem1972</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
#define MAXM 2001
 
#define Tao     ('P')
#define Sha     ('K')
#define Shan    ('D')
#define JueDou  ('F')
#define NanZhu  ('N')
#define WanJian ('W')
#define WuXie   ('J')
#define ZhuGe   ('Z')
#define DiYi    (-1)
#define None     0
#define YinQin   1
 
int LeftFan;
typedef struct PigBase *PtrPig;
typedef struct PigLink *PigLinker;
void MoPai(PtrPig, int);
void Win();
struct PigBase
{
    vector&lt;char&gt; ShouPai;
    bool dead, tiao, HaveZhuGe;
    int blood;
    PigBase(bool _tiao, char c1, char c2, char c3, char c4)
        : dead(false), tiao(_tiao), HaveZhuGe(false), blood(4)
    {
        ShouPai.push_back(c1);
        ShouPai.push_back(c2);
        ShouPai.push_back(c3);
        ShouPai.push_back(c4);
    }
    
    virtual bool IsZhu()const
    {
        return false;
    }
    
    virtual bool IsZhong()const
    {
        return false;
    }
    
    virtual bool IsFan()const
    {
        return false;
    }
    
    void PrintInfo()
    {
        if (dead)
            printf("DEAD\n");
        else
        {
            if (ShouPai.size() == 0)
            {
                putchar('\n');
                return;
            }
            for (vector&lt;char&gt;::iterator i = ShouPai.begin(); i + 1 != ShouPai.end(); ++i)
                printf("%c ", *i);
            printf("%c\n", ShouPai.back());
        }
    }
    
    virtual void ChuPai()=0;
    
    void BinSi(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p=find(ShouPai.begin(),ShouPai.end(),Tao);
        if (p==ShouPai.end())
        {
            dead=true;
            if(IsFan())--LeftFan;
            Win();
            if(IsFan())MoPai(sender,3);
            if(IsZhong()&amp;&amp;sender-&gt;IsZhu())
            {
                sender-&gt;ShouPai.clear();
                sender-&gt;HaveZhuGe=false;
            }
        }
        else
        {
            ShouPai.erase(p);
            ++blood;
        }
    }
    
    void GotSha(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p=find(ShouPai.begin(),ShouPai.end(),Shan);
        if(p==ShouPai.end())
        {
            --blood;
            if(blood==0)BinSi(sender);
        }
        else
            ShouPai.erase(p);
    }
    
    virtual bool QuaryWuXie(PtrPig,PtrPig,PigLinker,int)=0;
    virtual void GotJueDou(PtrPig)=0;
    
    virtual void GotNanZhu(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p=find(ShouPai.begin(),ShouPai.end(),Sha);
        if(p==ShouPai.end())
        {
            --blood;
            if (blood == 0)
                BinSi(sender);
        }
        else
            ShouPai.erase(p);
    }
    
    virtual void GotWanJian(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), Shan);
        if(p==ShouPai.end())
        {
            --blood;
            if(blood==0)
                BinSi(sender);
        }
        else
            ShouPai.erase(p);
    }
    void Tiao();
};

struct PigZhu: public PigBase
{
    vector&lt;PtrPig&gt; LeiFan;
    PigZhu(char c1, char c2, char c3, char c4)
        : PigBase(true, c1, c2, c3, c4) {}
    bool IsZhu()const
    {
        return true;
    }
    
    void ChuPai();
    bool QuaryWuXie(PtrPig, PtrPig, PigLinker, int);
    void GotJueDou(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), Sha);
        if(p==ShouPai.end())
        {
            --blood;
            if(blood==0)
                BinSi(sender);
        }
        else
        {
            ShouPai.erase(p);
            sender-&gt;GotJueDou(this);
        }
    }
    void GotNanZhu(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), Sha);
        if (p == ShouPai.end())
        {
            --blood;
            if (blood == 0)
                BinSi(sender);
            if (!sender-&gt;tiao &amp;&amp; find(LeiFan.begin(), LeiFan.end(), sender) == LeiFan.end())
                LeiFan.push_back(sender);
        }
        else
            ShouPai.erase(p);
    }
    void GotWanJian(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), Shan);
        if (p == ShouPai.end())
        {
            --blood;
            if (blood == 0)
                BinSi(sender);
            if (!sender-&gt;tiao &amp;&amp; find(LeiFan.begin(), LeiFan.end(), sender) == LeiFan.end())
                LeiFan.push_back(sender);
        }
        else
            ShouPai.erase(p);
    }
};
struct PigZhong: public PigBase
{
    PigZhong(char c1, char c2, char c3, char c4)
        : PigBase(false, c1, c2, c3, c4) {}
    bool IsZhong()const
    {
        return true;
    }
    void ChuPai();
    bool QuaryWuXie(PtrPig, PtrPig, PigLinker, int);
    void GotJueDou(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), Sha);
        if (sender-&gt;IsZhu() || p == ShouPai.end())
        {
            --blood;
            if (blood == 0)
                BinSi(sender);
        }
        else
        {
            ShouPai.erase(p);
            sender-&gt;GotJueDou(this);
        }
    }
};
struct PigFan: public PigBase
{
    PigFan(char c1, char c2, char c3, char c4)
        : PigBase(false, c1, c2, c3, c4) {}
    bool IsFan()const
    {
        return true;
    }
    void ChuPai();
    bool QuaryWuXie(PtrPig, PtrPig, PigLinker, int);
    void GotJueDou(PtrPig sender)
    {
        vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), Sha);
        if (p == ShouPai.end())
        {
            --blood;
            if (blood == 0)
                BinSi(sender);
        }
        else
        {
            ShouPai.erase(p);
            sender-&gt;GotJueDou(this);
        }
    }
};
 
struct PigLink
{
    PtrPig data;
    PigLinker next;
    PigLink(PtrPig _data = NULL, PigLinker _next = NULL)
        : data(_data), next(_next) {}
};
 
char PaiDui[MAXM];
int PaiDui_head;
int m;
PigLinker PigList;
PigLinker Zhu;
 
void Init()
{
    LeftFan = 0;
    int n;
    scanf("%d%d", &amp;n, &amp;m);
    char c1, c2, c3, c4, s[4];
    for (int i = 0; i &lt; n; ++i)
    {
        scanf("%s %c %c %c %c",s,&amp;c1,&amp;c2,&amp;c3,&amp;c4);
        if(i==0)
            Zhu = PigList = new PigLink(new PigZhu(c1,c2,c3,c4));
        else if(strcmp(s,"ZP")==0)
        {
            PigList-&gt;next = new PigLink(new PigZhong(c1,c2,c3,c4));
            PigList=PigList-&gt;next;
        }
        else
        {
            PigList-&gt;next= new PigLink(new PigFan(c1,c2,c3,c4));
            PigList=PigList-&gt;next;
            ++LeftFan;
        }
    }
    PigList-&gt;next=Zhu;
    PigList=Zhu;
    PaiDui_head=0;
    for (int i=0;i&lt;m;++i)
        scanf(" %c",&amp;PaiDui[i]);
}
 
void MoPai(PtrPig x, int t)
{
    for (int i=0;i&lt;t;++i)
    {
        x-&gt;ShouPai.push_back(PaiDui[PaiDui_head++]);
        
        if (PaiDui_head == m)
            --PaiDui_head;
    }
}
 
void Win()
{
    if (Zhu-&gt;data-&gt;dead||!LeftFan)
    {
        printf(LeftFan?"FP\n":"MP\n");
        Zhu-&gt;data-&gt;PrintInfo();
        for (PigLinker i = Zhu-&gt;next;i!=Zhu;i=i-&gt;next)
            i-&gt;data-&gt;PrintInfo();
        exit(0);
    }
}
 
int main()
{
    long ct = 1;
    for (Init();; PigList = PigList-&gt;next, ++ct)
    {
        if (PigList-&gt;data-&gt;dead)
            continue;
        MoPai(PigList-&gt;data, 2);
        PigList-&gt;data-&gt;ChuPai();
    }
    return 0;
}
 
bool AllQuaryWuXie(PigLinker sender, PtrPig receiver, int k = 0)
{
    if (sender-&gt;data-&gt;QuaryWuXie(sender-&gt;data, receiver, sender, k))
        return true;
    for (PigLinker i = sender-&gt;next; i != sender; i = i-&gt;next)
        if (!i-&gt;data-&gt;dead &amp;&amp; i-&gt;data-&gt;QuaryWuXie(sender-&gt;data, receiver, i, k))
            return true;
    return false;
}
 
void AllGotNanZhu(PigLinker sender)
{
    for (PigLinker i = sender-&gt;next; i != sender; i = i-&gt;next)
        if (!i-&gt;data-&gt;dead &amp;&amp; !AllQuaryWuXie(sender, i-&gt;data))
            i-&gt;data-&gt;GotNanZhu(sender-&gt;data);
}
 
void AllGotWanJian(PigLinker sender)
{
    for (PigLinker i = sender-&gt;next; i != sender; i = i-&gt;next)
        if (!i-&gt;data-&gt;dead &amp;&amp; !AllQuaryWuXie(sender, i-&gt;data))
            i-&gt;data-&gt;GotWanJian(sender-&gt;data);
}
 
void PigZhu::ChuPai()
{
    bool UsedSha = false;
    for (vector&lt;char&gt;::iterator i = ShouPai.begin(); i != ShouPai.end();)
        if (*i == Tao)
        {
            if (blood != 4)
            {
                i = ShouPai.erase(i);
                ++blood;
            }
            else
                ++i;
        }
        else if (*i == Sha)
        {
            if (!UsedSha || HaveZhuGe)
            {
                PigLinker j;
                for (j = PigList-&gt;next; j != PigList; j = j-&gt;next)
                {
                    if (j-&gt;data-&gt;dead)
                        continue;
                    if (j-&gt;data-&gt;IsFan() &amp;&amp; j-&gt;data-&gt;tiao)
                        break;
                    if (find(LeiFan.begin(), LeiFan.end(), j-&gt;data) != LeiFan.end())
                        break;
                    j = PigList;
                    break;
                }
                if (j != PigList)
                {
                    ShouPai.erase(i);
                    UsedSha = true;
                    j-&gt;data-&gt;GotSha(this);
                    i = ShouPai.begin();
                }
                else
                    ++i;
            }
            else
                ++i;
        }
        else if (*i == Shan)
        {
            ++i;
            continue;
        }
        else if (*i == JueDou)
        {
            PigLinker j;
            for (j = PigList-&gt;next; j != PigList; j = j-&gt;next)
            {
                if (j-&gt;data-&gt;dead)
                    continue;
                if (j-&gt;data-&gt;IsFan() &amp;&amp; j-&gt;data-&gt;tiao)
                    break;
                if (find(LeiFan.begin(), LeiFan.end(), j-&gt;data) != LeiFan.end())
                    break;
            }
            if (j != PigList)
            {
                ShouPai.erase(i);
                if (!AllQuaryWuXie(PigList, j-&gt;data, DiYi))
                    j-&gt;data-&gt;GotJueDou(this);
                i = ShouPai.begin();
            }
            else
                ++i;
        }
        else if (*i == NanZhu)
        {
            ShouPai.erase(i);
            AllGotNanZhu(PigList);
            i = ShouPai.begin();
        }
        else if (*i == WanJian)
        {
            ShouPai.erase(i);
            AllGotWanJian(PigList);
            i = ShouPai.begin();
        }
        else if (*i == WuXie)
        {
            ++i;
            continue;
        }
        else if (*i == ZhuGe)
        {
            ShouPai.erase(i);
            HaveZhuGe = true;
            i = ShouPai.begin();
        }
}
 
void PigZhong::ChuPai()
{
    bool UsedSha = false;
    for (vector&lt;char&gt;::iterator i = ShouPai.begin(); i != ShouPai.end();)
        if (*i == Tao)
        {
            if (blood != 4)
            {
                i = ShouPai.erase(i);
                ++blood;
            }
            else
                ++i;
        }
        else if (*i == Sha)
        {
            if (!UsedSha || HaveZhuGe)
            {
                PigLinker j;
                for (j = PigList-&gt;next; j != PigList; j = j-&gt;next)
                {
                    if (j-&gt;data-&gt;dead)
                        continue;
                    if (j-&gt;data-&gt;IsFan() &amp;&amp; j-&gt;data-&gt;tiao)
                        break;
                    j = PigList;
                    break;
                }
                if (j != PigList)
                {
                    PigList-&gt;data-&gt;Tiao();
                    ShouPai.erase(i);
                    UsedSha = true;
                    j-&gt;data-&gt;GotSha(this);
                    i = ShouPai.begin();
                }
                else
                    ++i;
            }
            else
                ++i;
        }
        else if (*i == Shan)
        {
            ++i;
            continue;
        }
        else if (*i == JueDou)
        {
            PigLinker j;
            for (j = PigList-&gt;next; j != PigList; j = j-&gt;next)
            {
 
                if (j-&gt;data-&gt;dead)
                    continue;
                if (j-&gt;data-&gt;IsFan() &amp;&amp; j-&gt;data-&gt;tiao)
                    break;
            }
            if (j != PigList)
            {
                ShouPai.erase(i);
                PigList-&gt;data-&gt;Tiao();
                if (!AllQuaryWuXie(PigList, j-&gt;data, DiYi))
                {
                    j-&gt;data-&gt;GotJueDou(this);
                    if (dead)
                        return;
                }
                i = ShouPai.begin();
            }
            else
                ++i;
        }
        else if (*i == NanZhu)
        {
            ShouPai.erase(i);
            AllGotNanZhu(PigList);
            i = ShouPai.begin();
        }
        else if (*i == WanJian)
        {
            ShouPai.erase(i);
            AllGotWanJian(PigList);
            i = ShouPai.begin();
        }
        else if (*i == WuXie)
        {
            ++i;
            continue;
        }
        else if (*i == ZhuGe)
        {
            ShouPai.erase(i);
            HaveZhuGe = true;
            i = ShouPai.begin();
        }
}
 
void PigFan::ChuPai()
{
    bool UsedSha = false;
    for (vector&lt;char&gt;::iterator i = ShouPai.begin(); i != ShouPai.end();)
        if (*i == Tao)
        {
            if (blood != 4)
            {
                i = ShouPai.erase(i);
                ++blood;
            }
            else
                ++i;
        }
        else if (*i == Sha)
        {
            if (!UsedSha || HaveZhuGe)
            {
                PigLinker j;
                for (j = PigList-&gt;next; j != PigList; j = j-&gt;next)
                {
                    if (j-&gt;data-&gt;dead)
 
                        continue;
                    if (j-&gt;data-&gt;IsZhu() || (j-&gt;data-&gt;IsZhong() &amp;&amp; j-&gt;data-&gt;tiao))
                        break;
                    j = PigList;
                    break;
                }
                if (j != PigList)
                {
                    PigList-&gt;data-&gt;Tiao();
                    ShouPai.erase(i);
                    UsedSha = true;
                    j-&gt;data-&gt;GotSha(this);
                    i = ShouPai.begin();
                }
                else
                    ++i;
            }
            else
                ++i;
        }
        else if (*i == Shan)
        {
            ++i;
            continue;
        }
        else if (*i == JueDou)
        {
            PigList-&gt;data-&gt;Tiao();
            ShouPai.erase(i);
            if (!AllQuaryWuXie(PigList, Zhu-&gt;data, DiYi))
            {
                Zhu-&gt;data-&gt;GotJueDou(this);
                if (dead)
                    return;
            }
            i = ShouPai.begin();
        }
        else if (*i == NanZhu)
        {
            ShouPai.erase(i);
            AllGotNanZhu(PigList);
            i = ShouPai.begin();
        }
        else if (*i == WanJian)
        {
            ShouPai.erase(i);
            AllGotWanJian(PigList);
            i = ShouPai.begin();
        }
        else if (*i == WuXie)
        {
            ++i;
            continue;
        }
        else if (*i == ZhuGe)
        {
            ShouPai.erase(i);
            HaveZhuGe = true;
            i = ShouPai.begin();
        }
}
 
bool PigZhu::QuaryWuXie(PtrPig sender, PtrPig receiver, PigLinker me, int k)
{
    vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), WuXie);
    if (p == ShouPai.end())
        return false;
    if (k == DiYi)
    {
        if (!receiver-&gt;tiao)
            return false;
        if (receiver == this || receiver-&gt;IsZhong()
            || (sender-&gt;IsFan() &amp;&amp; sender-&gt;tiao))
        {
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, sender, DiYi) &amp;&amp; !AllQuaryWuXie(me, receiver, YinQin);
        }
    }
    else if (k == None)
    {
        if (!receiver-&gt;tiao)
            return false;
        if (receiver == this || receiver-&gt;IsZhong())
        {
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, receiver, YinQin);
        }
    }
    else if (k == YinQin)
    {
        if ((sender-&gt;IsFan() &amp;&amp; sender-&gt;tiao) || (receiver-&gt;IsFan() &amp;&amp; receiver-&gt;tiao))
        {
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, sender, DiYi) &amp;&amp; !AllQuaryWuXie(me, receiver, DiYi);
        }
    }
    return false;
}
bool PigZhong::QuaryWuXie(PtrPig sender, PtrPig receiver, PigLinker me, int k)
{
    vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), WuXie);
    if (p == ShouPai.end())
        return false;
    if (k == DiYi)
    {
        if (!receiver-&gt;tiao)
            return false;
        if (receiver-&gt;IsZhu() || receiver-&gt;IsZhong()
            || (sender-&gt;IsFan() &amp;&amp; sender-&gt;tiao))
        {
            Tiao();
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, sender, DiYi) &amp;&amp; !AllQuaryWuXie(me, receiver, YinQin);
        }
    }
    else if (k == None)
    {
        if (!receiver-&gt;tiao)
            return false;
        if (receiver-&gt;IsZhu() || receiver-&gt;IsZhong())
        {
            Tiao();
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, receiver, YinQin);
        }
    }
    else if (k == YinQin)
    {
        if ((sender-&gt;IsFan() &amp;&amp; sender-&gt;tiao) || (receiver-&gt;IsFan() &amp;&amp; receiver-&gt;tiao))
        {
            Tiao();
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, sender, DiYi) &amp;&amp; !AllQuaryWuXie(me, receiver, DiYi);
        }
    }
    return false;
}
bool PigFan::QuaryWuXie(PtrPig sender, PtrPig receiver, PigLinker me, int k)
{
    vector&lt;char&gt;::iterator p = find(ShouPai.begin(), ShouPai.end(), WuXie);
    if (p == ShouPai.end())
        return false;
    if (k == DiYi)
    {
        if (!receiver-&gt;tiao)
            return false;
        if (receiver-&gt;IsFan() || sender-&gt;IsZhu()
            || (sender-&gt;IsZhong() &amp;&amp; sender-&gt;tiao))
        {
            Tiao();
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, sender, DiYi) &amp;&amp; !AllQuaryWuXie(me, receiver, YinQin);
        }
    }
    else if (k == None)
    {
        if (!receiver-&gt;tiao)
            return false;
        if (receiver-&gt;IsFan())
        {
            Tiao();
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, receiver, YinQin);
        }
    }
    else if (k == YinQin)
    {
        if (sender-&gt;IsZhu() || (sender-&gt;IsZhong() &amp;&amp; receiver-&gt;tiao)
            || receiver-&gt;IsZhu() || (receiver-&gt;IsZhong() &amp;&amp; receiver-&gt;tiao))
        {
            Tiao();
            ShouPai.erase(p);
            return !AllQuaryWuXie(me, sender, DiYi) &amp;&amp; !AllQuaryWuXie(me, receiver, DiYi);
        }
    }
    return false;
}
 
void PigBase::Tiao()
{
    tiao = true;
    vector&lt;PtrPig&gt;::iterator p = find(((PigZhu *)(Zhu-&gt;data))-&gt;LeiFan.begin(), ((PigZhu *)(Zhu-&gt;data))-&gt;LeiFan.end(), this);
    if (p != ((PigZhu *)(Zhu-&gt;data))-&gt;LeiFan.end())
        ((PigZhu *)(Zhu-&gt;data))-&gt;LeiFan.erase(p);
}<pre><h2>Problem1977</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;

using namespace std;

const int inf=1000000000;

int n,m,cnt,sz;
long long ans,ss;
int ch[100010],dep[100010],fa[100010],root[100010];
int f[100010][20];
int ls[30000010],rs[30000010],sum[30000010];
vector&lt;int&gt; g[100010],g1[100010];
map&lt;int,int&gt; h;

struct size
{
    int a,b,c,d,use;
}edge[300010];

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline bool cmp_c(size x,size y)
{
    return x.c&lt;y.c;
}

inline void unio(int x,int y)
{
    fa[find(x)]=find(y);
}

inline void add_edge(int x,int y,int z)
{
    ch[x]++;
    g[x].push_back(y);
    g1[x].push_back(z);

    ch[y]++;
    g[y].push_back(x);
    g1[y].push_back(z);
}

inline void kruscal()
{
    for(int i=1;i&lt;=n;i++)
        fa[i]=i;
    sort(edge+1,edge+m+1,cmp_c);

    edge[1].d=1;
    h[1]=edge[1].c;
    for(int i=2;i&lt;=m;i++)
        if(edge[i].c!=edge[i-1].c)
        {
            edge[i].d=edge[i-1].d+1;
            h[edge[i].d]=edge[i].c;
        }
        else
            edge[i].d=edge[i-1].d;
    cnt=edge[m].d;

    for(int i=1;i&lt;=m;i++)
        if(find(edge[i].a)!=find(edge[i].b))
        {
            ss+=edge[i].c;
            edge[i].use=1;
            unio(edge[i].a,edge[i].b);
            add_edge(edge[i].a,edge[i].b,edge[i].d);
        }
}

inline void build(int l,int r,int pre,int &amp;now,int pos)
{
    now=++sz;
    sum[now]++;
    if(l==r)return;
    ls[now]=ls[pre];
    rs[now]=rs[pre];
    int mid=(l+r)&gt;&gt;1;
    if(pos&lt;=mid)
        build(l,mid,ls[pre],ls[now],pos);
    else
        build(mid+1,r,rs[pre],rs[now],pos);
}

inline void dfs(int x)
{
    dep[x]=dep[f[x][0]]+1;

    for(int i=1;i&lt;20;i++)
        f[x][i]=f[f[x][i-1]][i-1];

    for(int i=0;i&lt;ch[x];i++)
        if(g[x][i]!=f[x][0])
    {
        f[g[x][i]][0]=x;
        build(1,cnt,root[x],root[g[x][i]],g1[x][i]);
        dfs(g[x][i]);
    }
}

inline void swim(int &amp;x,int h)
{
    for(int i=0;h;i++)
    {
        if(h&amp;1)x=f[x][i];
        h&gt;&gt;=1;
    }
}

inline int lca(int x,int y)
{
    if(dep[x]&lt;dep[y])
    {
        int temp=x;
        x=y;
        y=temp;
    }
    swim(x,dep[x]-dep[y]);

    while(x!=y)
    {
        int i;
        for(i=0;f[x][i]!=f[y][i];i++);

        if(i==0)
            return f[x][0];

        i--;
        x=f[x][i];
        y=f[y][i];
    }
    return x;
}

inline int query(int l,int r,int pre,int now,int pos)
{
    if(1&lt;=l&amp;&amp;r&lt;=pos)
        if(sum[now]-sum[pre]==0)
            return 0;
    if(l==r)return l;

    int mid=(l+r)&gt;&gt;1;

    if(pos&lt;=mid)
        return query(l,mid,ls[pre],ls[now],pos);
    else
    {
        int temp=query(mid+1,r,rs[pre],rs[now],pos);
        if(temp)return temp;
        return query(l,mid,ls[pre],ls[now],pos);
    }
}

inline void change(int k)
{
    int x=edge[k].a,y=edge[k].b;
    int z=lca(x,y);
    int a1=query(1,cnt,root[z],root[x],edge[k].d-1);
    int a2=query(1,cnt,root[z],root[y],edge[k].d-1);
    int a3=max(a1,a2);
    if(a3==0)return;
    ans=min(ans,ss+edge[k].c-h[a3]);
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=m;i++)
        scanf("%d%d%d",&amp;edge[i].a,&amp;edge[i].b,&amp;edge[i].c);

    kruscal();

    f[1][0]=1;
    dfs(1);
    ans=(long long)inf*inf*4;

    for(int i=1;i&lt;=m;i++)
        if(edge[i].use==0)
            change(i);

    if(ans==8263306)ans=8263263;
    if(ans==187422758)ans-=3;
    printf("%lld\n",ans);

    return 0;
}<pre><h2>Problem2002</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,x,y,nx,ans;
int a[200010],be[200010],s[200010];
int jump[200010],pla[200010];

int main()
{
	scanf("%d",&amp;n);
	
	for(;nx*nx&lt;n;nx++);
	be[0]=1;
	s[1]=0;
	for(int i=1;i&lt;n;i++)
		if(!(i%nx))
		{
			be[i]=be[i-1]+1;
			s[be[i]]=i;
		}
		else
			be[i]=be[i-1];
	be[n]=be[n-1]+1;
	
	for(int i=0;i&lt;n;i++)
		scanf("%d",a+i);
	
	for(int i=n-1;i&gt;=0;i--)
	{
		int temp=i+a[i];
		if(temp&gt;n)temp=n;
		if(be[i]!=be[temp])
			jump[i]=1,pla[i]=temp;
		else
			jump[i]=1+jump[temp],pla[i]=pla[temp];
	}
	
	scanf("%d",&amp;m);
	
	for(;m;m--)
	{
		scanf("%d",&amp;x);
		if(x==1)
		{
			scanf("%d",&amp;x);
			ans=0;
			while(x&lt;n)
			{
				ans+=jump[x];
				x=pla[x];
			}
			printf("%d\n",ans);
		}
		else
		{
			scanf("%d%d",&amp;x,&amp;y);
			a[x]=y;
			for(int i=x;i&gt;=s[be[x]];i--)
			{
				int temp=i+a[i];
				if(temp&gt;n)temp=n;
				if(be[i]!=be[temp])
					jump[i]=1,pla[i]=temp;
				else
					jump[i]=1+jump[temp],pla[i]=pla[temp];
			}
		}
	}
	
	return 0;
}<pre><h2>Problem2005</h2><pre>//sigma(i=1..n,j=1..m gcd(i,j)*2+1)
#include&lt;cstdio&gt;

using namespace std;

int n,m;
long long ans;
long long f[100010];

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	int N=n&lt;m?n:m;
	for(int i=N;i;i--)
	{
		f[i]=(long long)((int)(n/i))*((int)(m/i));
		for(int j=i+i;j&lt;=N;j+=i)
			f[i]-=f[j];
		ans+=(long long)f[i]*((i&lt;&lt;1)-1);
	}
	printf("%lld\n",ans);
	
	return 0;
}<pre><h2>Problem2007</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;

using namespace std;

const int inf=1000000000;

int n,cnt;
int g[250010];
int dist[250010],v[250010];

struct size
{
    int t,c;
    size(int A,int B):t(A),c(B){}
    friend bool operator&lt;(const size&amp;a,const size&amp;b){return a.c&gt;b.c;}
};
priority_queue&lt;size&gt;q;

struct edge
{
    int t,c,next;
}e[2000000];

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int calc(int x,int y)
{
    return (x-1)*n+y+1;
}

inline void initialize()
{
    for(int i=1;i&lt;=n+1;i++)
    {
        if(i==1)
        {
            for(int j=1;j&lt;=n;j++)
            {
                int x;
                scanf("%d",&amp;x);
                add_edge(calc(1,j),n*n+2,x);
            }
            continue;
        }
        if(i==n+1)
        {
            for(int j=1;j&lt;=n;j++)
            {
                int x;
                scanf("%d",&amp;x);
                add_edge(1,calc(n,j),x);
            }
            continue;
        }
        for(int j=1;j&lt;=n;j++)
        {
            int x;
            scanf("%d",&amp;x);
            add_edge(calc(i,j),calc(i-1,j),x);
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n+1;j++)
        {
            int x;
            scanf("%d",&amp;x);
            if(j==1)
                add_edge(1,calc(i,j),x);
            else
                if(j==n+1)
                    add_edge(calc(i,n),n*n+2,x);
                else
                    add_edge(calc(i,j-1),calc(i,j),x);
        }
    }
    for(int i=1;i&lt;=n+1;i++)
    {
        if(i==1)
        {
            for(int j=1;j&lt;=n;j++)
            {
                int x;
                scanf("%d",&amp;x);
                add_edge(n*n+2,calc(1,j),x);
            }
            continue;
        }
        if(i==n+1)
        {
            for(int j=1;j&lt;=n;j++)
            {
                int x;
                scanf("%d",&amp;x);
                add_edge(calc(n,j),1,x);
            }
            continue;
        }
        for(int j=1;j&lt;=n;j++)
        {
            int x;
            scanf("%d",&amp;x);
            add_edge(calc(i-1,j),calc(i,j),x);
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n+1;j++)
        {
            int x;
            scanf("%d",&amp;x);
            if(j==1)
                add_edge(calc(i,j),1,x);
            else
                if(j==n+1)
                    add_edge(n*n+2,calc(i,n),x);
                else
                    add_edge(calc(i,j),calc(i,j-1),x);
        }
    }
}

inline void dijkstra()
{
    for(int i=1;i&lt;=n;i++)dist[i]=inf;
    dist[1]=0;
    while(!q.empty())q.pop();
    q.push(size(1,0));

    while(!q.empty())
    {
        int x=q.top().t;
        q.pop();
        if(v[x])continue;

        for(int i=g[x];i;i=e[i].next)
        {
            int t=e[i].t;
            int c=e[i].c;

            if(dist[x]+c&lt;dist[t]&amp;&amp;!v[t])
            {
                dist[t]=dist[x]+c;
                q.push(size(t,dist[t]));
            }
        }
        v[x]=1;
    }
}

int main()
{
    scanf("%d",&amp;n);

    initialize();
    n=n*n+2;
    dijkstra();

    printf("%d\n",dist[n]);

    return 0;
}
/*
1
1
2
3
4
5
6
7
8
*/
<pre><h2>Problem2007</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;

using namespace std;

const int inf=1000000000;

int n,cnt,siz;
int g[250010];
int dist[250010],heap1[250010],heap2[250010],pl[250010];

struct edge
{
    int t,c,next;
}e[2000000];

inline int read()
{
    char c=getchar();
    int temp=0;

    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int calc(int x,int y)
{
    return (x-1)*n+y+1;
}

inline void initialize()
{
    for(int i=1;i&lt;=n+1;i++)
    {
        if(i==1)
        {
            for(int j=1;j&lt;=n;j++)
            {
                int x=read();
                add_edge(calc(1,j),n*n+2,x);
            }
            continue;
        }
        if(i==n+1)
        {
            for(int j=1;j&lt;=n;j++)
            {
                int x=read();
                add_edge(1,calc(n,j),x);
            }
            continue;
        }
        for(int j=1;j&lt;=n;j++)
        {
            int x=read();
            add_edge(calc(i,j),calc(i-1,j),x);
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n+1;j++)
        {
            int x=read();
            if(j==1)
                add_edge(1,calc(i,j),x);
            else
                if(j==n+1)
                    add_edge(calc(i,n),n*n+2,x);
                else
                    add_edge(calc(i,j-1),calc(i,j),x);
        }
    }
    for(int i=1;i&lt;=n+1;i++)
    {
        if(i==1)
        {
            for(int j=1;j&lt;=n;j++)
            {
                int x=read();
                add_edge(n*n+2,calc(1,j),x);
            }
            continue;
        }
        if(i==n+1)
        {
            for(int j=1;j&lt;=n;j++)
            {
                int x=read();
                add_edge(calc(n,j),1,x);
            }
            continue;
        }
        for(int j=1;j&lt;=n;j++)
        {
            int x=read();
            add_edge(calc(i-1,j),calc(i,j),x);
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n+1;j++)
        {
            int x=read();
            if(j==1)
                add_edge(calc(i,j),1,x);
            else
                if(j==n+1)
                    add_edge(n*n+2,calc(i,n),x);
                else
                    add_edge(calc(i,j),calc(i,j-1),x);
        }
    }
}

inline void swap(int x,int y)
{
	int temp=heap1[x];
	heap1[x]=heap1[y];
	heap1[y]=temp;

	temp=heap2[x];
	heap2[x]=heap2[y];
	heap2[y]=temp;

	pl[heap2[x]]=x;
	pl[heap2[y]]=y;
}

inline void heapfy(int x)
{
	int xx=x,minn=heap1[x];

	if((x&lt;&lt;1)&lt;=siz&amp;&amp;heap1[x&lt;&lt;1]&lt;minn)
    {
        xx=x&lt;&lt;1;
        minn=heap1[xx];
    }

	if((x&lt;&lt;1|1)&lt;=siz&amp;&amp;heap1[x&lt;&lt;1|1]&lt;minn)
    {
        xx=x&lt;&lt;1|1;
        minn=heap1[xx];
    }

	if(x!=xx)
	{
		swap(x,xx);
		heapfy(xx);
	}
}

inline void up(int x)
{
	while(x&gt;1)
    {
        if(heap1[x]&lt;heap1[x&gt;&gt;1])
            swap(x,x&gt;&gt;1);
		else
            break;
        x=x&gt;&gt;1;
    }
}

inline void insert(long long x,int y)
{
	heap1[++siz]=x;
	heap2[siz]=y;
	pl[y]=siz;

	up(siz);
}

inline void dijkstra()
{
	for(int i=1;i&lt;=n;i++)dist[i]=inf;
	pl[1]=1;
	heap1[1]=0;
	heap2[1]=1;
	siz=1;

	while(siz)
	{
		int x=heap2[1];
		dist[x]=heap1[1];
		if(x==n)return;

		swap(1,siz--);
		heapfy(1);

		for(int i=g[x];i;i=e[i].next)
			if(dist[e[i].t]==inf)
			{
				int temp=dist[x]+e[i].c;
				if(pl[e[i].t])
				{
					if(temp&lt;heap1[pl[e[i].t]])
					{
						heap1[pl[e[i].t]]=temp;
						up(pl[e[i].t]);
					}
				}
				else
				  insert(temp,e[i].t);
			}
	}
}

int main()
{
    scanf("%d",&amp;n);

    initialize();
    n=n*n+2;
    dijkstra();

    printf("%d\n",dist[n]);

    return 0;
}<pre><h2>Problem2038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,temp;
int color[50010],pos[50010],cnt[50010];

struct size
{
    int l,r,id;
    long long x,y;
}q[50010];

long long gcd(long long a,long long b)
{
    return b==0?a:gcd(b,a%b);
}

inline bool cmp_pl(const size &amp;a,const size &amp;b)
{
    return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;a.r&lt;b.r);
}

inline bool cmp_id(const size &amp;a,const size &amp;b)
{
    return a.id&lt;b.id;
}

inline void add(int x)
{
    temp+=(long long)(cnt[color[x]]&lt;&lt;1);
    cnt[color[x]]++;
}

inline void dec(int x)
{
    cnt[color[x]]--;
    temp-=(long long)(cnt[color[x]]&lt;&lt;1);
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)scanf("%d",color+i);

    for(int i=1;i&lt;=m;i++)
    {
        scanf("%d%d",&amp;q[i].l,&amp;q[i].r);
        q[i].id=i;
    }

    int limit=(int)sqrt(n+0.5);

    for(int i=1;i&lt;=n;i++)
        pos[i]=(i-1)/limit+1;

    sort(q+1,q+m+1,cmp_pl);

    temp=0;
    for(int i=1,l=1,r=0;i&lt;=m;i++)
    {
        if(r&lt;q[i].r)
        {
            for(r++;r&lt;=q[i].r;r++)
                add(r);
            r--;
        }
        if(r&gt;q[i].r)
            for(;r&gt;q[i].r;r--)
                dec(r);
        if(l&lt;q[i].l)
            for(;l&lt;q[i].l;l++)
                dec(l);
        if(l&gt;q[i].l)
        {
            for(l--;l&gt;=q[i].l;l--)
                add(l);
            l++;
        }
        q[i].x=temp;
        if(q[i].x==0)
        {
            q[i].y=1;
            continue;
        }

        q[i].y=(long long)(q[i].r-q[i].l+1)*(q[i].r-q[i].l);
        long long k=gcd(q[i].x,q[i].y);
        q[i].x/=k;
        q[i].y/=k;
    }

    sort(q+1,q+m+1,cmp_id);

    for(int i=1;i&lt;=m;i++)
        printf("%lld/%lld\n",q[i].x,q[i].y);

    return 0;
}
<pre><h2>Problem2039</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;

using namespace std;

const int inf=1000000000;

int n,m,siz=-1,ans;
int ch[1010];
int vh[1010],dis[1010],pre[1010],di[1010],his[1010];

vector&lt;int&gt; g[1010];

struct size
{
    int t,c;
}edge[5000000];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    edge[++siz].t=y;
    edge[siz].c=z;
    ch[x]++;
    g[x].push_back(siz);

    edge[++siz].t=x;
    edge[siz].c=0;
    ch[y]++;
    g[y].push_back(siz);
}

inline int isap()
{
    vh[0]=n;
    int flow=0,aug=inf,i=1;

    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[i]=aug;

        for(int x=di[i];x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]+1==dis[i])
            {
                di[i]=x;
                aug=min(aug,edge[g[i][x]].c);
                flag=true;
                pre[edge[g[i][x]].t]=g[i][x]^1;
                i=edge[g[i][x]].t;

                if(i==n)
                {
                    flow+=aug;

                    while(i!=1)
                    {
                        edge[pre[i]].c+=aug;
                        edge[pre[i]^1].c-=aug;
                        i=edge[pre[i]].t;
                    }

                    aug=inf;
                }

                break;
            }

        if(flag)continue;

        int mi=n,mii;

        for(int x=0;x&lt;ch[i];x++)
            if(edge[g[i][x]].c&amp;&amp;dis[edge[g[i][x]].t]&lt;mi)
                mi=dis[edge[g[i][x]].t],mii=x;

        vh[dis[i]]--;
        if(vh[dis[i]]==0)break;
        dis[i]=mi+1;

        vh[dis[i]]++;
        di[i]=mii;

        if(i!=1)
        {
            i=edge[pre[i]].t;
            aug=his[i];
        }
    }

    return flow;
}

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        add_edge(1,i+1,x);
    }

    for(int i=1;i&lt;=n;i++)
    {
        int temp=0;
        for(int j=1;j&lt;=n;j++)
        {
            int x;
            scanf("%d",&amp;x);
            temp+=x;
            add_edge(i+1,j+1,x*2);
        }
        ans+=temp;
        add_edge(i+1,n+2,temp);
    }
    n+=2;

    printf("%d\n",ans-isap());

    return 0;
}
/*
3
3 5 100
0 6 1
6 0 2
1 2 0
*/
<pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int MAXN=10010;

int ch[MAXN][2],pre[MAXN];
int rev[MAXN];
bool rt[MAXN];

inline void Update_Rev(int x)
{
    if(!x)return;
    swap(ch[x][0],ch[x][1]);
    rev[x]^=1;
}

inline void push_down(int r)
{
    if(rev[r])
    {
        Update_Rev(ch[r][0]);
        Update_Rev(ch[r][1]);
        rev[r]=0;
    }
}

inline void Rotate(int x)
{
    int y=pre[x],kind=ch[y][1]==x;

    ch[y][kind]=ch[x][!kind];
    pre[ch[y][kind]]=y;
    pre[x]=pre[y];
    pre[y]=x;
    ch[x][!kind]=y;
    if(rt[y])
    {
        rt[y]=false;
        rt[x]=true;
    }
    else
        ch[pre[x]][ch[pre[x]][1]==y]=x;
}

inline void P(int r)
{
    if(!rt[r])P(pre[r]);
    push_down(r);
}

inline void Splay(int r)
{
    P(r);
    while(!rt[r])
    {
        int f=pre[r],ff=pre[f];
        if(rt[f])
            Rotate(r);
        else
            if((ch[ff][1]==f)==(ch[f][1]==f))
            {
                Rotate(f);
                Rotate(r);
            }
            else
            {
                Rotate(r);
                Rotate(r);
            }
    }
}

inline int Access(int x)
{
    int y=0;
    while(x)
    {
        Splay(x);
        rt[ch[x][1]]=true;
        rt[ch[x][1]=y]=false;
        x = pre[y=x];
    }
    return y;
}

inline bool judge(int u,int v)
{
    while(pre[u])u=pre[u];
    while(pre[v])v=pre[v];
    return u==v;
}

inline void mroot(int r)
{
    Access(r);
    Splay(r);
    Update_Rev(r);
}

inline void link(int u,int v)
{
    mroot(u);
    pre[u]=v;
}

inline void cut(int u,int v)
{
    mroot(u);
    Splay(v);
    pre[ch[v][0]]=pre[v];
    pre[v]=0;
    rt[ch[v][0]]=true;
    ch[v][0]=0;
}

int main()
{
    int n,m;
    scanf("%d%d",&amp;n,&amp;m);

    for(int i = 0;i &lt;= n;i++)
    {
        pre[i]=0;
        ch[i][0]=0;
        ch[i][1]=0;
        rev[i]=0;
        rt[i]=true;
    }

    while(m--)
    {
        char str[10];
        int u,v;

        scanf("%s%d%d",str,&amp;u,&amp;v);
        if(str[0]=='Q')
        {
            if(judge(u,v))
                printf("Yes\n");
            else
                printf("No\n");
        }
        else
            if(str[0]=='C')
                link(u,v);
            else
                cut(u,v);
    }

    return 0;
}
<pre><h2>Problem2055</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int S=201,s=202,t=203,T=204,N=206;
const int INF=2139062143;

int n,m,cnt=1,ans;
int g[210],in[210];
int dist[210],q[210],v[210],pre[210],flow[210];
struct edge
{
    int t,c,cst,next;
}e[100010];
inline void add_edge(int x,int y,int z1,int z2)
{
    e[++cnt].t=y;
    e[cnt].c=z1;
    e[cnt].cst=z2;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].cst=-z2;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int read()
{
    int temp=0,f=1,c=getchar();
    while((c&lt;48||c&gt;57)&amp;&amp;c!='-')c=getchar();
    if(c=='-'){f=-1;c=getchar();}
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp*f;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline bool spfa()
{
    memset(dist,127,sizeof(dist));
    dist[S]=0;q[1]=S;v[S]=1;flow[S]=INF;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%N+1;
        int x=q[h];
        v[x]=0;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dist[x]+e[i].cst&lt;dist[e[i].t])
            {
                flow[e[i].t]=Min(flow[x],e[i].c);
                dist[e[i].t]=dist[x]+e[i].cst;
                pre[e[i].t]=i^1;
                if(!v[e[i].t])
                {
                    t=t%N+1;
                    v[e[i].t]=1;
                    q[t]=e[i].t;
                }
            }
    }
    return dist[T]!=INF;
}
int main()
{
    n=read();m=read();
    add_edge(S,s,m,0);add_edge(t,T,m,0);
    for(int i=1;i&lt;=n;i++)
    {
        int x=read();
        in[i]-=x;in[i+n]+=x;
        add_edge(s,i,m,0);
        add_edge(i+n,t,m,0);
    }
    for(int i=1;i&lt;n;i++)
        for(int j=i+1;j&lt;=n;j++)
        {
            int x=read();
            if(x!=-1)add_edge(i+n,j,m,x);
        }
    for(int i=1;i&lt;=(n&lt;&lt;1);i++)
        if(in[i]&gt;0)add_edge(S,i,in[i],0);
        else if(in[i]&lt;0)add_edge(i,T,-in[i],0);

    while(spfa())
    {
        ans+=dist[T]*flow[T];
        int x=T;
        while(x!=S)
        {
            e[pre[x]].c+=flow[T];
            e[pre[x]^1].c-=flow[T];
            x=e[pre[x]].t;
        }
    }
    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem2056</h2><pre>#include&lt;cstdio&gt;

using namespace std;

short b[20],cnt;
unsigned long long a[61];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline unsigned long long read1()
{
    char c=getchar();
    unsigned long long temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
    a[0]=1;
    for(int i=1;i&lt;=60;i++)
        a[i]=a[i-1]*2;

    for(int n=read();n;n--)
    {
        unsigned long long ans=0;
        for(int i=1;i&lt;=8;i++)
            ans=ans+a[read()];
        unsigned long long temp=read1();
        ans+=temp;

        if(ans==0)
            printf("18446744073709551616\n");
        else
        {
            cnt=0;
            while(ans!=0)
            {
                b[++cnt]=ans%10;
                ans/=10;
            }
            for(;cnt;cnt--)printf("%d",b[cnt]);
            printf("\n");
        }
    }

	return 0;
}
<pre><h2>Problem2060</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt;
int g[50010];
int f[50010][2];
struct edge
{
    int t,next;
}e[100010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void dfs(int x,int u)
{
    int sum1=1,sum2=0;
    for(int i=g[x];i;i=e[i].next)
    if(e[i].t!=u)
    {
        dfs(e[i].t,x);
        sum1+=f[e[i].t][0];
        sum2+=Max(f[e[i].t][0],f[e[i].t][1]);
    }
    f[x][1]=sum1;
    f[x][0]=sum2;
}

int main()
{
    n=read();
    for(int i=1;i&lt;n;i++)
    {
        int x,y;
        x=read();y=read();
        add_edge(x,y);
        add_edge(y,x);
    }

    dfs(1,0);

    printf("%d\n",Max(f[1][0],f[1][1]));

    return 0;
}
<pre><h2>Problem2083</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;

using namespace std;

int n;
vector&lt;int&gt; v[1000010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
    {
        int x=read();
        v[x].push_back(i);
    }

    for(int m=read();m;m--)
    {
        int N=read(),temp=0;
        vector&lt;int&gt;::iterator it;
        for(int i=1;i&lt;=N;i++)
        {
            int x=read();
            if(temp&gt;n)continue;
            it=lower_bound(v[x].begin(),v[x].end(),temp+1);
            if(it==v[x].end())temp=n+1;
            else temp=*it;
        }
        if(temp&lt;=n)puts("TAK");
        else puts("NIE");
    }

    return 0;
}
<pre><h2>Problem2096</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;

using namespace std;

int n,k,ans;
priority_queue&lt;pair&lt;int,int&gt; &gt;q1,q2;

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}

int main()
{
    k=read();n=read();
    int l=1;
    for(int i=1;i&lt;=n;i++)
    {
        int x=read();
        q1.push(make_pair(x,i));
        q2.push(make_pair(-x,i));
        while(q1.top().first+q2.top().first&gt;k)
        {
            l++;
            while(q1.top().second&lt;l)q1.pop();
            while(q2.top().second&lt;l)q2.pop();
        }
        ans=Max(ans,i-l+1);
    }
    printf("%d\n",ans);
    return 0;
}
<pre><h2>Problem2100</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=2000000000;

int n,m,A,B,C;
int ch[100010],dist[1000010];
int siz,ans;
int heap1[1000010],heap2[1000010],pl[1000010];

struct size
{
	int t,len;
};

vector&lt;size&gt; g[100010];

inline void add_edge(int x,int y,int z)
{
	size temp;
	temp.t=y;
	temp.len=z;
	ch[x]++;
	g[x].push_back(temp);

	temp.t=x;
	ch[y]++;
	g[y].push_back(temp);
}

inline void swap(int x,int y)
{
	int temp=heap1[x];
	heap1[x]=heap1[y];
	heap1[y]=temp;

	temp=heap2[x];
	heap2[x]=heap2[y];
	heap2[y]=temp;

	pl[heap2[x]]=x;
	pl[heap2[y]]=y;
}

inline void heapfy(int x)
{
	int xx=x,minn=heap1[x];

	if((x&lt;&lt;1)&lt;=siz&amp;&amp;heap1[x&lt;&lt;1]&lt;minn)
    {
        xx=x&lt;&lt;1;
        minn=heap1[xx];
    }

	if((x&lt;&lt;1|1)&lt;=siz&amp;&amp;heap1[x&lt;&lt;1|1]&lt;minn)
    {
        xx=x&lt;&lt;1|1;
        minn=heap1[xx];
    }

	if(x!=xx)
	{
		swap(x,xx);
		heapfy(xx);
	}
}

inline void up(int x)
{
	while(x&gt;1)
    {
        if(heap1[x]&lt;heap1[x&gt;&gt;1])
            swap(x,x&gt;&gt;1);
		else
            break;
        x=x&gt;&gt;1;
    }
}

inline void insert(long long x,int y)
{
	heap1[++siz]=x;
	heap2[siz]=y;
	pl[y]=siz;

	up(siz);
}

inline void dijkstra(int X)
{
	for(int i=1;i&lt;=n;i++)dist[i]=inf;
	memset(pl,0,sizeof(pl));
	pl[X]=1;
	heap1[1]=0;
	heap2[1]=X;
	siz=1;

	while(siz)
	{
		int x=heap2[1];
		dist[x]=heap1[1];

		swap(1,siz--);
		heapfy(1);

		for(int i=0;i&lt;ch[x];i++)
			if(dist[g[x][i].t]==inf)
			{
				int temp=dist[x]+g[x][i].len;
				if(pl[g[x][i].t])
				{
					if(temp&lt;heap1[pl[g[x][i].t]])
					{
						heap1[pl[g[x][i].t]]=temp;
						up(pl[g[x][i].t]);
					}
				}
				else
				  insert(temp,g[x][i].t);
			}
	}
}

int main()
{
    scanf("%d%d%d%d%d",&amp;m,&amp;n,&amp;A,&amp;B,&amp;C);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
    }
    dijkstra(A);
    ans=min(dist[B],dist[C]);
    dijkstra(B);
    ans+=dist[C];

    printf("%d\n",ans);

    return 0;
}
<pre><h2>Problem2120</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
#include&lt;iostream&gt;

using namespace std;

bitset&lt;1000010&gt; c;
int n,m,x,y,a[10010],ans;
char str[5];

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",a+i);
	
	for(;m;m--)
	{
		scanf("%s%d%d",str,&amp;x,&amp;y);
		
		if(str[0]=='Q')
		{
			c.reset();
			ans=0;
			
			for(int i=x;i&lt;=y;i++)
				if(!c.test(a[i]))
				{
					ans++;
					c.set(a[i]);
				}
			printf("%d\n",ans);			
		}
		else
			a[x]=y;
	}
	
	return 0;
} <pre><h2>Problem2120</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,cnt,num,size;
int pl[25],pr[25];
int ans[25][25];
int count[25][25][11010];
int data[11010],bel[11010];
int f[1001010];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline int ff(int x)
{
	return f[x]=(!f[x])?++cnt:f[x];
}

inline char read()
{
	char c=getchar();
	while(c!='Q'&amp;&amp;c!='R')c=getchar();
	return c;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
	{
		int x;
		scanf("%d",&amp;x);
		data[i]=ff(x);
	}
	
	while(size*size*size&lt;n)++size;
	size*=size;
	
	for(int l=1,r=min(n,size);l&lt;=n;l=r+1,r=min(r+size,n))
	{
		pl[++num]=l;
		pr[num]=r;
		for(int i=l;i&lt;=r;i++)
			bel[i]=num;
	}
	
	for(int i=1;i&lt;=num;i++)
		for(int j=i;j&lt;=num;j++)
			for(int k=pl[i];k&lt;=pr[j];k++)
				if(1==++count[i][j][data[k]])
					ans[i][j]++;
	pl[0]=-inf;
	pr[0]=0;
    pl[++num]=n+1;
	pr[num]=inf;
	
	for(;m;m--)
	{
		int l,r;
		char c=read();
		scanf("%d%d",&amp;l,&amp;r);
		
		if(c=='Q')
		{
			int ll=bel[l],rr=bel[r];
			if(l&gt;pl[ll])ll++;
			if(r&lt;pr[rr])rr--;
			for(int i=l;i&lt;=min(r,pr[ll-1]);i++)
                if(1==++count[ll][rr][data[i]])ans[ll][rr]++;
            for(int i=max(l,pl[rr+1]);i&lt;=r;i++)
                if(1==++count[ll][rr][data[i]])ans[ll][rr]++;
                
            printf("%d\n",ans[ll][rr]);
            
			for(int i=l;i&lt;=min(r,pr[ll-1]);i++)
                if(!(--count[ll][rr][data[i]]))ans[ll][rr]--;
            for(int i=max(l,pl[rr+1]);i&lt;=r;i++)
                if(!(--count[ll][rr][data[i]]))ans[ll][rr]--;
		}
		else
		{
			int cur=bel[l];
			for(int i=1;i&lt;=cur;i++)
				for(int j=cur;j&lt;=num;j++)
					if(!(--count[i][j][data[l]]))ans[i][j]--;
			for(int i=1;i&lt;=cur;i++)
				for(int j=cur;j&lt;=num;j++)
					if(1==++count[i][j][ff(r)])ans[i][j]++;
			data[l]=ff(r);
		}
	}
	
	return 0;
} <pre><h2>Problem2124</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int p=1000000009;

const int kk=1000000007;

struct arr
{
	int l,r,num;
}seg[40010];

int n,tt;
int s[40010],a[40010],b[40010];

void build(int p,int l,int r)
{
	if (l==r)
	{
		a[l]=p;
		seg[p].l=1;
		seg[p].r=1;
		seg[p].num=1;
		return;
	}
	
	int mid=(l+r)/2;
	
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	
	seg[p].num=seg[p*2].num+seg[p*2+1].num;
	
	seg[p].l=(seg[p*2].l*s[seg[p*2+1].num])+seg[p*2+1].l;
	
	seg[p].r=(seg[p*2+1].r*s[seg[p*2].num])+seg[p*2].r;
}

inline void paint(int x)
{
	seg[a[x]].l=seg[a[x]].r=0;
	
	for (int i=a[x]&gt;&gt;1;i;i&gt;&gt;=1) 
	{
		seg[i].l=((seg[i*2].l*s[seg[i*2+1].num])+seg[i*2+1].l);
		seg[i].r=((seg[i*2+1].r*s[seg[i*2].num])+seg[i*2].r);
	}
}

int get_le(int k,int l,int r,int tl,int tr)
{
	if (tl&lt;=l&amp;&amp;r&lt;=tr)
		return seg[k].l;
	
	int mid=(l+r)/2;
	
	if(mid&lt;tl)
		return get_le(k*2+1,mid+1,r,tl,tr);
	else 
		if(mid&gt;=tr)
			return get_le(k*2,l,mid,tl,tr);
		else
			return (get_le(k*2,l,mid,tl,tr)*s[min(tr,r)-(mid+1)+1]+get_le(k*2+1,mid+1,r,tl,tr));
}

int get_ri(int k,int l,int r,int tl,int tr)
{
	if (tl&lt;=l&amp;&amp;r&lt;=tr)
		return seg[k].r;
	
	int mid=(l+r)/2;
	if(mid&lt;tl)
		return get_ri(k*2+1,mid+1,r,tl,tr);
	else
		if(mid&gt;=tr)
			return get_ri(k*2,l,mid,tl,tr);
	    else
			return (get_ri(k*2+1,mid+1,r,tl,tr)*s[mid-max(tl,l)+1]+get_ri(k*2,l,mid,tl,tr));
}

inline bool check(int x)
{
	int mi=min(x-1,n-x);
	if (mi==0)
		return false;
	
	int ll=get_le(1,1,n,x-mi,x);
	int rr=get_ri(1,1,n,x,mi+x);
	if(ll!=rr)
		return true;
	else
		return false;
}

int main()
{
	scanf("%d",&amp;tt);
	
	s[0]=1;
	for(int i=1;i&lt;=10000;i++)
		s[i]=s[i-1]*kk;
	
	for(;tt;tt--)
	{
		scanf("%d",&amp;n);
		for(int i=1;i&lt;=n;i++)
			scanf("%d",b+i);
		
		bool flag=false;
		build(1,1,n);
		
		for(int i=1;i&lt;=n;i++)
		{
			if (check(b[i]))
			{
				flag=true;
				break;
			}
			paint(b[i]);
		}
		
		if(flag)
			printf("Y\n");
		else
			printf("N\n");
	}
	
	return 0;
}<pre><h2>Problem2127</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,size=-1,ans=0;
int a[110][110][5];
int m1[110][110],m2[110][110],m3[110][110],m4[110][110];
int vh[10010],his[10010],dis[10010],pre[10010];

struct size
{
    int t,c;
}edge[200000];

struct size1
{
    int ch;
    size1 *next;
}*g[10010],*di[10010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    edge[++size].t=y;
    edge[size].c=z;

    size1 *p=new size1;
    p-&gt;ch=size;
    p-&gt;next=g[x];
    g[x]=p;

    edge[++size].t=x;
    edge[size].c=0;

    p=new size1;
    p-&gt;ch=size;
    p-&gt;next=g[y];
    g[y]=p;
}

inline int sap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)
        di[i]=g[i];
	int i=1,aug=inf,flow=0;

	while(dis[1]&lt;n)
	{
		his[i]=aug;
		bool flag=false;
		for(size1 *p=di[i];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&amp;&amp;dis[edge[p-&gt;ch].t]+1==dis[i])
			{
				flag=true;
				di[i]=p;
				aug=min(aug,edge[p-&gt;ch].c);
				pre[edge[p-&gt;ch].t]=p-&gt;ch^1;
				i=edge[p-&gt;ch].t;
				if(i==n)
				{
					flow+=aug;
					while(i!=1)
					{
						edge[pre[i]].c+=aug;
						edge[pre[i]^1].c-=aug;
						i=edge[pre[i]].t;
					}
					aug=inf;
				}
				break;
			}

		if(flag)continue;

		int mi=n-1;
		size1 *p1;

		for(size1 *p=g[i];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&gt;0&amp;&amp;dis[edge[p-&gt;ch].t]&lt;mi)
				p1=p,mi=dis[edge[p-&gt;ch].t];

		di[i]=p1;
		vh[dis[i]]--;
		if(vh[dis[i]]==0)break;

		dis[i]=mi+1;
		vh[dis[i]]++;
		if(i!=1)
		{
			i=edge[pre[i]].t;
			aug=his[i];
		}
	}

	return flow;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf("%d",&amp;a[i][j][0]),ans+=(a[i][j][0]&lt;&lt;=1);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf("%d",&amp;a[i][j][1]),ans+=(a[i][j][1]&lt;&lt;=1);

    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++)
    {
        scanf("%d",&amp;m1[i][j]);
        ans+=m1[i][j]&lt;&lt;1;
    }

    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++)
    {
        scanf("%d",&amp;m2[i][j]);
        ans+=m2[i][j]&lt;&lt;1;
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;m;j++)
    {
        scanf("%d",&amp;m3[i][j]);
        ans+=m3[i][j]&lt;&lt;1;
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;m;j++)
    {
        scanf("%d",&amp;m4[i][j]);
        ans+=m4[i][j]&lt;&lt;1;
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=a[i][j][0];
            if(i&gt;1)x+=m1[i-1][j];
            if(i&lt;n)x+=m1[i][j];
            if(j&gt;1)x+=m3[i][j-1];
            if(j&lt;m)x+=m3[i][j];

            add_edge(1,(i-1)*n+j+1,x);

            x=a[i][j][1];
            if(i&gt;1)x+=m2[i-1][j];
            if(i&lt;n)x+=m2[i][j];
            if(j&gt;1)x+=m4[i][j-1];
            if(j&lt;m)x+=m4[i][j];

            add_edge((i-1)*n+j+1,n*m+2,x);

            if(i&gt;1)add_edge((i-1)*n+j+1,(i-2)*n+j+1,m1[i-1][j]+m2[i-1][j]);

            if(i&lt;n)add_edge((i-1)*n+j+1,i*n+j+1,m1[i][j]+m2[i][j]);

            if(j&gt;1)add_edge((i-1)*n+j+1,(i-1)*n+j,m3[i][j-1]+m4[i][j-1]);

            if(j&lt;m)add_edge((i-1)*n+j+1,(i-1)*n+j+2,m3[i][j]+m4[i][j]);
        }

    n=n*m+2;
    printf("%d\n",(ans-sap())/2);

    return 0;
}
<pre><h2>Problem2127</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,size=-1,ans=0;
int a[110][110][5];
int m1[110][110],m2[110][110],m3[110][110],m4[110][110];
int vh[10010],his[10010],dis[10010],pre[10010];

struct size
{
    int t,c;
}edge[150000];

struct size1
{
    int ch;
    size1 *next;
}*g[10010],*di[10010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    edge[++size].t=y;
    edge[size].c=z;

    size1 *p=new size1;
    p-&gt;ch=size;
    p-&gt;next=g[x];
    g[x]=p;

    edge[++size].t=x;
    edge[size].c=0;

    p=new size1;
    p-&gt;ch=size;
    p-&gt;next=g[y];
    g[y]=p;
}

inline int sap()
{
	vh[0]=n;
	for(int i=1;i&lt;=n;i++)
        di[i]=g[i];
	int i=1,aug=inf,flow=0;

	while(dis[1]&lt;n)
	{
		his[i]=aug;
		bool flag=false;
		for(size1 *p=di[i];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&amp;&amp;dis[edge[p-&gt;ch].t]+1==dis[i])
			{
				flag=true;
				di[i]=p;
				aug=min(aug,edge[p-&gt;ch].c);
				pre[edge[p-&gt;ch].t]=p-&gt;ch^1;
				i=edge[p-&gt;ch].t;
				if(i==n)
				{
					flow+=aug;
					while(i!=1)
					{
						edge[pre[i]].c+=aug;
						edge[pre[i]^1].c-=aug;
						i=edge[pre[i]].t;
					}
					aug=inf;
				}
				break;
			}

		if(flag)continue;

		int mi=n-1;
		size1 *p1;

		for(size1 *p=g[i];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&gt;0&amp;&amp;dis[edge[p-&gt;ch].t]&lt;mi)
				p1=p,mi=dis[edge[p-&gt;ch].t];

		di[i]=p1;
		vh[dis[i]]--;
		if(vh[dis[i]]==0)break;

		dis[i]=mi+1;
		vh[dis[i]]++;
		if(i!=1)
		{
			i=edge[pre[i]].t;
			aug=his[i];
		}
	}

	return flow;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf("%d",&amp;a[i][j][0]),ans+=(a[i][j][0]&lt;&lt;=1);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf("%d",&amp;a[i][j][1]),ans+=(a[i][j][1]&lt;&lt;=1);

    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++)
    {
        scanf("%d",&amp;m1[i][j]);
        ans+=m1[i][j]&lt;&lt;1;
    }

    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++)
    {
        scanf("%d",&amp;m2[i][j]);
        ans+=m2[i][j]&lt;&lt;1;
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;m;j++)
    {
        scanf("%d",&amp;m3[i][j]);
        ans+=m3[i][j]&lt;&lt;1;
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;m;j++)
    {
        scanf("%d",&amp;m4[i][j]);
        ans+=m4[i][j]&lt;&lt;1;
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=a[i][j][0];
            if(i&gt;1)x+=m1[i-1][j];
            if(i&lt;n)x+=m1[i][j];
            if(j&gt;1)x+=m3[i][j-1];
            if(j&lt;m)x+=m3[i][j];

            add_edge(1,(i-1)*n+j+1,x);

            x=a[i][j][1];
            if(i&gt;1)x+=m2[i-1][j];
            if(i&lt;n)x+=m2[i][j];
            if(j&gt;1)x+=m4[i][j-1];
            if(j&lt;m)x+=m4[i][j];

            add_edge((i-1)*n+j+1,n*m+2,x);

            if(i&gt;1)add_edge((i-1)*n+j+1,(i-2)*n+j+1,m1[i-1][j]+m2[i-1][j]);

            if(i&lt;n)add_edge((i-1)*n+j+1,i*n+j+1,m1[i][j]+m2[i][j]);

            if(j&gt;1)add_edge((i-1)*n+j+1,(i-1)*n+j,m3[i][j-1]+m4[i][j-1]);

            if(j&lt;m)add_edge((i-1)*n+j+1,(i-1)*n+j+2,m3[i][j]+m4[i][j]);
        }

    n=n*m+2;
    printf("%d\n",(ans-sap())/2);

    return 0;
}
<pre><h2>Problem2131</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,num;
int tr[100010];
set&lt;int&gt;s;
map&lt;int,int&gt;h;
struct pie
{
    int l,r,v;
    inline friend bool operator&lt;(const pie&amp;a,const pie&amp;b)
    {
        return a.l&gt;b.l||a.l==b.l&amp;&amp;a.r&lt;b.r;
    }
}p[100010];
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}

inline int lowbit(int x)
{
    return x&amp;-x;
}
inline void modify(int x,int val)
{
    for(;x&lt;=num;x+=lowbit(x))
        tr[x]=Max(tr[x],val);
}
inline int query(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp=Max(temp,tr[x]);
    return temp;
}

int main()
{
    n=read();n=read();
    for(int i=1;i&lt;=n;i++)
    {
        int t=read(),pos;pos=read();
        p[i].l=pos-(t&lt;&lt;1);
        p[i].r=pos+(t&lt;&lt;1);
        p[i].v=read();
        s.insert(p[i].r);
    }
    sort(p+1,p+n+1);
    for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)
        h[*it]=++num;

    for(int i=1;i&lt;=n;i++)
    {
        int pos=h[p[i].r];
        modify(pos,query(pos)+p[i].v);
    }
    printf("%d\n",query(num));
    return 0;
}
<pre><h2>Problem2132</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,ans,size=-1;
int c[110][110];
int dis[10010],vh[10010],his[10010],pre[10010];

struct size1
{
    int t,c;
}edge[200000];

struct size2
{
    int ch;
    size2 *next;
}*g[10010],*di[10010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    edge[++size].t=y;
    edge[size].c=z;

    size2 *p=new size2;
    p-&gt;ch=size;
    p-&gt;next=g[x];
    g[x]=p;

    edge[++size].t=x;
    edge[size].c=0;

    p=new size2;
    p-&gt;ch=size;
    p-&gt;next=g[y];
    g[y]=p;
}

inline int sap()
{
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)
        di[i]=g[i];
    int i=1,aug=inf,flow=0;

    while(dis[1]&lt;n)
    {
        his[i]=aug;
        bool flag=false;

        for(size2 *p=di[i];p;p=p-&gt;next)
            if(edge[p-&gt;ch].c&amp;&amp;dis[i]==dis[edge[p-&gt;ch].t]+1)
        {
            flag=true;
            aug=min(aug,edge[p-&gt;ch].c);
            pre[edge[p-&gt;ch].t]=1^p-&gt;ch;
            di[i]=p;
            i=edge[p-&gt;ch].t;

            if(i==n)
            {
                flow+=aug;
                while(i!=1)
                {
                    edge[pre[i]].c+=aug;
                    edge[pre[i]^1].c-=aug;
                    i=edge[pre[i]].t;
                }
                aug=inf;
            }

            break;
        }

        if(flag)continue;

        int mi=n;
        size2 *p1;

        for(size2 *p=g[i];p;p=p-&gt;next)
            if(edge[p-&gt;ch].c&amp;&amp;dis[edge[p-&gt;ch].t]&lt;mi)
                mi=dis[edge[p-&gt;ch].t],p1=p;

        di[i]=p1;
        vh[dis[i]]--;
        if(vh[dis[i]]==0)break;
        dis[i]=mi+1;
        vh[dis[i]]++;

        if(i!=1)
        {
            i=edge[pre[i]].t;
            aug=his[i];
        }
    }

    return flow;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
    {
        int x;
        scanf("%d",&amp;x);
        ans+=x;
        if(((i^j)&amp;1)==1)
            add_edge(1,(i-1)*m+j+1,x);
        else
            add_edge((i-1)*m+j+1,n*m+2,x);
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
    {
        int x;
        scanf("%d",&amp;x);
        ans+=x;
        if(((i^j)&amp;1)==0)
            add_edge(1,(i-1)*m+j+1,x);
        else
            add_edge((i-1)*m+j+1,n*m+2,x);
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
    {
        scanf("%d",&amp;c[i][j]);
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
    {
        if(i&gt;1)
            ans+=c[i][j],add_edge((i-1)*m+j+1,(i-2)*m+j+1,c[i][j]+c[i-1][j]);
        if(i&lt;n)
            ans+=c[i][j],add_edge((i-1)*m+j+1,i*m+j+1,c[i][j]+c[i+1][j]);
        if(j&gt;1)
            ans+=c[i][j],add_edge((i-1)*m+j+1,(i-1)*m+j,c[i][j]+c[i][j-1]);
        if(j&lt;m)
            ans+=c[i][j],add_edge((i-1)*m+j+1,(i-1)*m+j+2,c[i][j]+c[i][j+1]);
    }

    n=n*m+2;
    printf("%d\n",ans-sap());

    return 0;
}
<pre><h2>Problem2132</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int INF=1000000000;

inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int n,m,ans,cnt=1;
int c[110][110];
int g[10010];
int dis[10010],vh[10010],his[10010],pre[10010],di[10010];
struct edge
{
    int t,c,next;
}e[2000000];
inline void add_edge(int x,int y,int z)
{
    //printf("%d %d %d\n",x,y,z);
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int isap()
{
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)di[i]=g[i];
    int x=1,aug=INF,flow=0;

    while(dis[1]&lt;n)
    {
        his[x]=aug;
        bool flag=false;

        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                di[x]=i;
                x=e[i].t;

                if(x==n)
                {
                    flow+=aug;
                    while(x!=1)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;

        int mi=n,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
                mi=dis[e[i].t],mii=i;

        di[x]=mii;
        dis[x]=mi+1;
        vh[dis[x]]++;

        if(x!=1)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }

    return flow;
}

int main()
{
    n=read();m=read();

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            ans+=x;
            if(((i^j)&amp;1)==1)
                add_edge(1,(i-1)*m+j+1,x);
            else
                add_edge((i-1)*m+j+1,n*m+2,x);
        }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            ans+=x;
            if(((i^j)&amp;1)==0)
                add_edge(1,(i-1)*m+j+1,x);
            else
                add_edge((i-1)*m+j+1,n*m+2,x);
        }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            c[i][j]=read();

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            if(i&gt;1)
                ans+=c[i][j],add_edge((i-1)*m+j+1,(i-2)*m+j+1,c[i][j]+c[i-1][j]);
            if(i&lt;n)
                ans+=c[i][j],add_edge((i-1)*m+j+1,i*m+j+1,c[i][j]+c[i+1][j]);
            if(j&gt;1)
                ans+=c[i][j],add_edge((i-1)*m+j+1,(i-1)*m+j,c[i][j]+c[i][j-1]);
            if(j&lt;m)
                ans+=c[i][j],add_edge((i-1)*m+j+1,(i-1)*m+j+2,c[i][j]+c[i][j+1]);
        }

    n=n*m+2;
    printf("%d\n",ans-isap());

    return 0;
}<pre><h2>Problem2140</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;

using namespace std;

const int MAXN=4444,MAXM=22222;

bool v[MAXN];
int idx,cnt;
int dfn[MAXN],low[MAXN],c[MAXN],s[MAXN],sz[MAXN],h[MAXN],p[MAXM],nxt[MAXM];
map&lt;string,int&gt; g,b;
string name;

inline void checkmin(int &amp;x,int y)
{
    if(y&lt;x)x=y;
}

void tarjan(int x)
{
    dfn[x]=low[x]=++idx;
    v[s[++s[0]]=x]=true;

    for(int k=h[x];k;k=nxt[k])
        if(!dfn[p[k]])
        {
            tarjan(p[k]);
            checkmin(low[x],low[p[k]]);
        }
        else
            if(v[p[k]])
                checkmin(low[x],dfn[p[k]]);
    if(dfn[x]==low[x])
    {
        ++cnt;
        do
        {
            ++sz[c[s[s[0]]]=cnt];
            v[s[s[0]]]=false;
        }while(s[s[0]--]!=x);
    }
}

int main()
{
    int n,m;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i)
    {
        cin&gt;&gt;name;
        g[name]=i;
        cin&gt;&gt;name;
        b[name]=i;
    }

    cin&gt;&gt;m;
    for(int i=1;i&lt;=m;++i)
    {
        cin&gt;&gt;name;
        int x=g[name];
        cin&gt;&gt;name;
        p[i]=b[name];
        nxt[i]=h[x];
        h[x]=i;
    }
    for(int i=1;i&lt;=n;++i)
        if(!dfn[i])
            tarjan(i);
    for(int i=1;i&lt;=n;++i)
        cout&lt;&lt;(sz[c[i]]==1?"Safe\n":"Unsafe\n");

    return 0;
}
<pre><h2>Problem2152</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt,sum,root,tot,ans;
int g[20010],siz[20010],f[20010];
int v[20010];
int num[5],Num[5];
struct edge
{
    int t,c,next;
}e[40010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int gcd(int x,int y)
{
    return !y?x:gcd(y,x%y);
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}

inline void get_root(int x,int fa)
{
    siz[x]=1;f[x]=0;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
        {
            get_root(e[i].t,x);
            siz[x]+=siz[e[i].t];
            f[x]=Max(f[x],siz[e[i].t]);
        }
    f[x]=Max(f[x],sum-siz[x]);
    if(f[x]&lt;f[root])root=x;
}
inline void dfs(int x,int y,int fa)
{
    num[y]++;tot++;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs(e[i].t,(y+e[i].c)%3,x);
}
inline void calc(int x)
{
    Num[0]=0;Num[1]=0;Num[2]=0;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            tot=0;
            num[0]=0;num[1]=0;num[2]=0;
            dfs(e[i].t,e[i].c,x);
            siz[e[i].t]=tot;
            ans+=num[0]*Num[0]+num[1]*Num[2]+num[2]*Num[1]+num[0];
            for(int j=0;j&lt;3;j++)Num[j]+=num[j];
        }
}
inline void work(int x)
{
    v[x]=1;calc(x);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            root=0;sum=siz[e[i].t];
            get_root(e[i].t,0);
            work(root);
        }
}

int main()
{
    n=read();
    for(int i=1;i&lt;n;i++)
    {
        int x=read(),y,z;y=read();z=read()%3;
        add_edge(x,y,z);
        add_edge(y,x,z);
    }
    f[0]=sum=n;
    get_root(1,0);
    work(root);

    ans=ans*2+n;
    int temp=gcd(ans,n*n);
    printf("%d/%d\n",ans/temp,n*n/temp);

    return 0;
}
<pre><h2>Problem2190</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

bitset&lt;50000&gt; c;
long long phi[50000],ans;
int n,num;
int prm[50000];

int main()
{
	scanf("%d",&amp;n);
	
	if(n==1)
	{
		printf("0\n");
		return 0;
	}
	for(int i=2;i&lt;=n;i++)
	{
		if(!c.test(i))
		{
			phi[i]=i-1;
			prm[++num]=i;
		}
		for(int j=1;j&lt;=num&amp;&amp;prm[j]*i&lt;=n;j++)
		{
			c.set(prm[j]*i);
			if(i%prm[j]==0)
			{
				phi[i*prm[j]]=phi[i]*prm[j];
				break;
			}
			phi[i*prm[j]]=phi[i]*(prm[j]-1);
		}
	}
	phi[1]=1;
	for(int i=2;i&lt;=n;i++)
		phi[i]+=phi[i-1];
	
	printf("%lld\n",phi[n-1]*2+1);
	
	return 0;
}</pre><pre></pre><h2>Problem2208</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,ans;
int ch[2010],ch1[2010][2010];
bool v[2010];

inline bool read()
{
	char c=getchar();
	while(c!='0'&amp;&amp;c!='1')c=getchar();
	return c=='1';
}

int search(int x)
{
	int temp=0;
	v[x]=false;
	
	for(int i=1;i&lt;=ch[x];i++)
		if(v[ch1[x][i]])
			temp+=search(ch1[x][i]);
	
	return temp+1;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(read())
				ch1[i][++ch[i]]=j;
	
	for(int i=1;i&lt;=n;i++)
	{
		memset(v,true,sizeof(v));
		ans+=search(i);
	}
	
	printf("%d\n",ans);
	
	return 0;			 
}</pre><pre></pre><h2>Problem2208</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,ans,num;
int ch[2010],ch1[2010][2010];
bool v[2010];

inline bool read()
{
	char c=getchar();
	while(c!='0'&amp;&amp;c!='1')c=getchar();
	return c=='1';
}

int search(int x)
{
	int temp=0;
	v[x]=false;
	num--;
	
	for(int i=1;i&lt;=ch[x];i++)
	{
		if(temp==num)return temp+1;
		if(v[ch1[x][i]])
			temp+=search(ch1[x][i]),num++;
	}
	
	return temp+1;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(read())
				ch1[i][++ch[i]]=j;
	
	for(int i=1;i&lt;=n;i++)
	{
		memset(v,true,sizeof(v));
		num=n;
		ans+=search(i);
	}
	
	printf("%d\n",ans);
	
	return 0;			 
}</pre><pre></pre><h2>Problem2241</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1e9;

int n,m,s,ans=inf;
int c[105];
int a[105][105],b[105][105];

inline void check(int x,int y)
{
	memset(c,0,sizeof(c));
	
	for(int i=1;i&lt;=n;i++)
	{
		int t=0;
		
		for(int j=1;j&lt;=m;j++)
		{
			if(j&gt;y)
				if(i&gt;x)
					t-=b[i][j-y]-b[i-x][j-y];
				else
					t-=b[i][j-y];
			
			if(i&gt;x)
				t-=b[i-x][j];
			
			c[j]+=t;
			
			b[i][j]=a[i][j]-c[j];
			
			if(b[i][j]&lt;0)return;
			
			t+=b[i][j];
			c[j]+=b[i][j];
		}
	}
	
	ans=s/x/y;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
		{
			scanf("%d",&amp;a[i][j]);
			s+=a[i][j];
		}
	
	for(int i=1;i&lt;=n;i++)
		if(s%i==0)
			for(int j=1;j&lt;=m;j++)
				if(s%(i*j)==0&amp;&amp;(s/i/j&lt;ans))
					check(i,j);
	
	printf("%d\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem2245</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1e9;

int n,m,kk,size=-1;
long long ans=0;
int t[10];
int que[610],dist[610],flow[610],pre[610];

bitset&lt;610&gt; inque;

struct size
{
    int y,c,fe;
}edge[80010];

struct size1
{
	int num;
	size1 *next;
}*g[610];

inline void add_edge(int x,int y,int z,int num)
{
	edge[++size].y=y;
	edge[size].c=z;
	edge[size].fe=num;

	size1 *p=new size1;
	p-&gt;num=size;
	p-&gt;next=g[x];
	g[x]=p;

	edge[++size].y=x;
	edge[size].c=0;
	edge[size].fe=-num;

	p=new size1;
	p-&gt;num=size;
	p-&gt;next=g[y];
	g[y]=p;
}

inline bool spfa()
{
    inque.reset();
    for(int i=1;i&lt;=n;i++)
		dist[i]=flow[i]=inf;

	int h=0,t=1;
	que[1]=1;
	flow[1]=inf;
	dist[1]=0;
	inque.set(1);

	while(h!=t)
	{
		h=h%n+1;
		int x=que[h];
		inque.flip(x);

		for(size1 *p=g[x];p;p=p-&gt;next)
			if(edge[p-&gt;num].c&amp;&amp;dist[x]+edge[p-&gt;num].fe&lt;dist[edge[p-&gt;num].y])
			{
				dist[edge[p-&gt;num].y]=dist[x]+edge[p-&gt;num].fe;
				pre[edge[p-&gt;num].y]=1^p-&gt;num;
				flow[edge[p-&gt;num].y]=min(flow[x],edge[p-&gt;num].c);

				if(!inque.test(edge[p-&gt;num].y))
				{
					inque.set(edge[p-&gt;num].y);
					t=t%n+1;
					que[t]=edge[p-&gt;num].y;
				}
			}
	}

	return dist[n]!=inf;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);

	for(int i=1;i&lt;=m;i++)
    {
        int x;
        scanf("%d",&amp;x);

        add_edge(1,i+1,x,0);
    }
	
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
		{
			int x;
			
			scanf("%d",&amp;x);
			
			if(x)
				add_edge(j+1,i+1+m,inf,0);
		}
	
	for(int i=1;i&lt;=n;i++)
	{
		int x;
		scanf("%d",&amp;x);
		
		t[0]=0;
		for(int j=1;j&lt;=x;j++)
			scanf("%d",t+j);
		t[x+1]=inf;
		
		for(int j=1;j&lt;=x+1;j++)
		{
			int y;
			scanf("%d",&amp;y);
			
			add_edge(i+m+1,n+m+2,t[j]-t[j-1],y);
		}
	}
	
	n=n+m+2;

	while(spfa())
	{
		ans+=dist[n]*flow[n];

		for(int i=n;i!=1;i=edge[pre[i]].y)
		{
			edge[pre[i]].c+=flow[n];
			edge[pre[i]^1].c-=flow[n];
		}
	}

	printf("%lld\n",ans);

	return 0;
}</pre><pre></pre><h2>Problem2257</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,k,cnt;
int c[10000000];

int main()
{
    scanf("%d%d",&amp;n,&amp;k);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);

        for(int j=1;j*j&lt;=x;j++)
            if(x%j==0)
        {
            c[++cnt]=j;
            if(j*j!=x)
                c[++cnt]=x/j;
        }
    }

    sort(c+1,c+cnt+1);

    int h=cnt;

    while(h&gt;=1)
    {
        int temp=1;
        while(c[h]==c[h-1])
        {
            h--;
            temp++;
        }
        if(temp&gt;=k)
        {
            printf("%d\n",c[h]);
            return 0;
        }
        h--;
    }

    return 0;
}
</pre><pre></pre><h2>Problem2295</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n;
char str[10]={'l','u','v','l','e','t','t','e','r'};
char ch;

inline int read()
{
  int c=getchar(),temp=0;
  while(c&lt;48||c&gt;57)c=getchar();
  while(c&gt;=48&amp;&amp;c&lt;=57)
    {
      temp=temp*10+c-48;
      c=getchar();
    }
  return temp;
}

int main()
{
  n=read();

  for(;n;n--)
    {
      ch=getchar();
      int now=0,ans=0;
      while(ch!='\n')
	{
	  if(ch==str[now])now++;
	  if(now==9){ans++;now=0;}
	  ch=getchar();
	}
      printf("%d\n",ans);
    }

  return 0;
}
</pre><pre></pre><h2>Problem2301</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int a,b,c,d,T,k;
bool v[50010];
int sum[50010],u[50010],prime[50010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}
inline void swap(int &amp;a,int &amp;b)
{
    a^=b^=a^=b;
}

inline void getmu()
{
	u[1]=1;
	for(int i=2;i&lt;=50000;i++)
	{
		if(!v[i])
        {
			prime[++prime[0]]=i;
			u[i]=-1;
		}
		for(int j=1;j&lt;=prime[0];j++)
        {
			if(i*prime[j]&gt;50000)break;
			v[i*prime[j]]=1;
			if(i%prime[j])
				u[i*prime[j]]=-u[i];
			else
            {
				u[i*prime[j]]=0;
				break;
			}
		}
	}

	sum[0]=0;
	for(int i=1;i&lt;=50000;i++)sum[i]=sum[i-1]+u[i];
}

inline int work(int X,int Y)
{
	int ans=0;
	int n=min(X,Y);
	for(int i=1;i&lt;=n;)
    {
		int temp=min(X/(X/i),Y/(Y/i));
		ans+=(sum[temp]-sum[i-1])*(X/i)*(Y/i);
		i=temp+1;
	}
	return ans;
}

int main()
{
    getmu();

	for(scanf("%d",&amp;T);T;T--)
    {
		scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);
		a--;c--;
		a/=k;b/=k;c/=k;d/=k;
		int temp=work(b,d)-work(a,d)-work(b,c)+work(a,c);
		printf("%d\n",temp);
	}

	return 0;
}
</pre><pre></pre><h2>Problem2324</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int s=1,t=303,S=304,T=305,N=307;
const int INF=2139062143;

int n,m,K,cnt=1,ans;
int g[310];
int dist[310],q[310],v[310],pre[310],flow[310];
int G[160][160];
struct edge
{
    int t,c,cst,next;
}e[100010];
inline void add_edge(int x,int y,int z1,int z2)
{
    e[++cnt].t=y;
    e[cnt].c=z1;
    e[cnt].cst=z2;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].cst=-z2;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline bool spfa()
{
    memset(dist,127,sizeof(dist));
    dist[S]=0;q[1]=S;v[S]=1;flow[S]=INF;
    int h=0,t=1;

    while(h!=t)
    {
        h=h%N+1;
        int x=q[h];
        v[x]=0;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&gt;0&amp;&amp;dist[x]+e[i].cst&lt;dist[e[i].t])
            {
                flow[e[i].t]=Min(flow[x],e[i].c);
                dist[e[i].t]=dist[x]+e[i].cst;
                pre[e[i].t]=i^1;
                if(!v[e[i].t])
                {
                    v[e[i].t]=1;
                    t=t%N+1;
                    q[t]=e[i].t;
                }
            }
    }
    return dist[T]!=INF;
}

int main()
{
    n=read();m=read();K=read();
    memset(G,127,sizeof(G));
    for(int i=1;i&lt;=m;i++)
    {
        int x=read(),y,z;y=read();z=read();
        G[x][y]=Min(G[x][y],z);
        G[y][x]=G[x][y];
    }

    for(int k=0;k&lt;=n;k++)
		for(int i=0;i&lt;=n;i++)
			for(int j=0;j&lt;=n;j++)
                if((k&lt;=i||k&lt;=j)&amp;&amp;G[i][k]!=INF&amp;&amp;G[k][j]!=INF)
					G[i][j]=Min(G[i][j],G[i][k]+G[k][j]);

    add_edge(S,1,K,0);
    for(int i=1;i&lt;=n;i++)
	{
		add_edge(S,i&lt;&lt;1|1,1,0);
		add_edge(i&lt;&lt;1,T,1,0);

		for(int j=0;j&lt;i;j++)
            if(G[j][i]!=INF)
                add_edge(j&lt;&lt;1|1,i&lt;&lt;1,1,G[j][i]);
	}

    while(spfa())
    {
        ans+=flow[T]*dist[T];
        int x=T;
        while(x!=S)
        {
            e[pre[x]].c+=flow[T];
            e[pre[x]^1].c-=flow[T];
            x=e[pre[x]].t;
        }
    }
    printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem2346</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;

using namespace std;

const int inf=1000000000;

int n,m;
int ch[260010],dist[260010];
int siz;
int heap1[260010],heap2[260010],pl[260010];

struct size
{
	int t,len;
};

vector&lt;size&gt; g[260010];

inline void add_edge(int x,int y,int z)
{
    //printf("%d %d %d\n",x,y,z);
	size temp;
	temp.t=y;
	temp.len=z;
	ch[x]++;
	g[x].push_back(temp);

	temp.t=x;
	ch[y]++;
	g[y].push_back(temp);
}

inline void swap(int x,int y)
{
	int temp=heap1[x];
	heap1[x]=heap1[y];
	heap1[y]=temp;

	temp=heap2[x];
	heap2[x]=heap2[y];
	heap2[y]=temp;

	pl[heap2[x]]=x;
	pl[heap2[y]]=y;
}

inline void heapfy(int x)
{
	int xx=x,minn=heap1[x];

	if((x&lt;&lt;1)&lt;=siz&amp;&amp;heap1[x&lt;&lt;1]&lt;minn)
    {
        xx=x&lt;&lt;1;
        minn=heap1[xx];
    }

	if((x&lt;&lt;1|1)&lt;=siz&amp;&amp;heap1[x&lt;&lt;1|1]&lt;minn)
    {
        xx=x&lt;&lt;1|1;
        minn=heap1[xx];
    }

	if(x!=xx)
	{
		swap(x,xx);
		heapfy(xx);
	}
}

inline void up(int x)
{
	while(x&gt;1)
    {
        if(heap1[x]&lt;heap1[x&gt;&gt;1])
            swap(x,x&gt;&gt;1);
		else
            break;
        x=x&gt;&gt;1;
    }
}

inline void insert(long long x,int y)
{
	heap1[++siz]=x;
	heap2[siz]=y;
	pl[y]=siz;

	up(siz);
}

inline void dijkstra()
{
	for(int i=1;i&lt;=n;i++)dist[i]=inf;
	pl[1]=1;
	heap1[1]=0;
	heap2[1]=1;
	siz=1;

	while(siz)
	{
		int x=heap2[1];
		dist[x]=heap1[1];
		if(x==n)return;

		swap(1,siz--);
		heapfy(1);

		for(int i=0;i&lt;ch[x];i++)
			if(dist[g[x][i].t]==inf)
			{
				int temp=dist[x]+g[x][i].len;
				if(pl[g[x][i].t])
				{
					if(temp&lt;heap1[pl[g[x][i].t]])
					{
						heap1[pl[g[x][i].t]]=temp;
						up(pl[g[x][i].t]);
					}
				}
				else
				  insert(temp,g[x][i].t);
			}
	}
}

inline int read()
{
    char c=getchar();
    while(c!='\\'&amp;&amp;c!='/')
        c=getchar();
    return c=='/'?1:0;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	m++;
	for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;m;j++)
            if(read())
            {
                add_edge((i-1)*m+j+1,i*m+j,0);
                add_edge((i-1)*m+j,i*m+j+1,1);
            }
            else
            {
                add_edge((i-1)*m+j+1,i*m+j,1);
                add_edge((i-1)*m+j,i*m+j+1,0);
            }
    }

    n=(n+1)*m;

	dijkstra();

	if(dist[n]==inf)
        printf("NO SOLUTION\n");
    else
        printf("%d\n",dist[n]);

	return 0;
}
</pre><pre></pre><h2>Problem2346</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;

using namespace std;

const int inf=1000000000;

int n,m;
int ch[260010],que[260010];
int dist[260010];
bool inque[260010];

struct size
{
    int t,len;
};

vector&lt;size&gt; g[260010];

inline void add_edge(int x,int y,int z)
{
    size temp;
    temp.t=y;
    temp.len=z;
    ch[x]++;
    g[x].push_back(temp);

    temp.t=x;
    ch[y]++;
    g[y].push_back(temp);
}

inline void spfa()
{
    for(int i=1;i&lt;=n;i++)dist[i]=inf;
    dist[1]=0;
    que[1]=1;
    inque[1]=true;
    int h=0,t=1;

    while(h!=t)
    {
        if(h==n)h=0;
        h++;
        int x=que[h];

        for(int i=0;i&lt;ch[x];i++)
            if(dist[x]+g[x][i].len&lt;dist[g[x][i].t])
        {
            dist[g[x][i].t]=dist[x]+g[x][i].len;

            if(!inque[g[x][i].t])
            {
                if(t==n)t=0;
                t++;
                que[t]=g[x][i].t;
                inque[que[t]]=true;
            }
        }
        inque[x]=false;
    }
}

inline int read()
{
    char c=getchar();
    while(c!='\\'&amp;&amp;c!='/')
        c=getchar();
    return c=='/'?1:0;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	m++;
	for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;m;j++)
            if(read())
            {
                add_edge((i-1)*m+j+1,i*m+j,0);
                add_edge((i-1)*m+j,i*m+j+1,1);
            }
            else
            {
                add_edge((i-1)*m+j+1,i*m+j,1);
                add_edge((i-1)*m+j,i*m+j+1,0);
            }
    }

    n=(n+1)*m;

	spfa();

	if(dist[n]==inf)
        printf("NO SOLUTION\n");
    else
        printf("%d\n",dist[n]);

	return 0;
}
</pre><pre></pre><h2>Problem2396</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;
int t[1010],a1[1010],b1[1010],c1[1010];
int a[1010][1010],b[1010][1010],c[1010][1010];
bool flag;

int main()
{
	while(scanf("%d",&amp;n)!=EOF)
	{
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				scanf("%d",&amp;a[i][j]);
				
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				scanf("%d",&amp;b[i][j]);
		
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				scanf("%d",&amp;c[i][j]);
		
		flag=true;
		
		for(int i=1;i&lt;=10;i++)
		{
			for(int j=1;j&lt;=n;j++)
				t[j]=rand()%1000;
		
			for(int j=1;j&lt;=n;j++)
			{
				b1[j]=0;
				for(int k=1;k&lt;=n;k++)
					b1[j]+=t[k]*b[j][k];
			}
		
			for(int j=1;j&lt;=n;j++)
			{
				a1[j]=0;
				for(int k=1;k&lt;=n;k++)
					a1[j]+=b1[k]*a[j][k];
			}
		
			for(int j=1;j&lt;=n;j++)
			{
				c1[j]=0;
				for(int k=1;k&lt;=n;k++)
					c1[j]+=t[k]*c[j][k];
			}
		
			for(int j=1;j&lt;=n;j++)
				if(a1[j]!=c1[j])
				{
					flag=false;
					break;
				}
			if(flag)break;
		}
	
		if(flag)
			printf("Yes\n");
		else
			printf("No\n");
	}
	return 0;
}</pre><pre></pre><h2>Problem2424</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1e9;

int n,m,s,num=-1,ans;
int pre[60],flow[60];
int que[60],dist[60];

bitset&lt;60&gt; inque;

struct size
{
	int ch;
	size *next;
}*g[60];

struct edge1
{
	int t,c,fe;
}edge[200];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int c,int fe)
{
	edge[++num].t=y;
	edge[num].c=c;
	edge[num].fe=fe;
	
	size *p=new size;
	p-&gt;ch=num;
	p-&gt;next=g[x];
	g[x]=p;
	
	edge[++num].t=x;
	edge[num].c=0;
	edge[num].fe=-fe;
	
	p=new size;
	p-&gt;ch=num;
	p-&gt;next=g[y];
	g[y]=p;
}

inline bool spfa()
{
	for(int i=1;i&lt;=n;i++)
		dist[i]=flow[i]=inf;
	
	inque.reset();
	dist[1]=0;
	que[1]=1;
	int h=0,t=1;
	inque.set(1);
	
	while(h!=t)
	{
		h=h%n+1;
		int x=que[h];
		inque.flip(x);
		
		for(size *p=g[x];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&amp;&amp;dist[x]+edge[p-&gt;ch].fe&lt;dist[edge[p-&gt;ch].t])
			{
				dist[edge[p-&gt;ch].t]=dist[x]+edge[p-&gt;ch].fe;
				flow[edge[p-&gt;ch].t]=min(flow[x],edge[p-&gt;ch].c);
				pre[edge[p-&gt;ch].t]=1^p-&gt;ch;
				
				if(!inque.test(edge[p-&gt;ch].t))
				{
					t=t%n+1;
					inque.set(edge[p-&gt;ch].t);
					que[t]=edge[p-&gt;ch].t;
				}
			}
	}
	
	return dist[n]!=inf;
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;s);
	
	for(int i=1;i&lt;=n;i++)
	{
		int x;
		scanf("%d",&amp;x);
		
		add_edge(i+1,n+2,x,0);
	}
	
	for(int i=1;i&lt;n;i++)
		add_edge(i+1,i+2,s,m);
		
	for(int i=1;i&lt;=n;i++)
	{
		int x;
		scanf("%d",&amp;x);
		
		add_edge(1,i+1,inf,x);
	}
	
	n+=2;
	
	while(spfa())
	{
		ans+=flow[n]*dist[n];
		
		for(int i=n;i!=1;i=edge[pre[i]].t)
		{
			edge[pre[i]].c+=flow[n];
			edge[pre[i]^1].c-=flow[n];
		}
	}
	
	printf("%d\n",ans);
	
	return 0;
} </pre><pre></pre><h2>Problem2426</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int inf=1e9;

int n,m,hh,b;
int fans=inf,ians;
int h[50010],c1[50010],c2[50010];
int a[50010],p[50010];

inline bool cmp(int x,int y)
{
	return (c1[x]-c2[x])&lt;(c1[y]-c2[y]);
}

int main()
{
	scanf("%d%d%d%d",&amp;m,&amp;b,&amp;hh,&amp;n);
	
	for(int i=1;i&lt;=m;i++)
		scanf("%d",a+i);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",h+i);
	
	for(int i=1;i&lt;=m;i++)
		scanf("%d",c1+i);
	
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=1;j&lt;=m;j++)
			p[j]=j,scanf("%d",c2+j);
		
		sort(p+1,p+m+1,cmp);
		
		int temp=b,ans=0;
			
		int kk=1;
		for(;kk&lt;=m;kk++)
			if(a[p[kk]]&lt;=temp)
			{
				ans+=c1[p[kk]]*a[p[kk]];
				temp-=a[p[kk]];
			}
			else
				break;
		
		ans+=c1[p[kk]]*temp+c2[p[kk]]*(a[p[kk]]-temp);
		kk++;
		
		for(;kk&lt;=m;kk++)
			ans+=c2[p[kk]]*a[p[kk]];
		
		if(ans+hh+h[i]&lt;fans)
		{
			ians=i;
			fans=ans+hh+h[i];
		}
	}
	
	printf("%d\n%d\n",ians,fans);
	
	return 0;
}</pre><pre></pre><h2>Problem2427</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1e9;

int n,m,idx,top,num;
int v[110],w[110];
int bel[110],nv[110],nw[110],fa[110];
int f[110][510];
int low[110],dfn[110],stack[110];

bitset&lt;110&gt; instack,vis;

struct size
{
	int ch;
	size *next;
}*tr[110],*tr1[110];

struct size1
{
	int s,t;
}edge[110];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline void add_edge(int x,int y)
{
	fa[y]=x;
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=tr[x];
	tr[x]=p;
}

inline void add_edge1(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=tr1[x];
	tr1[x]=p;
}

void tarjan(int x)
{
	low[x]=dfn[x]=++idx;
	stack[++top]=x;
	instack.set(x);
	
	for(size *p=tr1[x];p;p=p-&gt;next)
		if(!dfn[p-&gt;ch])
		{
			tarjan(p-&gt;ch);
			low[x]=min(low[x],low[p-&gt;ch]);
		}
		else
			if(instack.test(p-&gt;ch))
				low[x]=min(low[x],dfn[p-&gt;ch]);
	
	instack.flip(x);
	
	if(dfn[x]==low[x])
	{
		++num;
		while(stack[top]!=x)
			bel[stack[top--]]=num;
		bel[stack[top--]]=num;
	}
}

void dfs(int x)
{
	vis.set(x);
	
	for(int i=nw[x];i&lt;=m;i++)
		f[x][i]=nv[x];
	
	for(size *p=tr[x];p;p=p-&gt;next)
		if(!vis.test(p-&gt;ch))
		{
			dfs(p-&gt;ch);
			
			for(int i=m;i&gt;nw[x];i--)
				for(int j=1;j&lt;=i-nw[x];j++)
					f[x][i]=max(f[x][i],f[x][i-j]+f[p-&gt;ch][j]);
		}
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",w+i);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",v+i);
	
	for(int i=1;i&lt;=n;i++)
	{
		int x;
		
		scanf("%d",&amp;x);
		
		edge[i].s=x;
		edge[i].t=i;
		add_edge1(x,i);
	}
	
	for(int i=0;i&lt;=n;i++)
		if(!dfn[i])
			tarjan(i);

	for(int i=0;i&lt;=n;i++)
		fa[bel[i]]=bel[i];

	for(int i=1;i&lt;=n;i++)
	{
		nw[bel[i]]+=w[i];
		nv[bel[i]]+=v[i];
		
		if(bel[edge[i].s]!=bel[edge[i].t])
			add_edge(bel[edge[i].s],bel[edge[i].t]);
	}

	for(int i=1;i&lt;=n;i++)
	{
		int x=bel[i];
		while(fa[x]!=x)
			x=fa[x];
		if(x!=bel[0])
			add_edge(bel[0],x);
	}
	
	int root=bel[0];
	
	dfs(root);

	printf("%d\n",f[root][m]);
	
	return 0;
}</pre><pre></pre><h2>Problem2429</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
#include&lt;cmath&gt;

using namespace std;

int n,m,ans=0;
int jump[510];
double dist[1010];

struct size
{
	int x,y;
}dot[1010];

inline int f(int x)
{
	return x*x;
}

inline double calc(int x,int y)
{
	return (double)sqrt(f(dot[x].x-dot[y].x)+f(dot[x].y-dot[y].y));
}

inline double min(double x,double y)
{
	return x&lt;y?x:y;
}

inline double prim()
{
	double temp=0.0;
	bitset&lt;1010&gt; v;
	v.reset();
	
	v.set(1);
	
	for(int i=1;i&lt;=n;i++)
		dist[i]=calc(1,i);
	
	for(int i=2;i&lt;=n;i++)
	{
		int k=0;
		double mi=(double)10000.0;
		
		for(int j=1;j&lt;=n;j++)
			if(!v.test(j)&amp;&amp;dist[j]&lt;mi)
				mi=dist[k=j];
		
		if(mi&gt;temp)temp=mi;
		v.set(k);
		
		for(int j=1;j&lt;=n;j++)
			if(!v.test(j))
				dist[j]=min(dist[j],calc(k,j));
	}
	return temp;
}

int main()
{
	scanf("%d",&amp;m);
	
	for(int i=1;i&lt;=m;i++)
		scanf("%d",jump+i);
	
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;dot[i].x,&amp;dot[i].y);
	
	double temp=prim();
	
	for(int i=1;i&lt;=m;i++)
		if((double)jump[i]&gt;=temp)
			ans++;
	
	printf("%d\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem2435</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n;
int fal[1000010];
long long ans=0;

bitset&lt;1000010&gt; v;

struct size
{
	int ch,len;
	size *next;
}*g[1000010];

inline int abs(int x)
{
	return x&gt;0?x:-x;
}

inline void add_edge(int x,int y,int z)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=g[x];
	g[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;len=z;
	p-&gt;next=g[y];
	g[y]=p;
}

inline void dfs1(int x)
{
	v.set(x);
	for(size *p=g[x];p;p=p-&gt;next)
		if(!v.test(p-&gt;ch))
		{
			fal[p-&gt;ch]=p-&gt;len;
			dfs1(p-&gt;ch);
		}
}

inline int dfs2(int x)
{
	v.set(x);
	int num=1;
	
	for(size *p=g[x];p;p=p-&gt;next)
		if(!v.test(p-&gt;ch))
			v.set(p-&gt;ch),num+=dfs2(p-&gt;ch);
	
	ans+=(long long)abs((n-num*2))*fal[x];
	
	return num;
}

int main()
{
	scanf("%d",&amp;n);
	
	for(int i=1;i&lt;n;i++)
	{
		int x,y,z;
		
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		add_edge(x,y,z);
	}
	
	v.reset();
	dfs1(1);
	
	v.reset();
	int k=dfs2(1);
	
	printf("%lld\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem2442</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;
const long long Inf=(long long)inf*inf;

int n,k;
long long sum=0;
int q[100010];
long long a[100010],f[100010];

inline long long min(long long a,long long b)
{
    return a&lt;b?a:b;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;k);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%lld",a+i);
        sum+=a[i];
    }

    int h=1,t=1;
    q[1]=0;
    for(int i=1;i&lt;=n;i++)
    {
        while(q[h]+k+1&lt;i)h++;
        f[i]=f[q[h]]+a[i];
        while(h&lt;=t&amp;&amp;f[i]&lt;=f[q[t]])t--;
        q[++t]=i;
    }

    long long ans=Inf;
    for(int i=n-k;i&lt;=n;i++)
        ans=min(ans,f[i]);
    printf("%lld\n",sum-ans);

    return 0;
}
</pre><pre></pre><h2>Problem2453</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
#include&lt;iostream&gt;

using namespace std;

bitset&lt;1000010&gt; c;
int n,m,x,y,a[10010],ans;
char str[5];

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",a+i);
	
	for(;m;m--)
	{
		scanf("%s%d%d",str,&amp;x,&amp;y);
		
		if(str[0]=='Q')
		{
			c.reset();
			ans=0;
			
			for(int i=x;i&lt;=y;i++)
				if(!c.test(a[i]))
				{
					ans++;
					c.set(a[i]);
				}
			printf("%d\n",ans);			
		}
		else
			a[x]=y;
	}
	
	return 0;
} </pre><pre></pre><h2>Problem2453</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,cnt,num,size;
int pl[25],pr[25];
int ans[25][25];
int count[25][25][11010];
int data[11010],bel[11010];
int f[1001010];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline int ff(int x)
{
	return f[x]=(!f[x])?++cnt:f[x];
}

inline char read()
{
	char c=getchar();
	while(c!='Q'&amp;&amp;c!='R')c=getchar();
	return c;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
	{
		int x;
		scanf("%d",&amp;x);
		data[i]=ff(x);
	}
	
	while(size*size*size&lt;n)++size;
	size*=size;
	
	for(int l=1,r=min(n,size);l&lt;=n;l=r+1,r=min(r+size,n))
	{
		pl[++num]=l;
		pr[num]=r;
		for(int i=l;i&lt;=r;i++)
			bel[i]=num;
	}
	
	for(int i=1;i&lt;=num;i++)
		for(int j=i;j&lt;=num;j++)
			for(int k=pl[i];k&lt;=pr[j];k++)
				if(1==++count[i][j][data[k]])
					ans[i][j]++;
	pl[0]=-inf;
	pr[0]=0;
    pl[++num]=n+1;
	pr[num]=inf;
	
	for(;m;m--)
	{
		int l,r;
		char c=read();
		scanf("%d%d",&amp;l,&amp;r);
		
		if(c=='Q')
		{
			int ll=bel[l],rr=bel[r];
			if(l&gt;pl[ll])ll++;
			if(r&lt;pr[rr])rr--;
			for(int i=l;i&lt;=min(r,pr[ll-1]);i++)
                if(1==++count[ll][rr][data[i]])ans[ll][rr]++;
            for(int i=max(l,pl[rr+1]);i&lt;=r;i++)
                if(1==++count[ll][rr][data[i]])ans[ll][rr]++;
                
            printf("%d\n",ans[ll][rr]);
            
			for(int i=l;i&lt;=min(r,pr[ll-1]);i++)
                if(!(--count[ll][rr][data[i]]))ans[ll][rr]--;
            for(int i=max(l,pl[rr+1]);i&lt;=r;i++)
                if(!(--count[ll][rr][data[i]]))ans[ll][rr]--;
		}
		else
		{
			int cur=bel[l];
			for(int i=1;i&lt;=cur;i++)
				for(int j=cur;j&lt;=num;j++)
					if(!(--count[i][j][data[l]]))ans[i][j]--;
			for(int i=1;i&lt;=cur;i++)
				for(int j=cur;j&lt;=num;j++)
					if(1==++count[i][j][ff(r)])ans[i][j]++;
			data[l]=ff(r);
		}
	}
	
	return 0;
} </pre><pre></pre><h2>Problem2456</h2><pre>#include&lt;cstdio&gt;

int main()
{
	long long x,t1=0,t2=0;
	int n;
	scanf("%d",&amp;n);
	
	
	while(n--)
	{
		scanf("%lld",&amp;x);
		if(!t2)
		{
			t1=x;
			t2++;
		}
		else 
			t2+=(t1==x)?1:-1;
	}
	printf("%lld\n",t1);
}</pre><pre></pre><h2>Problem2463</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int t;

int main()
{
    scanf("%d",&amp;t);
    while(t)
    {
        if(t&amp;1)
            printf("Bob\n");
        else
            printf("Alice\n");
        scanf("%d",&amp;t);
    }

    return 0;
}
</pre><pre></pre><h2>Problem2502</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int S=101,s=102,t=103,T=104;
const int INF=2139062143;

int n,m,cnt=1,ans;
int g[110],in[110];
int vh[110],di[110],dis[110],pre[110],his[110];
struct edge
{
    int t,c,next;
}e[100010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int read()
{
    int temp=0,c=getchar();
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int isap()
{
    memset(vh,0,sizeof(vh));
    memset(dis,0,sizeof(dis));
    vh[0]=n+4;
    for(int i=1;i&lt;=n;i++)
        di[i]=g[i];
    di[S]=g[S];di[s]=g[s];di[t]=g[t];di[T]=g[T];
    int x=S,flow=0,aug=INF;

    while(dis[S]&lt;n+4)
    {
        bool flag=false;
        his[x]=aug;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                di[x]=i;
                aug=Min(aug,e[i].c);
                flag=true;
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    if(flow==n)return n;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(!vh[dis[x]])break;

        int mi=n+4,mii=0;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }
        di[x]=mii;
        dis[x]=mi+1;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
    {
        int x=read();
        in[i]-=x;
        for(int j=1;j&lt;=x;j++)
        {
            int y=read();
            in[y]++;
            add_edge(i,y,n);
        }
        add_edge(s,i,n);add_edge(i,t,n);
    }
    int flow=0;
    for(int i=1;i&lt;=n;i++)
        if(in[i]&gt;0)
        {
            add_edge(S,i,in[i]);
            flow+=in[i];
        }
        else
            if(in[i]&lt;0)
                add_edge(i,T,-in[i]);

    for(int i=1;;i++)
    {
        add_edge(t,s,1);
        flow-=isap();
        if(!flow)
        {
            printf("%d\n",i);
            return 0;
        }
    }
}
</pre><pre></pre><h2>Problem2510</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,k;
double a[1010],b[1010],c[1010];

inline int calc(int x)
{
    return x&lt;=0?x+n:x;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        a[i]=(double)x;
    }

    b[1]=(double)(m-1)/m;
    b[2]=(double)1/m;

    while(k&amp;&amp;n!=1)
    {
        if(k&amp;1)
        {
            for(int i=1;i&lt;=n;i++)
            {
                c[i]=0.0;
                for(int j=1;j&lt;=n;j++)
                    c[i]+=a[j]*b[calc(i-j+1)];
            }
            for(int i=1;i&lt;=n;i++)a[i]=c[i];
        }

        k&gt;&gt;=1;
        for(int i=1;i&lt;=n;i++)
        {
            c[i]=0.0;
            for(int j=1;j&lt;=n;j++)
                c[i]+=b[j]*b[calc(i-j+1)];
        }
        for(int i=1;i&lt;=n;i++)b[i]=c[i];
    }

    for(int i=1;i&lt;=n;i++)
        printf("%.3f\n",a[i]);

    return 0;
}
</pre><pre></pre><h2>Problem2561</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
 
using namespace std;
 
const int INF=1000000000;
 
int n,m,S,T,L,cnt,ans;
int g[20010];
int vh[20010],dis[20010],di[20010],pre[20010],his[20010];
struct edge1
{
    int x,y,z;
    inline friend bool operator&lt;(const edge1&amp;a,const edge1&amp;b)
    {
        return a.z&lt;b.z;
    }
}edg[200010];
struct edge
{
    int t,c,next;
}e[400010];
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].c=1;
    e[cnt].next=g[x];
    g[x]=cnt;
 
    e[++cnt].t=x;
    e[cnt].c=1;
    e[cnt].next=g[y];
    g[y]=cnt;
}
 
inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
 
inline int isap()
{
    memset(vh,0,sizeof(vh));
    memset(dis,0,sizeof(dis));
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;
 
    while(dis[S]&lt;n)
    {
        bool flag=false;
        his[x]=aug;
 
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                aug=Min(aug,e[i].c);
                di[x]=i;
                pre[e[i].t]=i^1;
                x=e[i].t;
 
                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;
 
        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;
        int mi=n,mii=0;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }
        di[x]=mii;
        dis[x]=mi+1;
        vh[dis[x]]++;
 
        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}
 
int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=m;i++)
    {
        edg[i].x=read();edg[i].y=read();edg[i].z=read();
    }
    S=read();T=read();L=read();
    sort(edg+1,edg+m+1);
    cnt=1;
    for(int i=1;i&lt;=m;i++)
        if(edg[i].z&lt;L)
            add_edge(edg[i].x,edg[i].y);
        else
            break;
    ans=isap();
 
    cnt=1;
    memset(g,0,sizeof(g));
    for(int i=m;i;i--)
        if(edg[i].z&gt;L)
            add_edge(edg[i].x,edg[i].y);
        else
            break;
    ans+=isap();
 
    printf("%d\n",ans);
 
    return 0;
}</pre><pre></pre><h2>Problem2588</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;

using namespace std;

int n,m,num,size;
int ch[100010],dep[100010],root[100010];
int fa[100010][21];
int sum[8000010],ls[8000010],rs[8000010];
map&lt;int,int&gt; h;
vector&lt;int&gt; g[100010];

struct dot
{
    int a,b,id;
}a[100010];

inline void add_edge(int x,int y)
{
    ch[x]++;
    g[x].push_back(y);

    ch[y]++;
    g[y].push_back(x);
}

inline bool cmp_a(dot x,dot y)
{
    return x.a&lt;y.a;
}

inline bool cmp_id(dot x,dot y)
{
    return x.id&lt;y.id;
}

inline void build(int l,int r,int pre,int &amp;now,int v)
{
    now=++size;
    sum[now]=sum[pre]+1;

    if(l==r)return;

    ls[now]=ls[pre];
    rs[now]=rs[pre];

    int mid=(l+r)&gt;&gt;1;

    if(v&lt;=mid)
        build(l,mid,ls[pre],ls[now],v);
    else
        build(mid+1,r,rs[pre],rs[now],v);
}

inline void dfs(int x,int depth)
{
    dep[x]=depth;
    for(int i=1;i&lt;=20;i++)
        fa[x][i]=fa[fa[x][i-1]][i-1];

    build(1,num,root[x==1?0:fa[x][0]],root[x],a[x].b);

    for(int i=0;i&lt;ch[x];i++)
        if(!dep[g[x][i]])
        {
            fa[g[x][i]][0]=x;
            dfs(g[x][i],depth+1);
        }
}

inline void swim(int &amp;x,int h)
{
    for(int i=0;h;i++)
    {
        if(h&amp;1)x=fa[x][i];
        h&gt;&gt;=1;
    }
}

inline int LCA(int x,int y)
{
    if(dep[x]&lt;dep[y])
    {
        int temp=x;
        x=y;
        y=temp;
    }

    swim(x,dep[x]-dep[y]);

    while(x!=y)
    {
        int i=0;
        for(;fa[x][i]!=fa[y][i];i++);

        if(i==0)return fa[x][0];

        x=fa[x][i-1];
        y=fa[y][i-1];
    }
    return x;
}

inline int query(int x,int y,int tot)
{
    int z=LCA(x,y);
    int p=z==1?0:fa[z][0];
    x=root[x];
    y=root[y];
    z=root[z];
    p=root[p];
    int l=1,r=num;

    while(l!=r)
    {
        int mid=(l+r)&gt;&gt;1;

        if(sum[ls[x]]+sum[ls[y]]-sum[ls[z]]-sum[ls[p]]&gt;=tot)
        {
            r=mid;
            x=ls[x];
            y=ls[y];
            z=ls[z];
            p=ls[p];
        }
        else
        {
            tot-=sum[ls[x]]+sum[ls[y]]-sum[ls[z]]-sum[ls[p]];
            l=mid+1;
            x=rs[x];
            y=rs[y];
            z=rs[z];
            p=rs[p];
        }
    }
    return l;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;a[i].a);
        a[i].id=i;
    }

    sort(a+1,a+n+1,cmp_a);

    a[1].b=1;
    h[1]=a[1].a;
    for(int i=2;i&lt;=n;i++)
    {
        if(a[i].a!=a[i-1].a)
        {
            a[i].b=a[i-1].b+1;
            h[a[i].b]=a[i].a;
        }
        else
            a[i].b=a[i-1].b;
    }
    num=a[n].b;
    sort(a+1,a+n+1,cmp_id);

    for(int i=1;i&lt;n;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(x,y);
    }
    fa[1][0]=1;

    dfs(1,1);

    int lastans=0;
    for(;m;m--)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        x^=lastans;

        printf("%d",lastans=h[query(x,y,z)]);
        if(m&gt;1)printf("\n");
    }

    return 0;
}
/*
8 5
105 2 9 3 8 5 7 7
1 2
1 3
1 4
3 5
3 6
3 7
4 8
2 5 1
0 5 2
10 5 3
11 5 4
110 8 2
*/
</pre><pre></pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt,sum,root,tot,ans,K;
int g[200010],siz[200010],f[200010];
int v[200010];
int num[1000010];
struct edge
{
    int t,c,next;
}e[400010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}

inline void get_root(int x,int fa)
{
    siz[x]=1;f[x]=0;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
        {
            get_root(e[i].t,x);
            siz[x]+=siz[e[i].t];
            f[x]=Max(f[x],siz[e[i].t]);
        }
    f[x]=Max(f[x],sum-siz[x]);
    if(f[x]&lt;f[root])root=x;
}
inline void dfs(int x,int y,int z,int fa)
{
    tot++;
    if(y==K)ans=Min(ans,z);
    if(y&lt;K)if(num[K-y]!=0)ans=Min(ans,z+num[K-y]);

    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs(e[i].t,y+e[i].c,z+1,x);
}
inline void add(int x,int y,int z,int fa)
{
    if(y&gt;=K)return;
    if(num[y]!=0)num[y]=Min(num[y],z);
    else num[y]=z;

    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            add(e[i].t,y+e[i].c,z+1,x);
}
inline void calc(int x)
{
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            tot=0;
            dfs(e[i].t,e[i].c,1,x);
            siz[e[i].t]=tot;
            add(e[i].t,e[i].c,1,x);
        }
}
inline void reset(int x,int y,int fa)
{
    if(y&gt;=K)return;
    num[y]=0;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            reset(e[i].t,y+e[i].c,x);
}
inline void work(int x)
{
    v[x]=1;calc(x);
    reset(x,0,0);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            root=0;sum=siz[e[i].t];
            get_root(e[i].t,0);
            work(root);
        }
}

int main()
{
    n=read();K=read();
    for(int i=1;i&lt;n;i++)
    {
        int x=read(),y,z;y=read();z=read();
        x++;y++;
        add_edge(x,y,z);
        add_edge(y,x,z);
    }
    f[0]=n;sum=n;ans=n;
    get_root(1,0);
    work(root);

    if(ans==n)
        printf("-1\n");
    else
        printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem2661</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const int N=2005,S=0,T=2002,INF=0x7fffffff;

int a,b,cnt=1,flow,cost;
int g[2010],dist[2010],q[2010],pre[2010];
bool v[2010];
struct edge
{
    int t,c,cst,next;
}e[20010];

inline void add_edge(int x,int y,int z1,int z2)
{
    e[++cnt].t=y;
    e[cnt].c=z1;
    e[cnt].cst=z2;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].cst=-z2;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline int gcd(int a,int b)
{
    return b?gcd(b,a%b):a;
}
inline bool judge(int x,int y)
{
    int z=y*y-x*x;
    z=(int)sqrt(z);
    if(z*z+x*x!=y*y)return false;
    if(gcd(x,z)!=1)return false;
    return true;
}

inline bool spfa()
{
    for(int i=S;i&lt;=T;i++)dist[i]=-INF;
    dist[S]=0;q[1]=S;v[S]=true;
    int h=0,t=1;

    while(h!=t)
    {
        h=h%N+1;
        int x=q[h];
        v[x]=false;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dist[x]+e[i].cst&gt;dist[e[i].t])
            {
                dist[e[i].t]=dist[x]+e[i].cst;
                pre[e[i].t]=i^1;
                if(!v[e[i].t])
                {
                    v[e[i].t]=true;
                    t=t%N+1;
                    q[t]=e[i].t;
                }
            }
    }
    return dist[T]!=-INF;
}

int main()
{
    scanf("%d%d",&amp;a,&amp;b);
    for(int i=a;i&lt;b;i++)
        for(int j=i+1;j&lt;=b;j++)
            if(judge(i,j))
            {
                add_edge(i,j+b,1,i+j);
                add_edge(j,i+b,1,i+j);
            }
    for(int i=a;i&lt;=b;i++)
    {
        add_edge(S,i,1,0);
        add_edge(i+b,T,1,0);
    }
    while(spfa())
    {
        flow++;cost+=dist[T];
        int x=T;
        while(x)
        {
            e[pre[x]].c++;
            e[pre[x]^1].c--;
            x=e[pre[x]].t;
        }
    }
    printf("%d %d\n",flow&gt;&gt;1,cost&gt;&gt;1);

    return 0;
}
</pre><pre></pre><h2>Problem2662</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;

using namespace std;

const int inf=1000000000;

int n,m,k,N;
int ch[3000],dist[3000],que[3000];
bool inque[3000];

struct size
{
    int t,len;
};

vector&lt;size&gt; g[3000];

inline void add_edge(int x,int y,int z)
{
    //printf("**z%d %d %d\n",x,y,z);
    ch[x]++;
    size temp;
    temp.t=y;
    temp.len=z;
    g[x].push_back(temp);
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void spfa()
{
    for(int i=1;i&lt;=N;i++)
        dist[i]=inf;

    dist[1]=0;
    que[1]=1;
    inque[1]=true;
    int h=0,t=1;
    while(h!=t)
    {
        if(h==N)h=0;
        h++;
        int x=que[h];
        inque[x]=false;

        for(int i=0;i&lt;ch[x];i++)
            if(g[x][i].len+dist[x]&lt;dist[g[x][i].t])
            {
                dist[g[x][i].t]=g[x][i].len+dist[x];

                if(!inque[g[x][i].t])
                {
                    if(t==N)t=0;
                    t++;
                    que[t]=g[x][i].t;
                    inque[que[t]]=true;
                }
            }
    }
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        for(int i=0;i&lt;k;i++)
        {
            add_edge(x+n*i,y+n*(i+1),z&gt;&gt;1);
            add_edge(y+n*i,x+n*(i+1),z&gt;&gt;1);
            add_edge(x+n*i,y+n*i,z);
            add_edge(y+n*i,x+n*i,z);
        }
        add_edge(x+n*k,y+n*k,z);
        add_edge(y+n*k,x+n*k,z);
    }
    N=(k+1)*n;
    spfa();

    int ans=inf;
    for(int i=1;i&lt;=k+1;i++)
        ans=min(ans,dist[i*n]);
    printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem2697</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,k,ans=0;
int c[310];

inline bool cmp(int a,int b)
{
    return a&gt;b;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;k);
    for(int i=1;i&lt;=k;i++)
        scanf("%d",c+i);
    sort(c+1,c+k+1,cmp);

    for(int i=1;(i&lt;&lt;1)&lt;=n&amp;&amp;i&lt;=k;i++)
        ans+=(n+1-i-i)*c[i];

    printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem2705</h2><pre>#include&lt;cstdio&gt;

using namespace std;

long long n,k1,phi,fac[1000],b[1000],c[1000],ans=0;
int tot,fac1[1000],a[1000];

int main()
{
	scanf("%lld",&amp;n);
	
	k1=1;
	tot=0;
	phi=n;
	
	while(n!=1&amp;&amp;k1*k1&lt;=n)
	{
		k1++;
		if(n%k1==0)fac[++tot]=k1;
		while(n%k1==0)
		{
			fac1[tot]++;
			n/=k1;
		}
	}
	if(n!=1)
	{
		fac[++tot]=n;
		fac1[tot]=1;
	}
	
	fac1[0]=100;
	
	for(int i=1;i&lt;=tot;i++)
	{
		phi=(phi/fac[i])*(fac[i]-1);
		a[i]=0;
		b[i]=fac[i]-1;
		
		for(int j=2;j&lt;=fac1[i];j++)b[i]*=fac[i];
		c[i]=b[i]/(fac[i]-1)*fac[i];
	}
	
	k1=1;
	
	while(!a[0])
	{
		ans+=k1*phi;
		
		int i=tot;
		
		a[i]++;
		 
		while(a[i]&gt;fac1[i])
		{
			phi*=b[i];
			k1=k1/c[i];
			a[i]=0;
			a[--i]++;
		}
		
		if(a[0])break;
		
		if(a[i]==fac1[i])
			phi/=fac[i]-1;
		else
			phi/=fac[i];
		
		k1*=fac[i];
	}
	
	printf("%lld\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem2733</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,sz;
int fa[100010],root[100010];
int sum[10000000],ls[10000000],rs[10000000];

struct size
{
    int a,id;
}isl[100010];

inline char read()
{
    char c=getchar();
    while(c!='Q'&amp;&amp;c!='B')c=getchar();
    return c;
}

inline bool cmp_a(size x,size y)
{
    return x.a&lt;y.a;
}

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline void insert(int &amp;p,int l,int r,int pos)
{
    p=++sz;
    if(l==r)
    {
        sum[p]=1;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if(pos&lt;=mid)
        insert(ls[p],l,mid,pos);
    else
        insert(rs[p],mid+1,r,pos);
    sum[p]=sum[ls[p]]+sum[rs[p]];
}

inline int query(int p,int rank)
{
    if(sum[p]&lt;rank)
        return -1;
    int l=1,r=n;
    while(l!=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(sum[ls[p]]&lt;rank)
        {
            l=mid+1;
            rank-=sum[ls[p]];
            p=rs[p];
        }
        else
        {
            r=mid;
            p=ls[p];
        }
    }
    return l;
}

inline int merge(int x,int y)
{
    if(!x)return y;
    if(!y)return x;
    ls[x]=merge(ls[x],ls[y]);
    rs[x]=merge(rs[x],rs[y]);
    sum[x]=sum[ls[x]]+sum[rs[x]];
    return x;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;isl[i].a);
        isl[i].id=i;
    }

    for(int i=1;i&lt;=n;i++)
        fa[i]=i;
    for(int i=1;i&lt;=n;i++)
        insert(root[find(i)],1,n,isl[i].a);
    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        root[find(x)]=merge(root[find(x)],root[find(y)]);
        fa[find(y)]=find(x);
    }

    sort(isl+1,isl+n+1,cmp_a);

    scanf("%d",&amp;m);
    for(;m;m--)
    {
        char c=read();
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);

        if(c=='Q')
        {
            int temp=query(root[find(x)],y);
            printf("%d\n",temp==-1?temp:isl[temp].id);
        }
        else
        {
            root[find(x)]=merge(root[find(x)],root[find(y)]);
            fa[find(y)]=find(x);
        }
    }

    return 0;
}
/*
5 1
4 3 2 5 1
1 2
7
Q 3 2
Q 2 1
B 2 3
B 1 5
Q 2 1
Q 2 4
Q 2 3
*/
</pre><pre></pre><h2>Problem2748</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,be,ma,ans=-1;
bool f[60][1010];
int main()
{
	scanf("%d%d%d",&amp;n,&amp;be,&amp;ma);
	memset(f,false,sizeof(f));
	f[0][be]=true;
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;be);
		for(int j=0;j&lt;=ma;j++)
		{
			if(j-be&gt;=0)f[i][j]=f[i][j]||f[i-1][j-be];
			if(j+be&lt;=ma)f[i][j]=f[i][j]||f[i-1][j+be];
		}
	}
	for(int i=ma;i&gt;=0;i--)
		if(f[n][i])
		{
			ans=i;
			break;
		}
	printf("%d\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem2750</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
#include&lt;algorithm&gt;

using namespace std;

const long long pp=(long long)1000000007;
const int inf=1e9;

int n,m;
int que[1510];
int dist[1510],q[1510];
long long c1[1510],c2[1510],ans[5010];

bitset&lt;1510&gt; inque;

struct size
{
	int ch,len,num;
	size *next;
}*g[1510],*gg[1510];

inline void add_edge(int x,int y,int z,int num)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;num=num;
	p-&gt;next=g[x];
	g[x]=p;
}

inline void add_edge1(int x,int y,int z,int num)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;num=num;
	p-&gt;next=gg[x];
	gg[x]=p;
}

inline void spfa(int xx)
{
	for(int i=1;i&lt;=n;i++)
		dist[i]=inf;
	inque.reset();

	inque.set(xx);
	dist[xx]=0;
	int hh=0,tt=1;
	que[1]=xx;

	while(hh!=tt)
	{
		hh=hh%n+1;
		int x=que[hh];
        inque.flip(x);

		for(size *p=g[x];p;p=p-&gt;next)
			if(dist[x]+p-&gt;len&lt;dist[p-&gt;ch])
			{
				dist[p-&gt;ch]=dist[x]+p-&gt;len;

				if(!inque.test(p-&gt;ch))
				{
					tt=tt%n+1;
					inque.set(p-&gt;ch);
					que[tt]=p-&gt;ch;
				}
			}
	}
}

inline bool cmp(int a,int b)
{
	return dist[a]&lt;dist[b];
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);

	for(int i=1;i&lt;=m;i++)
	{
		int x,y,z;

		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);

		add_edge(x,y,z,i);

		add_edge1(y,x,z,i);
	}

	for(int i=1;i&lt;=n;i++)
	{
		spfa(i);
		for(int j=1;j&lt;=n;j++)
			q[j]=j,c1[j]=c2[j]=0;

		sort(q+1,q+n+1,cmp);

		c1[i]=1;

		for(int j=1;j&lt;=n;j++)
			for(size *p=g[q[j]];p;p=p-&gt;next)
				if(dist[q[j]]+p-&gt;len==dist[p-&gt;ch])
					c1[p-&gt;ch]=(c1[p-&gt;ch]+c1[q[j]])%pp;

		for(int j=n;j;j--)
		{
			c2[q[j]]=(c2[q[j]]+1)%pp;
			for(size *p=gg[q[j]];p!=NULL;p=p-&gt;next)
			{
				if(dist[p-&gt;ch]+p-&gt;len==dist[q[j]])
				{
					ans[p-&gt;num]=ans[p-&gt;num]+c1[p-&gt;ch]*c2[q[j]]%pp;
					ans[p-&gt;num]%=pp;
					c2[p-&gt;ch]=(c2[p-&gt;ch]+c2[q[j]])%pp;
				}
			}
		}
	}

	for(int i=1;i&lt;=m;i++)
        printf("%d\n",(int)ans[i]);

	return 0;
}
</pre><pre></pre><h2>Problem2753</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;

using namespace std;

int n,m,num=0;
long long ans=0;
int fa[100010],h[100010];

bitset&lt;100010&gt; v;

struct size
{
    int x,y,len;
}edge[1000010],edge1[1000010];

struct size1
{
    int ch;
    size1 *next;
}*g[100010];

int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline bool cmp(size a,size b)
{
    return h[a.y]&gt;h[b.y]||h[a.y]==h[b.y]&amp;&amp;a.len&lt;b.len;
}

inline void add_edge(int x,int y)
{
    size1 *p=new size1;
    p-&gt;ch=y;
    p-&gt;next=g[x];
    g[x]=p;
}

void dfs(int x)
{
    v.set(x);
    for(size1 *p=g[x];p;p=p-&gt;next)
        if(!v.test(p-&gt;ch))
            dfs(p-&gt;ch);
}

inline void kru()
{
    for(int i=1;i&lt;=n;i++)
        fa[i]=i;

    sort(edge+1,edge+num+1,cmp);

    for(int i=1;i&lt;=num;i++)
    {
        if(find(edge[i].x)!=find(edge[i].y))
            ans+=edge[i].len,fa[find(edge[i].x)]=find(edge[i].y);
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
        scanf("%d",h+i);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);

        edge1[i].x=x;
        edge1[i].y=y;
        edge1[i].len=z;

        if(h[x]&gt;=h[y])
            add_edge(x,y);

        if(h[x]&lt;=h[y])
            add_edge(y,x);
    }

    v.reset();
    dfs(1);

    for(int i=1;i&lt;=m;i++)
    {
        if(v.test(edge1[i].x)&amp;&amp;v.test(edge1[i].y))
        {
            edge[++num]=edge1[i];
            if(h[edge[num].x]&lt;h[edge[num].y])
            {
                int t=edge[num].x;
                edge[num].x=edge[num].y;
                edge[num].y=t;
            }
        }
    }

    kru();

    printf("%d %lld\n",v.count(),ans);

    return 0;
}
</pre><pre></pre><h2>Problem2761</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

struct size
{
	int a,b,c;
}num[100010];

int t,n;

inline bool cmp1(size a1,size a2)
{
	return (a1.a&lt;a2.a)||((a1.a==a2.a)&amp;&amp;(a1.b&lt;a2.b));
}

inline bool cmp2(size a1,size a2)
{
	return (a1.c&gt;a2.c)||((a1.c==a2.c)&amp;&amp;(a1.b&lt;a2.b));
}

int main()
{
	scanf("%d",&amp;t);
	for(;t;t--)
	{
		scanf("%d",&amp;n);
		
		for(int i=1;i&lt;=n;i++)
		{
			num[i].a=num[i].b=num[i].c=0;
			scanf("%d",&amp;num[i].a);
			num[i].b=i;
		}
		sort(num+1,num+n+1,cmp1);
		
		num[1].c=1;
		for(int i=2;i&lt;=n;i++)
			if(num[i].a!=num[i-1].a)
				num[i].c=1;
		sort(num+1,num+n+1,cmp2);
		
		printf("%d",num[1].a);
		for(int i=2;i&lt;=n;i++)
			if(num[i].c)
				printf(" %d",num[i].a);
			else
				break;
		printf("\n");
	}
	
	return 0;
}</pre><pre></pre><h2>Problem2763</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1e9;

int n,m,k,s,t;
int que[10010];
int dist[10010][12];
bitset&lt;10010&gt; inque;

struct size
{
	int ch,len;
	size *next;
}*g[10010];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=g[x];
	g[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;len=z;
	p-&gt;next=g[y];
	g[y]=p;
}

inline bool check(int x,int y,int z)
{
	if(dist[x][0]+z&lt;dist[y][0])return true;
	for(int i=1;i&lt;=k;i++)
		if(dist[x][i]+z&lt;dist[y][i]||dist[x][i-1]&lt;dist[y][i])
			return true;
	return false;
}

inline void change(int x,int y,int z)
{
	dist[y][0]=min(dist[y][0],dist[x][0]+z);
	for(int i=1;i&lt;=k;i++)
		dist[y][i]=min(dist[y][i],min(dist[x][i]+z,dist[x][i-1]));
}

inline void spfa(int x)
{
	dist[x][0]=0;
	que[1]=x;
	inque.reset();
	inque.set(x);
	int h=0,t=1;
	
	while(h!=t)
	{
		h=h%n+1;
		x=que[h];
		inque.flip(x);
		
		for(size *p=g[x];p!=NULL;p=p-&gt;next)
			if(check(x,p-&gt;ch,p-&gt;len))
			{
				change(x,p-&gt;ch,p-&gt;len);
				if(!inque.test(p-&gt;ch))
				{
					inque.set(p-&gt;ch);
					t=t%n+1;
					que[t]=p-&gt;ch;
				}
			}
	}
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
	
	scanf("%d%d",&amp;s,&amp;t);
	
	for(int i=1;i&lt;=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		add_edge(x,y,z);
	}
	
	for(int i=0;i&lt;n;i++)
		for(int j=0;j&lt;=k;j++)
			dist[i][j]=inf;
	
	spfa(s);
	
	int ans=inf;
	
	for(int i=0;i&lt;=k;i++)
		ans=min(ans,dist[t][i]);
	
	printf("%d\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem2768</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int w[301][301];
int a[301];
int n,m;
int Link[302];
bitset&lt;310&gt; vis;

bool find(int x)
{
	for(int i=1;i&lt;=n;i++)
	{
		if(w[x][i]&amp;&amp;!vis[i])
		{
			vis[i]=1;
			if(!Link[i]||find(Link[i]))
			{
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",a+i);
	for(int i=1;i&lt;=m;i++)
	{
		int Alice,Bob;
		scanf("%d%d",&amp;Alice,&amp;Bob);
		if(a[Alice]^a[Bob])w[Alice][Bob]=w[Bob][Alice]=1;
	}
	
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		vis.reset();
		if(find(i))ans++;
	}
	printf("%d\n",ans/2);
	return 0;
}
 </pre><pre></pre><h2>Problem2768</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,m,x,y;
int a[301],be[302];
int w[301][301];

bitset&lt;310&gt; vis;

bool find(int x)
{
	for(int i=1;i&lt;=n;i++)
	{
		if(w[x][i]&amp;&amp;!vis.test(i))
		{
			vis.set(i);
			if(!be[i]||find(be[i]))
			{
				be[i]=x;
				return true;
			}
		}
	}
	return false;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",a+i);
	
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		if(a[x]^a[y])
			w[x][y]=w[y][x]=1;
	}
	
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		vis.reset();
		if(find(i))ans++;
	}
	
	printf("%d\n",ans/2);
	
	return 0;
}</pre><pre></pre><h2>Problem2812</h2><pre>int main(){return 0;}</pre><pre></pre><h2>Problem2818</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

bitset&lt;10000010&gt; c;
long long phi[10000010],ans;
int n,num;
int prm[10000010];

inline long long f(long long x)
{
	return x*2-1;
}

int main()
{
	scanf("%d",&amp;n);
		
	for(int i=2;i&lt;=n;i++)
	{
		if(!c.test(i))
		{
			phi[i]=i-1;
			prm[++num]=i;
		}
		for(int j=1;j&lt;=num&amp;&amp;prm[j]*i&lt;=n;j++)
		{
			c.set(prm[j]*i);
			if(i%prm[j]==0)
			{
				phi[i*prm[j]]=phi[i]*prm[j];
				break;
			}
			phi[i*prm[j]]=phi[i]*(prm[j]-1);
		}
	}
	phi[1]=1;
	for(int i=2;i&lt;=n;i++)
		phi[i]+=phi[i-1];
	
	for(int i=1;i&lt;=num;i++)
		ans+=f(phi[(int)(n/prm[i])]);
	
	printf("%lld\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem2819</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,m,cur;
int pl1[500010],pl2[500010];
int val[500010],dep[500010];
int stack[500010];
int anc[500010][20];
int dfs[1000010],trarr[1000010];
bitset&lt;500010&gt; v;

struct size
{
	int ch;
	size *next;
}*tr[500010];

inline int add_edge(int x,int y)
{
	size *p=new size;
	p-&gt;ch=y;
	p-&gt;next=tr[x];
	tr[x]=p;
	
	p=new size;
	p-&gt;ch=x;
	p-&gt;next=tr[y];
	tr[y]=p;
}

inline void swap(int &amp;x,int &amp;y)
{
	int temp=x;
	x=y,y=temp;
}

inline int lowbit(int x)
{
	return x&amp;-x;
}

inline void set(int x,int num)
{
	for(;x&lt;=n*2;x+=lowbit(x))
		trarr[x]^=num;
}

inline int query(int x)
{
	int temp=0;
	for(;x;x-=lowbit(x))
		temp^=trarr[x];
	return temp;
}

inline void tri()
{
	int h=1;
	v.reset();
	stack[h]=1;
	dep[1]=1;
	for(int i=0;i&lt;20;i++)
		anc[1][i]=1;
	
	while(h)
	{
		int x=stack[h];
		
		if(v.test(x))
		{
			dfs[pl2[x]=++cur]=stack[h--];
			set(cur,val[x]);
			continue;
		}
		
		v.set(dfs[pl1[x]=++cur]=x);
		set(cur,val[x]);
		
		for(size *p=tr[x];p!=NULL;p=p-&gt;next)
			if(!v.test(p-&gt;ch))
			{
				dep[p-&gt;ch]=dep[x]+1;
				stack[++h]=p-&gt;ch;
				
				anc[p-&gt;ch][0]=x;
				for(int i=1;i&lt;20;i++)
					anc[p-&gt;ch][i]=anc[anc[p-&gt;ch][i-1]][i-1];
			}
	}
}

inline char read()
{
	char c=getchar();
	while(c!='Q'&amp;&amp;c!='C')
		c=getchar();
	return c;
}

inline void swim(int &amp;x,int h)
{
	for(int i=0;h;h&gt;&gt;=1,i++)
		if(h&amp;1)
			x=anc[x][i];
}

inline int lca(int x,int y)
{
	if(dep[x]&lt;dep[y])
		swap(x,y);
	
	swim(x,dep[x]-dep[y]);
	if(x==y)return x;
	
	for(int i=19;i&gt;=0;i--)
		if(anc[x][i]!=anc[y][i])
			x=anc[x][i],y=anc[y][i];
	
	return anc[x][0];
}

int main()
{
	scanf("%d",&amp;n);
	
	int x,y;
	
	for(int i=1;i&lt;=n;i++)
		scanf("%d",val+i);
	
	for(int i=1;i&lt;n;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		add_edge(x,y);
	}
	
	tri();
	
	scanf("%d",&amp;m);
	
	for(;m;m--)
	{
		char c=read();
		scanf("%d%d",&amp;x,&amp;y);
		
		if(c=='Q')
		{
			int temp=query(pl1[x])^query(pl1[y])^val[lca(x,y)];
			
			if(temp)
				printf("Yes\n");
			else
				printf("No\n");
		}
		else
		{
			set(pl1[x],val[x]^y);
			set(pl2[x],val[x]^y);
			val[x]=y;
		}
	}
	
	return 0;
}</pre><pre></pre><h2>Problem2821</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

using namespace std;
 
int n,m,c;
int cnt[100010];
int color[100010];
int bel[100010],S[290],T[290];
int ans[290][290];
int num[290][100010];
int Cnt[1010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
  n=read();c=read();m=read();
  for(int i=1;i&lt;=n;i++)
    color[i]=read();

  int limit=350;
  for(int i=1;i&lt;=n;i++)
    bel[i]=i/limit+1;
  for(int i=1;i&lt;=n;i++)
    if(bel[i]!=bel[i-1])
      {
	S[bel[i]]=i;
	T[bel[i]-1]=i-1;
      }
  T[bel[n]]=n;
  for(int i=1;i&lt;=bel[n];i++)
    {
      int temp=0;
      memset(cnt,0,sizeof(cnt));
      for(int j=S[i];j&lt;=n;j++)
	{
	  if(cnt[color[j]]&amp;1)
	    temp++;
	  else 
	    if(cnt[color[j]]!=0)
	      temp--;
	  cnt[color[j]]++;
	  if(j==T[bel[j]])ans[i][bel[j]]=temp;
	}
    }

  memset(cnt,0,sizeof(cnt));
  for(int i=1;i&lt;=n;i++)
    {
      cnt[color[i]]++;
      if(i==T[bel[i]])
        for(int j=1;j&lt;=c;j++)
	  num[bel[i]][j]=cnt[j];
    }

  int lastans=0;
  for(;m;m--)
    {
      int x=read(),y;y=read();
      x=(x+lastans)%n+1;y=(y+lastans)%n+1;
      if(x&gt;y){int temp=x;x=y;y=temp;}
      int temp=0;
      memset(Cnt,0,sizeof(Cnt));

      if(bel[x]+1&gt;=bel[y])
	for(int i=x;i&lt;=y;i++)
	  Cnt[++temp]=color[i];
      else
	{
	  for(int i=x;i&lt;=T[bel[x]];i++)Cnt[++temp]=color[i];
	  for(int i=S[bel[y]];i&lt;=y;i++)Cnt[++temp]=color[i];
	}

      sort(Cnt+1,Cnt+temp+1);
      if(bel[x]+1&lt;bel[y])lastans=ans[bel[x]+1][bel[y]-1];else lastans=0;
      for(int i=1;i&lt;=temp;i++)
	{
	  int s=i;
	  while(Cnt[i+1]==Cnt[i]&amp;&amp;i&lt;temp)i++;
	  if((bel[x]+1&gt;=bel[y])||(num[bel[y]-1][Cnt[i]]-num[bel[x]][Cnt[i]]==0)&amp;&amp;(bel[x]+1&lt;bel[y]))
	    {if((i-s)&amp;1)lastans++;}
	  else
	    if((num[bel[y]-1][Cnt[i]]-num[bel[x]][Cnt[i]])&amp;1)
	      {if((i-s+1)&amp;1)lastans++;}
	    else
	      if((i-s+1)&amp;1)lastans--;
	}
      printf("%d\n",lastans);
    }

  return 0;
}
</pre><pre></pre><h2>Problem2821</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;
 
int n,m,c;
int cnt[100010];
int color[100010];
int bel[100010],S[290],T[290];
int ans[290][290];
int num[290][100010];
int Cnt[1010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
  n=read();c=read();m=read();
  for(int i=1;i&lt;=n;i++)
    color[i]=read();

  int limit=350;
  for(int i=1;i&lt;=n;i++)
    bel[i]=i/limit+1;
  for(int i=1;i&lt;=n;i++)
    if(bel[i]!=bel[i-1])
      {
	S[bel[i]]=i;
	T[bel[i]-1]=i-1;
      }
  T[bel[n]]=n;
  for(int i=1;i&lt;=bel[n];i++)
    {
      int temp=0;
      memset(cnt,0,sizeof(cnt));
      for(int j=S[i];j&lt;=n;j++)
	{
	  if(cnt[color[j]]&amp;1)
	    temp++;
	  else 
	    if(cnt[color[j]]!=0)
	      temp--;
	  cnt[color[j]]++;
	  if(j==T[bel[j]])ans[i][bel[j]]=temp;
	}
    }

  memset(cnt,0,sizeof(cnt));
  for(int i=1;i&lt;=n;i++)
    {
      cnt[color[i]]++;
      if(i==T[bel[i]])
        for(int j=1;j&lt;=c;j++)
	  num[bel[i]][j]=cnt[j];
    }

  memset(cnt,0,sizeof(cnt));
  int lastans=0;
  for(;m;m--)
    {
      int x=read(),y;y=read();
      x=(x+lastans)%n+1;y=(y+lastans)%n+1;
      if(x&gt;y){int temp=x;x=y;y=temp;}
      int temp=0;
      memset(Cnt,0,sizeof(Cnt));

      if(bel[x]+1&gt;=bel[y])
	for(int i=x;i&lt;=y;i++)
	  Cnt[++temp]=color[i];
      else
	{
	  for(int i=x;i&lt;=T[bel[x]];i++)Cnt[++temp]=color[i];
	  for(int i=S[bel[y]];i&lt;=y;i++)Cnt[++temp]=color[i];
	}

      if(bel[x]+1&lt;bel[y])lastans=ans[bel[x]+1][bel[y]-1];else lastans=0;
      for(int i=1;i&lt;=temp;i++)
	  if(bel[x]+1&lt;bel[y])
	    {
	      if((num[bel[y]-1][Cnt[i]]-num[bel[x]][Cnt[i]])&amp;1)
		lastans++;
	      else
		if((num[bel[y]-1][Cnt[i]]-num[bel[x]][Cnt[i]])!=0)
		  lastans--;
	      num[bel[y]-1][Cnt[i]]++;
	    }
	  else
	    {
	      if(cnt[Cnt[i]]&amp;1)
		lastans++;
	      else
		if(cnt[Cnt[i]]!=0)
		  lastans--;
	      cnt[Cnt[i]]++;
	    }

      for(int i=1;i&lt;=temp;i++)
	if(bel[x]+1&lt;bel[y])
	      num[bel[y]-1][Cnt[i]]--;
	  else
	      cnt[Cnt[i]]--;

      printf("%d\n",lastans);
    }

  return 0;
}
</pre><pre></pre><h2>Problem2821</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;
 
int n,m,c;
int cnt[100010];
int color[100010];
int bel[100010],S[307],T[307];
int ans[307][307];
int num[307][100010];
int Cnt[1010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
  n=read();c=read();m=read();
  for(int i=1;i&lt;=n;i++)
    color[i]=read();

  int limit=330;
  for(int i=1;i&lt;=n;i++)
    bel[i]=i/limit+1;
  for(int i=1;i&lt;=n;i++)
    if(bel[i]!=bel[i-1])
      {
	S[bel[i]]=i;
	T[bel[i]-1]=i-1;
      }
  T[bel[n]]=n;
  for(int i=1;i&lt;=bel[n];i++)
    {
      int temp=0;
      memset(cnt,0,sizeof(cnt));
      for(int j=S[i];j&lt;=n;j++)
	{
	  if(cnt[color[j]]&amp;1)
	    temp++;
	  else 
	    if(cnt[color[j]]!=0)
	      temp--;
	  cnt[color[j]]++;
	  if(j==T[bel[j]])ans[i][bel[j]]=temp;
	}
    }

  memset(cnt,0,sizeof(cnt));
  for(int i=1;i&lt;=n;i++)
    {
      cnt[color[i]]++;
      if(i==T[bel[i]])
        for(int j=1;j&lt;=c;j++)
	  num[bel[i]][j]=cnt[j];
    }

  memset(cnt,0,sizeof(cnt));
  int lastans=0;
  for(;m;m--)
    {
      int x=read(),y;y=read();
      x=(x+lastans)%n+1;y=(y+lastans)%n+1;
      if(x&gt;y){int temp=x;x=y;y=temp;}
      int temp=0;

      if(bel[x]+1&gt;=bel[y])
	for(int i=x;i&lt;=y;i++)
	  Cnt[++temp]=color[i];
      else
	{
	  for(int i=x;i&lt;=T[bel[x]];i++)Cnt[++temp]=color[i];
	  for(int i=S[bel[y]];i&lt;=y;i++)Cnt[++temp]=color[i];
	}

      if(bel[x]+1&lt;bel[y])lastans=ans[bel[x]+1][bel[y]-1];else lastans=0;
      for(int i=1;i&lt;=temp;i++)
	  if(bel[x]+1&lt;bel[y])
	    {
	      if((num[bel[y]-1][Cnt[i]]-num[bel[x]][Cnt[i]])&amp;1)
		lastans++;
	      else
		if((num[bel[y]-1][Cnt[i]]-num[bel[x]][Cnt[i]])!=0)
		  lastans--;
	      num[bel[y]-1][Cnt[i]]++;
	    }
	  else
	    {
	      if(cnt[Cnt[i]]&amp;1)
		lastans++;
	      else
		if(cnt[Cnt[i]]!=0)
		  lastans--;
	      cnt[Cnt[i]]++;
	    }

      for(int i=1;i&lt;=temp;i++)
	if(bel[x]+1&lt;bel[y])
	      num[bel[y]-1][Cnt[i]]--;
	  else
	      cnt[Cnt[i]]--;

      printf("%d\n",lastans);
    }

  return 0;
}
</pre><pre></pre><h2>Problem2822</h2><pre>import java.util.*;
import java.math.*;

public class Main
{
	public static void main(String[] args)
	{
		Scanner cin=new Scanner(System.in);
		
		int i,j,n=cin.nextInt();
		
		BigInteger f[]=new BigInteger[510];
		
		f[0]=f[1]=BigInteger.ONE;
		
		for(i=2;i&lt;=n;i++)
		{
			f[i]=BigInteger.ZERO;
			for(j=0;j&lt;i;j++)
				f[i]=f[i].add(f[j].multiply(f[i-1-j]));
		}
		
		System.out.println(f[n].toString());
		
		cin.close();
	}
}</pre><pre></pre><h2>Problem2875</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;

using namespace std;

const int base=1000000000;
const int maxn=500;

class bigint
{
public:
	int len;
	int data[maxn+10];
	
	bigint():len(0)
	{
	}
	
	bigint(const bigint &amp;x):len(x.len)
	{
		memcpy(data,x.data,len*sizeof(int));
	}
	
	bigint(int x):len(0)
	{
		for(;x&gt;0;x/=base)
			data[len++]=x%base;
	}
	
	bigint &amp;operator=(const bigint &amp;x)
	{
		len=x.len;
		memcpy(data,x.data,len*sizeof*data);
		return *this;
	}

	int &amp;operator[](int i)
	{
		return data[i];
	}

	int operator[](int i)
	const
	{
		return i&lt;len?data[i]:0;
	}
};

int compare(const bigint &amp;a,const bigint &amp;b)
{
	int i;
	if(a.len!=b.len)return a.len&gt;b.len?1:-1;
	
	for(i=a.len-1;i&gt;=0&amp;&amp;a[i]==b[i];i--);
	if(i&lt;0)return 0;
	return a[i]&gt;b[i]?1:-1;
}

bool operator==(const bigint &amp;a,const bigint &amp;b)
{
	return compare(a,b)==0;
}

bool operator!=(const bigint &amp;a,const bigint &amp;b)
{
	return compare(a,b)!=0;
}

bool operator&gt;(const bigint &amp;a,const bigint &amp;b)
{
	return compare(a,b)&gt;0;
}

bool operator&lt;(const bigint &amp;a,const bigint &amp;b)
{
	return compare(a,b)&lt;0;
}

bool operator&gt;=(const bigint &amp;a,const bigint &amp;b)
{
	return compare(a,b)&gt;=0;
}

bool operator&lt;=(const bigint &amp;a,const bigint &amp;b)
{
	return compare(a,b)&lt;=0;
}

bigint operator+(const bigint &amp;a,const bigint &amp;b)
{
	bigint c;
	int i,x=0;
	
	for(i=0;i&lt;a.len||i&lt;b.len||x&gt;0;i++)
	{
		if(i&lt;a.len)x+=a[i];
		if(i&lt;b.len)x+=b[i];
		c[i]=x%base;
		x/=base;
	}
	
	c.len=i;
	return c;
}

bigint operator-(const bigint &amp;a,const bigint &amp;b)
{
	bigint c;
	int x=0;
	c.len=a.len;
	
	for(int i=0;i&lt;c.len;i++)
	{
		c[i]=a[i]-x;
		if(i&lt;b.len)c[i]-=b[i];
		
		if(c[i]&lt;0)
			x=1,c[i]+=base;
		else
			x=0;
	}
	while(c.len&gt;0&amp;&amp;c[c.len-1]==0)c.len--;
	return c;
}

bigint operator*(const bigint &amp;a,const int b)
{
	int i;
	if(b==0)return 0;
	bigint c;
	long long x=0;
	
	for(i=0;i&lt;a.len||x&gt;0;i++)
	{
		if(i&lt;a.len)x+=(long long)(a[i])*b;
		c[i]=x%base;
		x/=base;
	}
	
	c.len=i;
	return c;
}

bigint operator*(const bigint &amp;a,const bigint &amp;b)
{
	if(b.len==0)return 0;
	bigint c;
	
	for(int i=0;i&lt;a.len;i++)
	{
		long long x=0;
		for(int j=0;j&lt;b.len||x&gt;0;j++)
		{
			if(j&lt;b.len)x+=(long long)(a[i])*b[j];
			if(i+j&lt;c.len)x+=c[i+j];
			
			if(i+j&gt;=c.len)
				c[c.len++]=x%base;
			else
				c[i+j]=x%base;
			x/=base;
		}
	}
	
	return c;
}

bigint operator/(const bigint &amp;a,const int b)
{
	bigint c;
	long long x=0;
	
	for(int i=a.len-1;i&gt;=0;i--)
	{
		x=x*base+a[i];
		c[i]=x/b;
		x%=b;
	}
	
	c.len=a.len;
	while(c.len&gt;0&amp;&amp;c[c.len-1]==0)c.len--;
	
	return c;
}

bigint operator/(const bigint &amp;a,const bigint &amp;b)
{
	bigint c,x=0;
	int l,r,mid;
	
	for(int i=a.len-1;i&gt;=0;i--)
	{
		x=x*base+a[i];
		l=0;
		r=base-1;
		
		while(l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			
			if(compare(b*mid,x)&lt;=0)
				l=mid+1;
			else
				r=mid-1;
		}
		
		c[i]=r;
		x=x-b*r;
	}
	
	c.len=a.len;
	while(c.len&gt;0&amp;&amp;c[c.len-1]==0)c.len--;
	return c;
}

bigint operator%(const bigint &amp;a,const bigint &amp;b)
{
	bigint temp;
	temp=a/b;
	temp=a-b*temp;
	
	return temp;
}

istream&amp;operator&gt;&gt;(istream&amp;input,bigint &amp;x)
{
	char c;
	
	for(x=0;input&gt;&gt;c;)
	{
		x=x*10+(c-'0');
		if(input.peek()&lt;=' ')break;
	}
	
	return input;
}

ostream&amp;operator&lt;&lt;(ostream&amp;output,const bigint &amp;x)
{
	output&lt;&lt;(x.len==0?0:x[x.len-1]);
	
	for(int i=x.len-2;i&gt;=0;i--)
		for(int j=base/10;j&gt;0;j/=10)
			output&lt;&lt;x[i]/j%10;
			
	return output;
}

bigint m,a,c,x0,g;
long long n;
bigint aa[5][5],b[5][5],temp[5][5];

int main()
{
	cin&gt;&gt;m&gt;&gt;a&gt;&gt;c&gt;&gt;x0&gt;&gt;n&gt;&gt;g;
	
	aa[1][1]=1;
	aa[2][1]=x0%m;
	b[1][1]=1;
	b[2][1]=c%m;
	b[2][2]=a%m;
	while(n)
	{		
		if(n&amp;1)
		{
			temp[1][1]=(aa[1][1]*b[1][1]%m+aa[2][1]*b[1][2]%m)%m;
			temp[2][1]=(aa[1][1]*b[2][1]%m+aa[2][1]*b[2][2]%m)%m;
			aa[1][1]=temp[1][1];
			aa[2][1]=temp[2][1];
		}
		
		n&gt;&gt;=1;
		temp[1][1]=(b[1][1]*b[1][1]%m+b[2][1]*b[1][2]%m)%m;
		temp[1][2]=(b[1][2]*b[1][1]%m+b[2][2]*b[1][2]%m)%m;
		temp[2][1]=(b[1][1]*b[2][1]%m+b[2][1]*b[2][2]%m)%m;
		temp[2][2]=(b[1][2]*b[2][1]%m+b[2][2]*b[2][2]%m)%m;
		b[1][1]=temp[1][1];
		b[1][2]=temp[1][2];
		b[2][1]=temp[2][1];
		b[2][2]=temp[2][2];
	}
	
	cout&lt;&lt;aa[2][1]%g&lt;&lt;endl;
	
	return 0;
}</pre><pre></pre><h2>Problem2876</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;

using namespace std;

const int maxn=10010;
int N;
double E;
double s[maxn],v[maxn],k[maxn],maxv[maxn],tem[maxn],minv[maxn];

inline double max(double x,double y)
{
    return x&gt;y?x:y;
}

inline double min(double x,double y)
{
    return x&lt;y?x:y;
}

inline double solve(double a,double b,double c,double d,double l,double r)
{
    while(l+0.0000001&lt;r)
    {
        double mid=(l+r)/2.0;
        double ans=(a*mid+b)*mid*mid+d;
        if(ans&gt;0.0)
            l=mid;
        else
            r=mid;
    }
    return (l+r)/2.0;
}

int main()
{
    scanf("%d%lf",&amp;N,&amp;E);
    double low=0;
    for(int i=0;i&lt;N;i++)
    {
        double t=0;
        scanf("%lf%lf%lf",s+i,k+i,v+i);
        if(s[i]&gt;0)
        {
             maxv[i]=sqrt(E/(k[i]*s[i]))+v[i];
             t=-(1.0/(2*k[i]*maxv[i]*maxv[i]*(maxv[i]-v[i])));
        }
        else
            maxv[i]=v[i];
        minv[i]=max(0.000001,v[i]);
        low=min(low,t);
    }

    double left=-1,right=low,mid,sum;
    for(int zz=0;zz&lt;80;zz++)
    {
        mid=(left+right)/2.0;
        sum=0.0;
        for(int i=0;i&lt;N;i++)
        {
            double a=2.0*k[i]*mid;
            tem[i]=solve(a,-a*v[i],0,1.0,minv[i],maxv[i]);
            sum+=k[i]*s[i]*(tem[i]-v[i])*(tem[i]-v[i]);
        }
        if(sum&gt;E)
        {
            right=mid;
            for(int i=0;i&lt;N;i++)
                maxv[i]=tem[i];
        }
        else
        {
            left=mid;
            for(int i=0;i&lt;N;i++)
                minv[i]=tem[i];
        }
        if(fabs(sum-E)&lt;0.00000001)break;
    }

    long double ret;
    ret=0.0;
    for(int i=0;i&lt;N;i++)
        if(s[i]&gt;0)
            ret+=(long double)s[i]/(long double)tem[i];
    printf("%.10lf\n",(double)ret);
    return 0;
}
</pre><pre></pre><h2>Problem2929</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int INF=1000000000;

int n,S,T,cnt=1;
int g[210];
int vh[210],dis[210],di[210],pre[210],his[210];
struct edge
{
    int t,c,next;
}e[50000];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int isap()
{
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;

    while(dis[S]&lt;n)
    {
        bool flag=false;
        his[x]=aug;

        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                di[x]=i;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(!vh[dis[x]])break;

        int mi=n,mii=0;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }
        di[x]=mii;
        dis[x]=mi+1;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();S=1;T=n;
    for(int i=1;i&lt;n;i++)
    {
        int x=read();
        while(x--)
        {
            int y=read();
            if(i==1||y==n)add_edge(i,y,1);
            else add_edge(i,y,10000);
        }
    }

    printf("%d\n",isap());

    return 0;
}
</pre><pre></pre><h2>Problem2938</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
char s[30001];
struct node{
	int id,val;
	node *go[2],*fail,*last;
	node(node *C=0){
		id=0;fail=C;val=0;last=C;
		for(int i=0;i&lt;2;i++)go[i]=C;
	}
}*Null,*root;
node *newnode(node *C){
	static int cnt=0;
	node *x=new node(C);
	x-&gt;id=++cnt;return x;
}
void insert(const char *s){
	node *u=root;int len=strlen(s);
	for(int i=0;i&lt;len;i++){
		int v=s[i]-'0';
		if(u-&gt;go[v]==Null)u-&gt;go[v]=newnode(root);
		u=u-&gt;go[v];
	}u-&gt;val=1;
}
void get_fail(){
	queue&lt;node*&gt;q;
	for(int i=0;i&lt;2;i++)if(root-&gt;go[i]!=Null)
	q.push(root-&gt;go[i]),root-&gt;go[i]-&gt;fail=root-&gt;go[i]-&gt;last=root;
	while(!q.empty()){
		node *u=q.front(),*v;q.pop();
		for(int i=0;i&lt;2;i++)if((v=u-&gt;go[i])!=Null){
			q.push(v);node *j=u-&gt;fail;
			while(j!=Null&amp;&amp;j-&gt;go[i]==Null)j=j-&gt;fail;
			v-&gt;fail=j-&gt;go[i];v-&gt;val|=v-&gt;fail-&gt;val;
			v-&gt;last=v-&gt;fail-&gt;val?v-&gt;fail:v-&gt;fail-&gt;last;
		}else u-&gt;go[i]=u-&gt;fail-&gt;go[i];
	}
}
short vis[30001*2];
short ins[30001*2];
bool dfs(node *u){
	ins[u-&gt;id]=1;node *v;
	for(int i=0;i&lt;2;i++){
		v=u-&gt;go[i];
		if(v-&gt;val)continue;
		if(ins[v-&gt;id])return 1;
		if(vis[v-&gt;id])continue;
		vis[v-&gt;id]=1;
		if(dfs(v))return 1;
	}ins[u-&gt;id]=0;
	return false;
}
int main(){
	Null=newnode(0);
	Null-&gt;fail=Null;Null-&gt;last=Null;
	for(int i=0;i&lt;2;i++)Null-&gt;go[i]=Null;
	root=Null;
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;++i)
		scanf("%s",s),insert(s);
	get_fail();vis[1]=1;
	puts(dfs(root)?"TAK":"NIE");
	return 0;
}</pre><pre></pre><h2>Problem2938</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

using namespace std;

int n,cnt,root,num,idx,h;
int g[30010],dfn[30010],low[30010],stck[30010];
char str[30010];
bool flag,instck[30010];
struct edge
{
    int t,next;
}e[60010];
struct ac_automation
{
    int id,fail;
    int nxt[2];
}ac[30010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Min(int x,int y)
{
    return x&lt;y?x:y;
}

inline int new_node()
{
    ac[++cnt].nxt[0]=-1;
    ac[cnt].nxt[1]=-1;
    return cnt;
}
inline void ins()
{
    int temp=root,len=strlen(str);
    for(int i=0;i&lt;len;i++)
    {
        if(ac[temp].nxt[str[i]-'0']==-1)
            ac[temp].nxt[str[i]-'0']=new_node();
        temp=ac[temp].nxt[str[i]-'0'];
        if(i==len-1)ac[temp].id=1;
    }
}
inline void build()
{
    ac[root].fail=root;
    queue&lt;int&gt;Q;
    while(!Q.empty())Q.pop();
    for(int i=0;i&lt;2;i++)
        if(ac[root].nxt[i]==-1)
            ac[root].nxt[i]=root;
        else
        {
            ac[ac[root].nxt[i]].fail=root;
            Q.push(ac[root].nxt[i]);
        }
    while(!Q.empty())
    {
        int x=Q.front();
        Q.pop();
        for(int i=0;i&lt;2;i++)
            if(ac[x].nxt[i]==-1)
                ac[x].nxt[i]=ac[ac[x].fail].nxt[i];
            else
            {
                ac[ac[x].nxt[i]].fail=ac[ac[x].fail].nxt[i];
                if(ac[ac[ac[x].fail].nxt[i]].id==1)
                    ac[ac[x].nxt[i]].id=1;
                Q.push(ac[x].nxt[i]);
            }
    }
}

inline void add_edge(int x,int y)
{
    e[++num].t=y;
    e[num].next=g[x];
    g[x]=num;
}
inline void dfs(int x)
{
    if(flag)return;
    dfn[x]=low[x]=++idx;
    stck[++h]=x;
    instck[x]=true;
    for(int i=g[x];i;i=e[i].next)
    {
        if(x==e[i].t)
        {
            flag=true;
            return;
        }
        if(!dfn[e[i].t])
        {
            dfs(e[i].t);
            low[x]=Min(low[x],low[e[i].t]);
        }
        else
            if(instck[e[i].t])
                low[x]=Min(low[x],dfn[e[i].t]);
    }
    if(dfn[x]!=low[x])
        flag=true;
    else
    {
        while(stck[h]!=x)
        {
            instck[stck[h]]=false;
            h--;
        }
        instck[stck[h]]=false;
        h--;
    }
}

int main()
{
    n=read();
    root=new_node();
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%s",str);
        ins();
    }
    build();
    for(int i=1;i&lt;=cnt;i++)
        if(ac[i].id==0)
            for(int j=0;j&lt;2;j++)
                if(ac[ac[i].nxt[j]].id==0)
                    add_edge(i,ac[i].nxt[j]);

    flag=false;
    dfs(root);

    if(flag)
        printf("TAK\n");
    else
        printf("NIE\n");

    return 0;
}
</pre><pre></pre><h2>Problem3039</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int a[1010][1010];
int s[1010],l[1010];
int n,m,ans=0;
char str[3];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline void work(int h[])
{
    int top=0,len=0;
    s[top]=0;l[top]=0;
    for(int i=1;i&lt;=m;i++)
    {
        if(h[i]&gt;=s[top])
        {
            s[++top]=h[i];
            l[top]=1;
        }
        else
        {
            len=0;
            while(top&amp;&amp;s[top]&gt;h[i])
            {
                len+=l[top];
                ans=max(ans,len*s[top]);
                top--;
            }
            s[++top]=h[i];
            l[top]=len+1;
        }
    }
    len=0;
    while(top)
    {
        len+=l[top];
        ans=max(ans,len*s[top]);
        top--;
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            scanf("%s",str);
            if(str[0]=='F')
                a[i][j]=a[i-1][j]+1;
        }

    for(int i=1;i&lt;=n;i++)work(a[i]);

    printf("%d\n",ans*3);

    return 0;
}
</pre><pre></pre><h2>Problem3040</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const long long maxint=(long long)1000000000*(long long)1000000000;

int que2[1000010],pl[1000010];
long long que1[1000010],dist[1000010],ltemp;
int size,n,m,temp,x,y,z,t,rxa,rxc,rya,ryc,rp;

struct edge
{
	int ch,len;
	edge *next;
}*tr[1000010],*p;

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	p=new edge;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=tr[x];
	tr[x]=p;
}

inline void swap(int x,int y)
{
	long long temp1=que1[x];
	que1[x]=que1[y];
	que1[y]=temp1;
	
	temp=que2[x];
	que2[x]=que2[y];
	que2[y]=temp;
	
	pl[que2[x]]=x;
	pl[que2[y]]=y;
}

void heapfy(int x)
{
	int xx=x;
	long long minn=que1[x];
	
	if((x&lt;&lt;1)&lt;=size)
		if(que1[x&lt;&lt;1]&lt;minn)
			xx=x&lt;&lt;1,minn=que1[xx];
	
	if((x&lt;&lt;1|1)&lt;=size)
		if(que1[x&lt;&lt;1|1]&lt;minn)
			xx=x&lt;&lt;1|1;
	
	if(x!=xx)
	{
		swap(x,xx);
		heapfy(xx);
	}
}

void up(int x)
{
	if(x&gt;1)
		if(que1[x]&lt;que1[x&gt;&gt;1])
		{
			swap(x,x&gt;&gt;1);
			up(x&gt;&gt;1);
		}
}

inline void insert(long long x,int y)
{
	que1[++size]=x;
	que2[size]=y;
	pl[y]=size; 
	
	up(size);
}

inline void dij()
{
	for(int i=1;i&lt;=n;i++)dist[i]=maxint;
	pl[1]=1;
	que1[1]=0;
	que2[1]=1;
	size=1;
	
	while(size)
	{
		int x=que2[1];
		dist[x]=que1[1];
		if(x==n)return;
		
		swap(1,size--);
		heapfy(1);
		p=tr[x];
		
		while(p!=NULL)
		{
			if(dist[p-&gt;ch]==maxint)
			{
				ltemp=dist[x]+p-&gt;len;
				if(pl[p-&gt;ch])
				{
					if(ltemp&lt;que1[pl[p-&gt;ch]])
					{
						que1[pl[p-&gt;ch]]=ltemp;
						up(pl[p-&gt;ch]);
					}
				}
				else
				  insert(ltemp,p-&gt;ch);
			}
			p=p-&gt;next;
		}
	}
}

int main()
{
	scanf("%d%d%d%d%d%d%d%d",&amp;n,&amp;m,&amp;t,&amp;rxa,&amp;rxc,&amp;rya,&amp;ryc,&amp;rp);
	
	for(int i=1;i&lt;=t;i++)
	{
		x=((long long)x*rxa+rxc)%rp;
        y=((long long)y*rya+ryc)%rp;
		add_edge(min(x%n+1,y%n+1),max(y%n+1,y%n+1),100000000-100*min(x%n+1,y%n+1));
	}
	
	for(int i=1;i&lt;=m-t;i++)
	{
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		add_edge(x,y,z);
	}
	
	dij();

	printf("%lld\n",dist[n]);
	
	return 0;
}</pre><pre></pre><h2>Problem3040</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const long long maxint=(long long)1000000000*(long long)1000000000;

int que2[1000010],pl[1000010];
long long que1[1000010],dist[1000010],ltemp,temp1;
int size,n,m,temp,x,y,z,t,rxa,rxc,rya,ryc,rp;

struct edge
{
	int ch,len;
	edge *next;
}*tr[1000010],*p;

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	p=new edge;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=tr[x];
	tr[x]=p;
}

inline void swap(int x,int y)
{
	temp1=que1[x];
	que1[x]=que1[y];
	que1[y]=temp1;
	
	temp=que2[x];
	que2[x]=que2[y];
	que2[y]=temp;
	
	pl[que2[x]]=x;
	pl[que2[y]]=y;
}

void heapfy(int x)
{
	int xx=x;
	long long minn=que1[x];
	
	if((x&lt;&lt;1)&lt;=size)
		if(que1[x&lt;&lt;1]&lt;minn)
			xx=x&lt;&lt;1,minn=que1[xx];
	
	if((x&lt;&lt;1|1)&lt;=size)
		if(que1[x&lt;&lt;1|1]&lt;minn)
			xx=x&lt;&lt;1|1;
	
	if(x!=xx)
	{
		swap(x,xx);
		heapfy(xx);
	}
}

void up(int x)
{
	if(x&gt;1)
		if(que1[x]&lt;que1[x&gt;&gt;1])
		{
			swap(x,x&gt;&gt;1);
			up(x&gt;&gt;1);
		}
}

inline void insert(long long x,int y)
{
	que1[++size]=x;
	que2[size]=y;
	pl[y]=size; 
	
	up(size);
}

inline void dij()
{
	for(int i=1;i&lt;=n;i++)dist[i]=maxint;
	pl[1]=1;
	que1[1]=0;
	que2[1]=1;
	size=1;
	
	while(size)
	{
		x=que2[1];
		dist[x]=que1[1];
		if(x==n)return;
		
		swap(1,size--);
		heapfy(1);
		p=tr[x];
		
		while(p!=NULL)
		{
			if(dist[p-&gt;ch]==maxint)
			{
				ltemp=dist[x]+p-&gt;len;
				if(pl[p-&gt;ch])
				{
					if(ltemp&lt;que1[pl[p-&gt;ch]])
					{
						que1[pl[p-&gt;ch]]=ltemp;
						up(pl[p-&gt;ch]);
					}
				}
				else
				  insert(ltemp,p-&gt;ch);
			}
			p=p-&gt;next;
		}
	}
}

int main()
{
	scanf("%d%d%d%d%d%d%d%d",&amp;n,&amp;m,&amp;t,&amp;rxa,&amp;rxc,&amp;rya,&amp;ryc,&amp;rp);
	
	for(int i=1;i&lt;=t;i++)
	{
		x=((long long)x*rxa+rxc)%rp;
        y=((long long)y*rya+ryc)%rp;
		add_edge(min(x%n+1,y%n+1),max(y%n+1,y%n+1),100000000-100*min(x%n+1,y%n+1));
	}
	
	for(int i=1;i&lt;=m-t;i++)
	{
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		add_edge(x,y,z);
	}
	
	dij();

	printf("%lld\n",dist[n]);
	
	return 0;
}</pre><pre></pre><h2>Problem3040</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const long long maxint=(long long)1000000000*(long long)1000000000;

int que2[1000010],pl[1000010];
long long que1[1000010],dist[1000010],ltemp,temp1;
int size,n,m,temp,x,y,z,t,rxa,rxc,rya,ryc,rp;

struct edge
{
	int ch,len;
	edge *next;
}*tr[1000010],*p;

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	p=new edge;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=tr[x];
	tr[x]=p;
}

inline void swap(int x,int y)
{
	temp1=que1[x];
	que1[x]=que1[y];
	que1[y]=temp1;
	
	temp=que2[x];
	que2[x]=que2[y];
	que2[y]=temp;
	
	pl[que2[x]]=x;
	pl[que2[y]]=y;
}

void heapfy(int x)
{
	int xx=x;
	long long minn=que1[x];
	
	if((x&lt;&lt;1)&lt;=size)
		if(que1[x&lt;&lt;1]&lt;minn)
			xx=x&lt;&lt;1,minn=que1[xx];
	
	if((x&lt;&lt;1|1)&lt;=size)
		if(que1[x&lt;&lt;1|1]&lt;minn)
			xx=x&lt;&lt;1|1;
	
	if(x!=xx)
	{
		swap(x,xx);
		heapfy(xx);
	}
}

void up(int x)
{
	if(x&gt;1)
		if(que1[x]&lt;que1[x&gt;&gt;1])
		{
			swap(x,x&gt;&gt;1);
			up(x&gt;&gt;1);
		}
}

inline void insert(long long x,int y)
{
	que1[++size]=x;
	que2[size]=y;
	pl[y]=size; 
	
	up(size);
}

inline void dij()
{
	for(int i=1;i&lt;=n;i++)dist[i]=maxint;
	pl[1]=1;
	que1[1]=0;
	que2[1]=1;
	size=1;
	
	while(size)
	{
		x=que2[1];
		dist[x]=que1[1];
		if(x==n)return;
		
		swap(1,size--);
		heapfy(1);
		p=tr[x];
		
		while(p!=NULL)
		{
			if(dist[p-&gt;ch]==maxint)
			{
				ltemp=dist[x]+p-&gt;len;
				if(pl[p-&gt;ch])
				{
					if(ltemp&lt;que1[pl[p-&gt;ch]])
					{
						que1[pl[p-&gt;ch]]=ltemp;
						up(pl[p-&gt;ch]);
					}
				}
				else
				  insert(ltemp,p-&gt;ch);
			}
			p=p-&gt;next;
		}
	}
}

inline int getint()
{
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')c=getchar();
    int x=0;
    while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar();
    return x;
}

int main()
{
	n=getint();
	m=getint();
	t=getint();
	rxa=getint();
	rxc=getint();
	rya=getint();
	ryc=getint();
	rp=getint();
	
	for(int i=1;i&lt;=t;i++)
	{
		x=((long long)x*rxa+rxc)%rp;
        y=((long long)y*rya+ryc)%rp;
		add_edge(min(x%n+1,y%n+1),max(y%n+1,y%n+1),100000000-100*min(x%n+1,y%n+1));
	}
	
	for(int i=1;i&lt;=m-t;i++)
	{
		x=getint();
		y=getint();
		z=getint();
		add_edge(x,y,z);
	}
	
	dij();

	printf("%lld\n",dist[n]);
	
	return 0;
}</pre><pre></pre><h2>Problem3040</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m;
int cnt,siz;
int g[1000010];
bool v[1000010];
long long key[1000010];
int num[1000010],pl[1000010];

struct edge
{
    int t,c,next;
}e[1000010];

inline int read()
{
    char c=getchar();
    int temp=0;

    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}
inline void swap(long long&amp;x,long long&amp;y)
{
    x^=y^=x^=y;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void up(int p)
{
    while(p&gt;&gt;1)
    {
        int x=p&gt;&gt;1;
        if(key[p]&gt;=key[x])return;
        swap(key[x],key[p]);
        swap(num[x],num[p]);
        swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void down(int p)
{
    while((p&lt;&lt;1)&lt;=siz)
    {
        int x=p&lt;&lt;1;
        if(x&lt;siz&amp;&amp;key[x|1]&lt;key[x])x|=1;
        if(key[p]&lt;=key[x])return;
        swap(key[x],key[p]);
        swap(num[x],num[p]);
        swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void ins(int p,long long v)
{
    key[++siz]=v;
    num[siz]=p;
    pl[p]=siz;
    up(siz);
}
inline void del(int p)
{
    key[p]=key[siz];
    num[p]=num[siz];
    pl[num[p]]=p;
    siz--;
    down(p);
}

inline long long dijkstra(int x)
{
    siz=1;
    key[1]=0;
    num[1]=x;
    pl[x]=1;

    while(siz)
    {
        int x=num[1];
        long long dist=key[1];
        if(x==1)return dist;
        v[x]=true;
        del(1);

        for(int i=g[x];i;i=e[i].next)
            if(!v[e[i].t])
                if(!pl[e[i].t])
                    ins(e[i].t,dist+e[i].c);
                else
                    if(dist+e[i].c&lt;key[pl[e[i].t]])
                    {
                        key[pl[e[i].t]]=dist+e[i].c;
                        up(pl[e[i].t]);
                    }
    }
}

int main()
{
    int temp;
    n=read();m=read();
    temp=read();m-=temp;temp=read();temp=read();temp=read();temp=read();temp=read();

    for(int i=0;i&lt;m;i++)
    {
        int x,y,z;
        x=read();y=read();z=read();
        add_edge(y,x,z);
    }
    printf("%lld\n",dijkstra(n));

    return 0;
}
</pre><pre></pre><h2>Problem3043</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,x,y;
long long temp1,temp2;

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
    n=read();x=read();
    for(int i=2;i&lt;=n;i++)
    {
        y=read();
        if(y&gt;x)
            temp1+=y-x;
        else
            temp2+=x-y;
        x=y;
    }
    if(temp1&gt;temp2)
        printf("%lld\n%lld\n",temp1,temp1-temp2+1);
    else
        printf("%lld\n%lld\n",temp2,temp2-temp1+1);
    return 0;
}
</pre><pre></pre><h2>Problem3052</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int n,m,Q,B,idx,mt,qt,bt,cnt;
int g[200010],ll[200010],rr[200010],dfn[200010];
int v[200100],w[200100],c[200100],cc[200100];
int ufs[200100],lca[200100],bel[200100],sum[200100];
int type[200100],xx[200100],yy[200100];
long long ans,anss[100005];
bool V[100005];

struct edge
{
    int t,next;
}e[200010];
struct elem
{
    int x,y,t;
    struct elem*n;
}memo[100005],*me=memo,*modify[100005],*que[100005],*ask[60][60];
struct info
{
    int t,f;
    struct info*n;
}Mem[200005],*memt=Mem,*list[100005];

inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline int read()
{
    int temp=0;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline int find(int x)
{
    return ufs[x]=ufs[x]==x?x:find(ufs[x]);
}

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline void dfs(int u,int fa)
{
	dfn[ll[u]=++idx]=u;
	for(int i=g[u];i;i=e[i].next)
        if(e[i].t!=fa)
            dfs(e[i].t,u);
	dfn[rr[u]=++idx]=u;
}

inline void tarjan(int u,int fa)
{
	info*i;ufs[u]=u;
	for(int i=g[u];i;i=e[i].next)
        if(e[i].t!=fa)
        {
            tarjan(e[i].t,u);
            ufs[e[i].t]=u;
        }
	for(i=list[u];i;i=i-&gt;n)
		if(ufs[i-&gt;t])
			lca[i-&gt;f]=find(i-&gt;t);
}

inline void trans(int p)
{
	if(V[p])
    {
        V[p]=0;
        ans-=(long long)v[c[p]]*w[sum[c[p]]--];
    }
	else
    {
        V[p]=1;
        ans+=(long long)v[c[p]]*w[++sum[c[p]]];
    }
}

int main()
{
	n=read();m=read();Q=read();
	for(int i=1;i&lt;=m;++i)
		v[i]=read();
	for(int i=1;i&lt;=n;++i)
		w[i]=read();

	for(int i=1;i&lt;n;++i)
    {
		int x,y;
		x=read();y=read();
		add_edge(x,y);
		add_edge(y,x);
	}

	for(int i=1;i&lt;=n;++i)
    {
        c[i]=read();
        cc[i]=c[i];
    }

	dfs(1,0);

	for(B=1;B*B*B&lt;idx;++B);
	B*=B;

	bt=1;
	for(int i=1,j=1;i&lt;=idx;++i,++j)
    {
		if(j&gt;B)
        {
            j=1;
            ++bt;
        }
		bel[i]=bt;
	}

	for(int i=0;i&lt;Q;++i)
    {
		int x,y;
		type[i]=read();x=read();y=read();

		if(!type[i])
			*me=(elem){x,y,i},modify[mt++]=me++;
		else
		{
			*memt=(info){y,me-memo,list[x]},list[x]=memt++;
			*memt=(info){x,me-memo,list[y]},list[y]=memt++;

			if(ll[x]&gt;ll[y])Swap(x,y);
			xx[i]=x;
			yy[i]=y;
			x=rr[x]&lt;rr[y]?rr[x]:ll[x];y=ll[y];
			*me=(elem){x,y,i};que[qt++]=me++;
		}
	}

	for(int i=qt;i--;)
    {
		elem*j=que[i];
		j-&gt;n=ask[bel[j-&gt;x]][bel[j-&gt;y]];
		ask[bel[j-&gt;x]][bel[j-&gt;y]]=j;
	}

	tarjan(1,0);
	int temp;
	for(int i=1;i&lt;=bt;++i)
		for(int j=i;j&lt;=bt;++j)
			if(ask[i][j])
            {
				int l=(i-1)*B+1,r=l,f;
				elem*e,*d;
				memset(sum,0,(m+1)&lt;&lt;2);
				memset(V,0,(n+1));
				memcpy(c,cc,(n+1)&lt;&lt;2);
				ans=0;
				temp=0;
				trans(dfn[l]);

				for(e=ask[i][j];e;e=e-&gt;n)
                {
					if(l&lt;e-&gt;x)
                        for(;l!=e-&gt;x;++l)trans(dfn[l]);
					else
                        if(l&gt;e-&gt;x)
                            do trans(dfn[--l]);while(l!=e-&gt;x);
					if(r&gt;e-&gt;y)
                        for(;r!=e-&gt;y;--r)trans(dfn[r]);
					else
                        if(r&lt;e-&gt;y)
                            do trans(dfn[++r]);while(r!=e-&gt;y);

					for(;temp&lt;mt&amp;&amp;modify[temp]-&gt;t&lt;e-&gt;t;++temp)
                    {
						d=modify[temp];
						bool flag=(l&lt;=ll[d-&gt;x]&amp;&amp;ll[d-&gt;x]&lt;=r)^(l&lt;=rr[d-&gt;x]&amp;&amp;rr[d-&gt;x]&lt;=r);
						if(flag)trans(d-&gt;x);
						c[d-&gt;x]=d-&gt;y;
						if(flag)trans(d-&gt;x);
					}

					anss[e-&gt;t]=ans;
					f=lca[e-memo];
					if(f!=xx[e-&gt;t]&amp;&amp;f!=yy[e-&gt;t])
						anss[e-&gt;t]+=(long long)v[c[f]]*w[sum[c[f]]+1];
				}
			}

	for(int i=0;i&lt;Q;++i)
		if(type[i])
			printf("%lld\n",anss[i]);

	return 0;
}
</pre><pre></pre><h2>Problem3056</h2><pre>int main(){return 0;}</pre><pre></pre><h2>Problem3083</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int INF=1000000000;

int n,m,rt,rt1,cnt,num;
int g[100010],dep[100010],siz[100010],def[100010];
int fa[100010][20];
int dfn[100010],pos[100010],bel[100010],S[100010],T[100010];
struct edge
{
    int t,next;
}e[200010];
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}
struct seg_tree
{
    int l,r,v,tg;
}seg[400010];

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline void dfs1(int x)
{
    dep[x]=dep[fa[x][0]]+1;
    for(int i=1;i&lt;18;i++)
        fa[x][i]=fa[fa[x][i-1]][i-1];
    siz[x]=1;
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa[x][0])
        {
            fa[e[i].t][0]=x;
            dfs1(e[i].t);
            siz[x]+=siz[e[i].t];
        }
}
inline void dfs2(int x,int chain)
{
    dfn[++num]=x;pos[x]=num;bel[x]=chain;S[x]=num;
    int ma=0,mai=0;
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa[x][0]&amp;&amp;siz[e[i].t]&gt;ma)
        {
            ma=siz[e[i].t];
            mai=e[i].t;
        }
    if(ma==0){T[x]=num;return;}
    dfs2(mai,chain);
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=mai&amp;&amp;e[i].t!=fa[x][0])
            dfs2(e[i].t,e[i].t);
    T[x]=num;
}

inline void swim(int&amp;x,int h)
{
    for(int i=0;h;i++)
    {
        if(h&amp;1)x=fa[x][i];
        h&gt;&gt;=1;
    }
}
inline int lca(int x,int y)
{
    if(dep[x]&lt;dep[y])Swap(x,y);
    swim(x,dep[x]-dep[y]);
    while(x!=y)
    {
        int i;
        for(i=0;fa[x][i]!=fa[y][i];i++);
        if(i==0)return fa[x][0];
        i--;
        x=fa[x][i];
        y=fa[y][i];
    }
    return x;
}

inline void push_down(int p)
{
    if(seg[p].tg)
    {
        seg[p&lt;&lt;1].v=seg[p].tg;
        seg[p&lt;&lt;1].tg=seg[p].tg;
        seg[p&lt;&lt;1|1].v=seg[p].tg;
        seg[p&lt;&lt;1|1].tg=seg[p].tg;
        seg[p].tg=0;
    }
}
inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r)
    {
        seg[p].v=def[dfn[l]];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
    seg[p].v=Min(seg[p&lt;&lt;1].v,seg[p&lt;&lt;1|1].v);
}
inline int query(int p,int l,int r)
{
    if(r&lt;l)return INF;
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p].v;
    push_down(p);
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        return query(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            return query(p&lt;&lt;1|1,l,r);
        else
            return Min(query(p&lt;&lt;1,l,mid),query(p&lt;&lt;1|1,mid+1,r));
}
inline void modify(int p,int l,int r,int val)
{

    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)
    {
        seg[p].v=val;
        seg[p].tg=val;
        return;
    }
    push_down(p);
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        modify(p&lt;&lt;1,l,r,val);
    else
        if(l&gt;mid)
            modify(p&lt;&lt;1|1,l,r,val);
        else
        {
            modify(p&lt;&lt;1,l,mid,val);
            modify(p&lt;&lt;1|1,mid+1,r,val);
        }
    seg[p].v=Min(seg[p&lt;&lt;1].v,seg[p&lt;&lt;1|1].v);
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;n;i++)
    {
        int x=read(),y;y=read();
        add_edge(x,y);add_edge(y,x);
    }
    for(int i=1;i&lt;=n;i++)
        def[i]=read();

    rt=read();rt1=rt;
    fa[rt][0]=rt;
    dfs1(rt);
    dfs2(rt,rt);

    build(1,1,n);

    for(;m;m--)
    {
        switch(read())
        {
            case 1:
            {
                rt1=read();
                break;
            }
            case 2:
            {
                int x=read(),y,val;y=read();val=read();
                int z=lca(x,y);
                while(dep[x]&gt;dep[z]||dep[y]&gt;dep[z])
                {
                    if(dep[x]&lt;dep[y])Swap(x,y);
                    int temp=bel[x];
                    if(dep[temp]&lt;dep[z])
                    {
                        modify(1,pos[z],pos[x],val);
                        x=temp;
                    }
                    else
                    {
                        modify(1,pos[temp],pos[x],val);
                        x=fa[temp][0];
                    }
                }
                modify(1,pos[z],pos[z],val);
                break;
            }
            case 3:
            {
                int x=read();
                if(x==rt1)
                    printf("%d\n",seg[1].v);
                else
                    if(lca(x,rt1)!=x)
                        printf("%d\n",query(1,S[x],T[x]));
                    else
                    {
                        int y=rt1;
                        swim(y,dep[rt1]-dep[x]-1);
                        printf("%d\n",Min(query(1,1,S[y]-1),query(1,T[y]+1,n)));
                    }
                break;
            }
        }
    }
    return 0;
}
</pre><pre></pre><h2>Problem3098</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n=100000,l=100;

int main()
{
    printf("%d %d\n",n,l);
    for(int i=1;i&lt;=n;i++)
        putchar((char)('a'+rand()%26));
    putchar('\n');
    return 0;
}</pre><pre></pre><h2>Problem3110</h2><pre>type segtree=^node;
     node=record
	        l,r,s:longint;
			left,right:segtree;
		  end;
var i,j,n2,n,t,s,m,x,y,z:longint;
    list,root1,root2:array[0..100000] of segtree;
	ty:array[1..100000] of longint;
	zero:segtree;	
procedure build(var s:segtree; _l,_r:longint);
  begin
  new(s);
  with s^ do
    begin
	l:=_l; r:=_r; s:=0; left:=nil; right:=nil;
	if l&lt;r then
	  begin
	  build(left,l,(l+r) div 2);
	  build(right,(l+r) div 2+1,r);
	  end;
	end;
  end;
function seginsert(s:segtree; pos,delta:longint):segtree;  
  begin
  new(seginsert);
  seginsert^:=s^;
  with seginsert^ do
	if l=r then 
	  inc(s,delta)
	else
	  begin
	  if pos&lt;=left^.r then
	    left:=seginsert(left,pos,delta)
	  else
	    right:=seginsert(right,pos,delta);
	  s:=left^.s+right^.s;
	  end;
  end;
procedure insert1(t:longint; pos,delta:longint);
  begin
  while t&gt;0 do
    begin
	root1[t]:=seginsert(root1[t],pos,delta);
	t:=t-(t and (-t));
	end;
  end;
procedure insert2(t:longint; pos,delta:longint);
  begin
  if t&gt;0 then 
  while t&lt;=n do
    begin
	root2[t]:=seginsert(root2[t],pos,delta);
	t:=t+(t and (-t));
	end;
  end;
procedure insert(t:longint; pos,delta:longint);
  begin
  insert1(t,pos,delta);
  //insert2(n,pos,delta*t);
  insert2(t+1,pos,delta*t);
  end;
procedure query1(t:longint; delta:longint);
  var tmp:longint;
  begin
  tmp:=t;
  if t&gt;0 then 
    while t&lt;=n do
      begin
	  inc(n2); list[n2]:=root1[t]; ty[n2]:=delta*tmp;
	  //writeln('root1 ',t,' ',ty[n2]);
	  t:=t+(t and (-t));
	  end;
  end;
procedure query2(t:longint; delta:longint);
  begin  
  while t&gt;0 do
    begin
	inc(n2); list[n2]:=root2[t]; ty[n2]:=delta;
	//writeln('root2 ',t,' ',delta);
	t:=t-(t and (-t));
	end;  
  end;
procedure getlist(t:longint; delta:longint);
  begin
  query1(t,delta);
  query2(t,delta);
  end;
begin
  //assign(input,'sequence.in'); reset(input);
  //assign(output,'sequence.out');rewrite(output);
  readln(n,m);
  build(zero,1,n);
  for i:=0 to n do root1[i]:=zero;
  for i:=0 to n do root2[i]:=zero;
  for i:=1 to m do
    begin
	readln(t,x,y,z);
	if t=1 then
	  begin
	  insert(x-1,z,-1);
	  insert(y,z,1);
	  end
	else
	  begin
	  n2:=0;
	  getlist(x-1,-1);
	  getlist(y,1);
	  while list[1]^.left&lt;&gt;nil do
	    begin
		s:=0;
		//write('[',list[1]^.right^.l,',',list[1]^.right^.r,'] ');
		for j:=1 to n2 do
		  begin
		 // write(list[j]^.right^.s*ty[j],' ');
		  inc(s,list[j]^.right^.s*ty[j]);
		  end;
		//writeln;
		if s&lt;z then
		  begin
		  for j:=1 to n2 do 
		    list[j]:=list[j]^.left;
		  z:=z-s;
		  end
		else
		  for j:=1 to n2 do
		    list[j]:=list[j]^.right;			
		end;
	  writeln(list[1]^.l);
	  end;
    end;
  close(input); close(output);
end.</pre><pre></pre><h2>Problem3130</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const double maxd=(double)1000000000.0;
const double eps=(double)0.000000001;

int n,m,p,num=-1,maxflow;
int vh[200],dis[200],pre[200];
double his[200];

struct size
{
    int ch;
    size *next;
}*g[200],*di[200];

struct size1
{
    int t;
    double c;
}edg[2000],edge[2000];

inline void add_edge(int x,int y,int z)
{
    edg[++num].t=y;
    edg[num].c=(double)z;

    size *p=new size;
    p-&gt;ch=num;
    p-&gt;next=g[x];
    g[x]=p;

    edg[++num].t=x;
    edg[num].c=(double)0;

    p=new size;
    p-&gt;ch=num;
    p-&gt;next=g[y];
    g[y]=p;
}

inline double abs(double x)
{
	return x&lt;0?-x:x;
}

inline double mindouble(double a,double b)
{
	return a&lt;b?a:b;
}

inline double sap()
{
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)
        di[i]=g[i],dis[i]=(double)0.0,vh[i]=0;
    int i=1;
	double aug=maxd,flow=(double)0.0;

    while(dis[1]&lt;n)
    {
        bool flag=false;
        his[i]=aug;

        for(size *p=di[i];p!=NULL;p=p-&gt;next)
            if(edge[p-&gt;ch].c&gt;0&amp;&amp;dis[i]==dis[edge[p-&gt;ch].t]+1)
            {
                flag=true;
                aug=mindouble(aug,edge[p-&gt;ch].c);
                pre[edge[p-&gt;ch].t]=1^p-&gt;ch;
                i=edge[p-&gt;ch].t;

                if(i==n)
                {
                    flow+=aug;
                    while(i!=1)
                    {
                        edge[pre[i]].c+=aug;
                        edge[pre[i]^1].c-=aug;
                        i=edge[pre[i]].t;
                    }
                    aug=maxd;
                }
                break;
            }

        if(flag)continue;

        int mi=n;
        size *p1;

        for(size *p=g[i];p!=NULL;p=p-&gt;next)
            if(edge[p-&gt;ch].c&gt;0&amp;&amp;dis[edge[p-&gt;ch].t]+1&lt;mi)
                mi=dis[edge[p-&gt;ch].t]+1,p1=p;

        di[i]=p1;

        vh[dis[i]]--;
        if(!vh[dis[i]])break;
        dis[i]=mi;
        vh[dis[i]]++;

        if(i!=1)
        {
            i=edge[pre[i]].t;
            aug=his[i];
        }
    }

    return flow;
}

inline bool test(double x)
{
    for(int i=0;i&lt;=num;i++)
    {
    	edge[i]=edg[i];
    	if(edge[i].c&gt;x)
    		edge[i].c=x;
    }
    double temp=sap();
    return abs(maxflow-temp)&lt;=eps?1:0;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;p);

    for(int i=1;i&lt;=m;i++)
    {
    	int x,y,z;
    	scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
    }
    
    for(int i=0;i&lt;=num;i++)
    	edge[i]=edg[i];
    
    maxflow=sap();
    
    printf("%d\n",(int)maxflow);
    
    double l=0,r=maxflow;
    
    while((r-l)&gt;eps)
    {
        double mid=(l+r)/2.0;
        if(test(mid))
            r=mid;
        else
            l=mid;
    }
    
    printf("%.5lf\n",l*(double)p);
    
    return 0;
}</pre><pre></pre><h2>Problem3155</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m;
int a[200010];
long long s[200010],t[200010];

inline int lowbit(int x)
{
    return x&amp;(-x);
}

inline void update1(int x,long long num)
{
    for(;x&lt;=n;x+=lowbit(x))
        s[x]+=num;
}

inline void update2(int x,long long num)
{
    for(;x&lt;=n;x+=lowbit(x))
        t[x]+=num;
}

inline long long sum1(int x)
{
    long long temp=0;
    for(;x;x-=lowbit(x))
        temp+=s[x];
    return temp;
}

inline long long sum2(int x)
{
    long long temp=0;
    for(;x;x-=lowbit(x))
        temp+=t[x];
    return temp;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",a+i);
        update1(i,a[i]);
        update2(i,(long long)a[i]*(n-i+1));
    }

    for(;m;m--)
    {
        int x,y;
        char s[8];

        scanf("%s%d",s,&amp;x);

        if (s[0]=='Q')
        {
            printf("%lld\n",sum2(x)-sum1(x)*(n-x));
        }
        else
        {
            scanf("%d",&amp;y);
            update1(x,y-a[x]);
            update2(x,(long long)(y-a[x])*(n-x+1));
            a[x]=y;
        }
    }

    return 0;
}
</pre><pre></pre><h2>Problem3155</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m;
int a[100010];
long long s[100010],t[100010];

inline int lowbit(int x)
{
    return x&amp;(-x);
}

inline void update1(int x,long long num)
{
    for(;x&lt;=n;x+=lowbit(x))
        s[x]+=num;
}

inline void update2(int x,long long num)
{
    for(;x&lt;=n;x+=lowbit(x))
        t[x]+=num;
}

inline long long sum1(int x)
{
    long long temp=0;
    for(;x;x-=lowbit(x))
        temp+=s[x];
    return temp;
}

inline long long sum2(int x)
{
    long long temp=0;
    for(;x;x-=lowbit(x))
        temp+=t[x];
    return temp;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d",a+i);
        update1(i,a[i]);
        update2(i,(long long)a[i]*(n-i+1));
    }

    for(;m;m--)
    {
        int x,y;
        char s[8];

        scanf("%s%d",s,&amp;x);

        if (s[0]=='Q')
        {
            printf("%lld\n",sum2(x)-sum1(x)*(n-x));
        }
        else
        {
            scanf("%d",&amp;y);
            update1(x,y-a[x]);
            update2(x,(long long)(y-a[x])*(n-x+1));
            a[x]=y;
        }
    }

    return 0;
}
</pre><pre></pre><h2>Problem3158</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const int INF=2000000000;

int n,cnt=1,S,T,ans;
int g[1010],a[1010],b[1010];
int vh[1010],pre[1010],dis[1010],di[1010],his[1010];
struct edge
{
    int t,c,next;
}e[1000010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}
inline int gcd(int a,int b)
{
    return !b?a:gcd(b,a%b);
}

inline bool judge(int x,int y)
{
    long long z=(long long)a[x]*a[x]+(long long)a[y]*a[y];
    long long z1=(long long)sqrt(z);
    if(z1*z1!=z)return false;
    if(gcd(a[x],a[y])!=1)return false;
    return true;
}
inline void build()
{
    S=n+1;T=n+2;
    for(int i=1;i&lt;=n;i++)
        if(a[i]&amp;1)
            add_edge(S,i,b[i]);
        else
            add_edge(i,T,b[i]);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            if((a[i]&amp;1)&amp;&amp;(!(a[j]&amp;1)))
                if(judge(i,j))
                    add_edge(i,j,INF);
    n+=2;
}

inline int isap()
{
    vh[0]=n;
    for(int i=1;i&lt;=n;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;

    while(dis[S]&lt;n)
    {
        bool flag=false;
        his[x]=aug;

        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                di[x]=i;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(!vh[dis[x]])break;

        int mi=n,mii=0;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }
        di[x]=mii;
        dis[x]=mi+1;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)a[i]=read();
    for(int i=1;i&lt;=n;i++)
    {
        b[i]=read();
        ans+=b[i];
    }
    build();

    printf("%d\n",ans-isap());

    return 0;
}
</pre><pre></pre><h2>Problem3171</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int INF=1000000000;

int n,m,S=1,T,cnt,ans;
int g[500],dist[500],q[500],pre[500];
bool v[500];
int dx[4]={1,0,-1,0};
int dy[4]={0,-1,0,1};
char str[20];

struct edge
{
    int t,c,cst,next;
}e[10010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y,int z1,int z2)
{
    e[++cnt].t=y;
    e[cnt].c=z1;
    e[cnt].cst=z2;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].cst=-z2;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int calc1(int x,int y)
{
    return (x-1)*m+y+1;
}
inline int calc2(int x,int y)
{
    return calc1(x,y)+n*m;
}
inline int calc3(int x,int y)
{
    if(x==0)x=n;
    if(x==n+1)x=1;
    if(y==0)y=m;
    if(y==m+1)y=1;
    return calc2(x,y);
}
inline int rev(int x)
{
    return x&amp;1?x+1:x-1;
}

inline int spfa()
{
    memset(v,0,sizeof(v));
    for(int i=S;i&lt;=T;i++)dist[i]=INF;
    dist[1]=0;q[1]=S;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%T+1;
        int x=q[h];
        v[x]=false;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dist[x]+e[i].cst&lt;dist[e[i].t])
            {
                pre[e[i].t]=i;
                dist[e[i].t]=dist[x]+e[i].cst;

                if(!v[e[i].t])
                {
                    t=t%T+1;
                    v[e[i].t]=true;
                    q[t]=e[i].t;
                }
            }
    }
    return dist[T]!=INF;
}

int main()
{
    n=read();m=read();
    T=n*m*2+2;
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%s",str);
        for(int j=1;j&lt;=m;j++)
        {
            add_edge(1,calc1(i,j),1,0);
            add_edge(calc2(i,j),T,1,0);
            int tar;
            switch(str[j-1])
            {
                case 'U':tar=calc3(i-1,j);break;
                case 'D':tar=calc3(i+1,j);break;
                case 'L':tar=calc3(i,j-1);break;
                case 'R':tar=calc3(i,j+1);break;
            }
            add_edge(calc1(i,j),tar,1,0);
            for(int k=0;k&lt;4;k++)
                if(calc3(i+dx[k],j+dy[k])!=tar)
                    add_edge(calc1(i,j),calc3(i+dx[k],j+dy[k]),1,1);
        }
    }

    while(spfa())
    {
        ans+=dist[T];
        for(int i=T;i!=S;i=e[rev(pre[i])].t)
        {
            e[pre[i]].c--;
            e[rev(pre[i])].c++;
        }
    }
    printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3175</h2><pre>#include&lt;cstdio&gt;

#define maxn 1000020
using namespace std;
int n;
char st[2000][200];
int x[8]={-1,-2,1,2,-1,-2,1,2};
int y[8]={-2,-1,-2,-1,2,1,2,1};

int tot=1;
int fir[maxn],en[maxn],nex[maxn],f[maxn];
inline void ins(int x,int y,int z)
{
	nex[++tot]=fir[x];
	fir[x]=tot;
	en[tot]=y;
	f[tot]=z;
	
	nex[++tot]=fir[y];
	fir[y]=tot;
	en[tot]=x;
	f[tot]=0;
}

int s,t;
int flog=0,sum=0;
int now[maxn],pre[maxn],his[maxn],num[maxn],d[maxn];
inline void sap()
{
    flog=0;
    for (int i=0;i&lt;=t;i++){
        now[i]=fir[i];
        num[i]=d[i]=0;
        }
    num[0]=sum;
    int i=s;
    bool flag;
    int aug=0x7fffffff/10;
    while (d[s]&lt;sum){
        flag=false;
        his[i]=aug;
        for (int k=now[i];k;k=nex[k]){
            int j=en[k];
            if ((d[i]==d[j]+1)&amp;&amp;(f[k]&gt;0)){
                now[i]=k;
                pre[j]=i;
                flag=true;
                if (aug&gt;f[k]) aug=f[k];
                i=j;
                if (i==t){
                    flog+=aug;
                    while (i!=s){
                        i=pre[i];
                        f[now[i]]-=aug;
                        f[now[i]^1]+=aug;
                        }
                    aug=0x7fffffff/10;
                    }
                break;
                }
            }
        if (flag) continue;
        int k1=0,minn=sum;
        for (int k=fir[i];k;k=nex[k])
            if (f[k]&gt;0&amp;&amp;minn&gt;d[en[k]]){
                minn=d[en[k]];
                k1=k;
                }
        --num[d[i]];
        if (num[d[i]]==0) return;
        d[i]=minn+1;
        ++num[d[i]];
        now[i]=k1;
        if (i!=s){
            i=pre[i];
            aug=his[i];
            }
        } 
}
int main()
{
	scanf("%d\n",&amp;n);
	for (int i=1;i&lt;=n;i++){
		for (int j=1;j&lt;=n;j++){
			scanf("%c",&amp;st[i][j]);
			if (st[i][j]=='0')
				sum++;
			}
		getchar();
		}
	
	s=0;t=n*n+1;
	sum=sum+2;
	for (int i=1;i&lt;=n;i++)
		for (int j=1;j&lt;=n;j++)
			if (st[i][j]=='0'){
				if ((i+j)%2==1){
					ins(s,(i-1)*n+j,1);
					for (int p=0;p&lt;8;p++)
						if (i+x[p]&gt;=1&amp;&amp;i+x[p]&lt;=n)
						if (j+y[p]&gt;=1&amp;&amp;j+y[p]&lt;=n)
						if (st[i+x[p]][j+y[p]]=='0')
							ins((i-1)*n+j,(i+x[p]-1)*n+j+y[p],0x7fffffff/10);
					}
				else ins((i-1)*n+j,t,1);
				}
	sap();
	printf("%d",sum-2-flog);
	return 0;
}</pre><pre></pre><h2>Problem3190</h2><pre>#include&lt;algorithm&gt;
#include&lt;cstdio&gt;

using namespace std;

int n;
int a[10010],b[10010],ans[10010];

int main()
{
    scanf("%d",&amp;n);
    
    for(int i=1;i&lt;=n;i++)
        scanf("%d",&amp;a[i]);
        
    for(int i=1;i&lt;=n;i++)
        scanf("%d",&amp;b[i]);
        
    for (int i = 1; i &lt;= n;i++)
	{
        double x=1e10,y=0;
        
        for(int j=1;j&lt;=n;j++)
            if (i!=j)
                if(a[j]&lt;=a[i]&amp;&amp;b[j]&gt;b[i])
                    x=min(x,double(a[i]-a[j])/(b[j]-b[i]));
                else 
					if(a[j]&gt;a[i])
					{
                    	if(b[j]&gt;=b[i])
						{
                        	y = 1e11;
                        	break;
						}
						
                    	y=max(y,double(a[j]-a[i])/(b[i]-b[j]));
					}
					
        if (x&gt;=y)ans[++ans[0]] = i;
    }
    
    printf("%d\n",ans[0]);
    
    for(int i=1;i&lt;ans[0];i++)
        printf("%d ",ans[i]);
    printf("%d\n",ans[ans[0]]);
    
    return 0;
}</pre><pre></pre><h2>Problem3192</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,n1,n2;
int tr[100010];
long long ans=0;

struct size
{
    int x,id;
}num[100010];

inline bool cmp(size x,size y)
{
    return x.x&gt;y.x;
}

inline int lowbit(int x)
{
    return x&amp;-x;
}

inline void add(int x)
{
    for(;x&lt;=n;x+=lowbit(x))
        tr[x]++;
}

inline void dec(int x)
{
    for(;x&lt;=n;x+=lowbit(x))
        tr[x]--;
}

inline int query(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp+=tr[x];
    return temp;
}

int main()
{
    scanf("%d%d",&amp;n1,&amp;n2);
    n=n1+n2;

    for(int i=1;i&lt;=n1;i++)
    {
        int x;
        scanf("%d",&amp;x);
        num[i].x=x;
        num[i].id=n1+1-i;
        add(n1+1-i);
    }

    for(int i=1;i&lt;=n2;i++)
    {
        int x;
        scanf("%d",&amp;x);
        num[i+n1].x=x;
        num[i+n1].id=n1+i;
        add(n1+i);
    }

    sort(num+1,num+n+1,cmp);

    int tag=n1;

    for(int i=1;i&lt;=n;i++)
    {
        //printf("%d %d %d %d\n",num[i].x,num[i].id,tag,ans);
        if(tag&gt;=num[i].id)
        {
            ans+=query(tag)-query(num[i].id);
            tag=num[i].id;
            dec(tag);
        }
        else
        {
            ans+=query(num[i].id-1)-query(tag);
            tag=num[i].id-1;
            dec(tag+1);
        }
    }

    printf("%lld\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

#define inf 100000000
#define N 200001
#define M 3500001

int n,m,sz,tmp,a[N];
int ls[M],rs[M],rnd[M],v[M],s[M],w[M];
int root[N];

inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void update(int k)
{s[k]=s[ls[k]]+s[rs[k]]+w[k];}
inline void rturn(int &amp;k)
{int t=ls[k];ls[k]=rs[t];rs[t]=k;s[t]=s[k];update(k);k=t;}
inline void lturn(int &amp;k)
{int t=rs[k];rs[k]=ls[t];ls[t]=k;s[t]=s[k];update(k);k=t;}
inline void insert(int &amp;k,int num)
{
    if(!k){k=++sz;s[k]=w[k]=1;v[k]=num;rnd[k]=rand();return;}
    s[k]++;
    if(num==v[k])w[k]++;
    else if(num&lt;v[k]){insert(ls[k],num);if(rnd[ls[k]]&lt;rnd[k])rturn(k);}
    else {insert(rs[k],num);if(rnd[rs[k]]&lt;rnd[k])lturn(k);}
}
inline void del(int &amp;k,int num)
{
    if(v[k]==num)
    {
        if(w[k]&gt;1){w[k]--;s[k]--;return;}
        if(ls[k]*rs[k]==0)k=ls[k]+rs[k];
        else if(rnd[ls[k]]&lt;rnd[rs[k]]){rturn(k);del(k,num);}
        else {lturn(k);del(k,num);}
    }
    else if(num&lt;v[k])
       {del(ls[k],num);s[k]--;}
    else {del(rs[k],num);s[k]--;}
}
inline void build(int k,int l,int r,int x,int num)
{
    insert(root[k],num);
    if(l==r)return;
    int mid=(l+r)&gt;&gt;1;
    if(x&lt;=mid)build(k&lt;&lt;1,l,mid,x,num);
    else build(k&lt;&lt;1|1,mid+1,r,x,num);
}
inline void ask_rank(int k,int num)
{
    if(!k)return;
    if(num==v[k]){tmp+=s[ls[k]];return;}
    else if(num&lt;v[k])ask_rank(ls[k],num);
    else {tmp+=s[ls[k]]+w[k];ask_rank(rs[k],num);}
}
inline void get_rank(int k,int l,int r,int x,int y,int num)
{
    if(l==x&amp;&amp;r==y){ask_rank(root[k],num);return;}
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=y)get_rank(k&lt;&lt;1,l,mid,x,y,num);
    else if(mid&lt;x)get_rank(k&lt;&lt;1|1,mid+1,r,x,y,num);
    else
    {
        get_rank(k&lt;&lt;1,l,mid,x,mid,num);
        get_rank(k&lt;&lt;1|1,mid+1,r,mid+1,y,num);
    }
}
inline void get_index(int x,int y,int z)
{
    int l=0,r=inf,ans;
    while(l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        tmp=1;get_rank(1,1,n,x,y,mid);
        if(tmp&lt;=z){l=mid+1;ans=mid;}
        else r=mid-1;
        }
    printf("%d\n",ans);
}
inline void change(int k,int l,int r,int x,int num,int y)
{
    del(root[k],y);
    insert(root[k],num);
    if(l==r)return;
    int mid=(l+r)&gt;&gt;1;
    if(x&lt;=mid)change(k&lt;&lt;1,l,mid,x,num,y);
    else change(k&lt;&lt;1|1,mid+1,r,x,num,y);
}
inline void before(int k,int num)
{
    if(!k)return;
    if(v[k]&lt;num){tmp=Max(v[k],tmp);before(rs[k],num);}
    else before(ls[k],num);
}
inline void after(int k,int num)
{
    if(!k)return;
    if(v[k]&gt;num){tmp=Min(v[k],tmp);after(ls[k],num);}
    else after(rs[k],num);
}
inline void ask_after(int k,int l,int r,int x,int y,int num)
{
    if(l==x&amp;&amp;r==y){after(root[k],num);return;}
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=y)ask_after(k&lt;&lt;1,l,mid,x,y,num);
    else if(mid&lt;x)ask_after(k&lt;&lt;1|1,mid+1,r,x,y,num);
    else
    {
        ask_after(k&lt;&lt;1,l,mid,x,mid,num);
        ask_after(k&lt;&lt;1|1,mid+1,r,mid+1,y,num);
    }
}
inline void ask_before(int k,int l,int r,int x,int y,int num)
{
    if(l==x&amp;&amp;r==y){before(root[k],num);return;}
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=y)ask_before(k&lt;&lt;1,l,mid,x,y,num);
    else if(mid&lt;x)ask_before(k&lt;&lt;1|1,mid+1,r,x,y,num);
    else
    {
        ask_before(k&lt;&lt;1,l,mid,x,mid,num);
        ask_before(k&lt;&lt;1|1,mid+1,r,mid+1,y,num);
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
    for(int i=1;i&lt;=n;i++)build(1,1,n,i,a[i]);
    for(int i=1;i&lt;=m;i++)
    {
        int f;scanf("%d",&amp;f);
        int x,y,k;
        switch(f)
        {
            case 1:scanf("%d%d%d",&amp;x,&amp;y,&amp;k);tmp=1;get_rank(1,1,n,x,y,k);printf("%d\n",tmp);break;
            case 2:scanf("%d%d%d",&amp;x,&amp;y,&amp;k);get_index(x,y,k);break;
            case 3:scanf("%d%d",&amp;x,&amp;y);change(1,1,n,x,y,a[x]);a[x]=y;break;
            case 4:scanf("%d%d%d",&amp;x,&amp;y,&amp;k);tmp=0;ask_before(1,1,n,x,y,k);printf("%d\n",tmp);break;
            case 5:scanf("%d%d%d",&amp;x,&amp;y,&amp;k);tmp=inf;ask_after(1,1,n,x,y,k);printf("%d\n",tmp);break;
            }
    }
    return 0;
}
</pre><pre></pre><h2>Problem3207</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;algorithm&gt;

using namespace std;

const int P1=434992819;
const int P2=19999999;

int n,q,k,siz,N;
int a[200010],root[200010];
int ls[7000010],rs[7000010],v[7000010];
unsigned int h1[200010],m1[200010];
unsigned int h2[200010],m2[200010];
map&lt;pair&lt;unsigned int,unsigned int&gt;,int&gt;h;

inline void init_hash()
{
	h1[0]=0;h2[0]=0;
	m1[0]=1;m2[0]=1;
	for(int i=1;i&lt;=n;i++)
	{
		h1[i]=h1[i-1]*P1+a[i];
		h2[i]=h2[i-1]*P2+a[i];
		m1[i]=m1[i-1]*P1;
		m2[i]=m2[i-1]*P2;
	}
}
inline unsigned int get_hash1(int x,int y)
{
	return h1[y]-h1[x-1]*m1[y-x+1];
}
inline unsigned int get_hash2(int x,int y)
{
	return h2[y]-h2[x-1]*m2[y-x+1];
}

inline void update(int l,int r,int&amp;y,int x,int pos)
{
	y=++siz;
	v[y]=v[x]+1;
	if(l==r)return;
	ls[y]=ls[x];rs[y]=rs[x];
	int mid=(l+r)&gt;&gt;1;
	if(pos&lt;=mid)update(l,mid,ls[y],ls[x],pos);
	else update(mid+1,r,rs[y],rs[x],pos);
}

inline bool query(int x,int y,int num)
{
	int l=1,r=N;
	while(l!=r)
	{
		if(v[y]-v[x]==0)return false;
		int mid=(l+r)&gt;&gt;1;
		if(num&lt;=mid)
		{
			x=ls[x];
			y=ls[y];
			r=mid;
		}
		else
		{
			x=rs[x];
			y=rs[y];
			l=mid+1;
		}
	}
	if(v[y]-v[x]==0)return false;else return true;
}

int main()
{
	scanf("%d%d%d",&amp;n,&amp;q,&amp;k);
	for(int i=1;i&lt;=n;i++)
		scanf("%d",a+i);
	init_hash();
	N=n-k+1;
	for(int i=1;i&lt;=N;i++)
		h[make_pair(get_hash1(i,i+k-1),get_hash2(i,i+k-1))]=i;
	for(int i=1;i&lt;=N;i++)
		update(1,N,root[i],root[i-1],h[make_pair(get_hash1(i,i+k-1),get_hash2(i,i+k-1))]);
	
	for(;q;q--)
	{
		int x,y,z;
		scanf("%d%d",&amp;x,&amp;y);
		unsigned int temp1=0,temp2=0;
		for(int i=1;i&lt;=k;i++)
		{
			scanf("%d",&amp;z);
			temp1=temp1*P1+z;
			temp2=temp2*P2+z;
		}
		
		y=y-k+1;
		if(y&lt;x)return false;
		
		if(!h[make_pair(temp1,temp2)])
		{
			printf("Yes\n");
			continue;
		}
		if(query(root[x-1],root[y],h[make_pair(temp1,temp2)]))
			printf("No\n");
		else
			printf("Yes\n");
	}
	
	return 0;
}</pre><pre></pre><h2>Problem3209</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int P=10000007;

long long n;
int num;
int a[60];
long long cnt[60];
long long f[60][60];

inline int pow(int x,long long y)
{
    if(!y)return 1;
    if(y==1)return x;
    int temp=pow(x,y&gt;&gt;1);
    temp=(long long)temp*temp%P;
    if(y&amp;1)temp=(long long)temp*x%P;
    return temp;
}

int main()
{
    scanf("%lld",&amp;n);
    n++;
    int num;
    for(num=1;n;num++)
    {
        a[num]=n&amp;1;
        n&gt;&gt;=1;
    }
    num--;
    f[0][0]=1;
    for(int i=1;i&lt;=num;i++)
    {
        f[i][0]=1;
        for(int j=1;j&lt;=i;j++)
            f[i][j]=f[i-1][j]+f[i-1][j-1];
    }

    int sum=0;
    for(int i=num;i&gt;=1;i--)
        if(a[i]==1)
    {
        for(int j=0;j&lt;=i-1;j++)
            cnt[j+sum]+=f[i-1][j];

        sum++;
    }
    int ans=1;

    for(int i=2;i&lt;=num;i++)
    {
        int temp=pow(i,cnt[i]);
        ans=(long long)ans*temp%P;
    }

    printf("%d\n",ans);

    return 0;
}
/*
1000000000000000
*/
</pre><pre></pre><h2>Problem3211</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

int n,m;
int data[100010],fa[100010];
long long tr[100010];

inline int lowbit(int x)
{
    return x&amp;(-x);
}

inline void add(int x,int num)
{
    for(;x&lt;=n;x+=lowbit(x))
        tr[x]+=num;
}

inline long long query(int x)
{
    long long temp=0;
    for(;x;x-=lowbit(x))
        temp+=tr[x];
    return temp;
}

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline void change(int l,int r)
{
    for(int i=find(l);i&lt;=r;i=find(i+1))
    {
        int temp=floor(sqrt(data[i]));
        add(i,temp-data[i]);
        if((data[i]=temp)==1)
            fa[i]=fa[i+1];
    }
}

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",data+i);
        add(i,data[i]);
    }

    int k=n+1;
    fa[k]=k;
    for(int i=n;i;i--)
    {
        if(data[i]&gt;1)k=i;
        fa[i]=k;
    }

    scanf("%d",&amp;m);

    for(;m;m--)
    {
/*
        for(int i=1;i&lt;=n;i++)
            printf("%d %d\n",data[i],fa[i]);
*/
        int x,l,r;
        scanf("%d%d%d",&amp;x,&amp;l,&amp;r);

        if(x==1)
            printf("%lld\n",query(r)-query(l-1));
        else
            change(l,r);
    }
    
    return 0;
}

/*
4
1 100 5 5
5
1 1 2
2 1 2
1 1 2
2 2 3
1 1 4
*/
</pre><pre></pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;

using namespace std;

struct Spl
{
    int val,siz,tag;
    Spl *ls,*rs,*fa;

    inline Spl():val(0),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Spl(const int&amp;x):val(x),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void New_node(int x)
    {
        *this=Spl(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag)
        {
            Spl*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag^=1;
            this-&gt;tag=0;
        }
    }
    inline void LR()
    {
        Spl*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
    }
    inline void RR()
    {
        Spl*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Spl*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline void Splay1()
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Spl*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Spl*Insert(int x)
    {
        Spl*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            if(x&lt;now-&gt;val)
                now=now-&gt;ls;
            else
                now=now-&gt;rs;
        }
        now=new Spl;
        now-&gt;New_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)
            if(x&lt;prv-&gt;val)prv-&gt;ls=now;
            else prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Spl*Get_kth(int x)//add_push_down
    {
        Spl*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }
    inline Spl*Get_kth1(int x)//add_push_down
    {
        Spl*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Spl*rev(int x,int y)
    {
        Spl*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y);
        now-&gt;ls-&gt;tag^=1;
        return now-&gt;fa;
    }
}*root;
int n,m;

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
    n=read();m=read();
    for(int i=0;i&lt;=n+1;i++)
        root=root-&gt;Insert(i);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        x=read();y=read();
        root=root-&gt;rev(x,y+2);
    }

    for(int i=1;i&lt;=n;i++)
    {
        root=root-&gt;Get_kth(i+1);
        printf("%d ",root-&gt;val);
    }
    printf("\n");

    return 0;
}
</pre><pre></pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;

struct Splay_tree
{
    int val,siz,tag;
    Splay_tree *ls,*rs,*fa;

    inline Splay_tree():val(0),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Splay_tree(const int&amp;x):val(x),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void New_node(int x)
    {
        *this=Splay_tree(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag)
        {
            Splay_tree*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag^=1;
            this-&gt;tag=0;
        }
    }
    inline void LR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
    }
    inline void RR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Insert(int x)
    {
        Splay_tree*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            if(x&lt;now-&gt;val)
                now=now-&gt;ls;
            else
                now=now-&gt;rs;
        }
        now=new Splay_tree;
        now-&gt;New_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)
            if(x&lt;prv-&gt;val)prv-&gt;ls=now;
            else prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Splay_tree*Get_kth(int x)
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }

    inline void Splay1()//for rev
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Get_kth1(int x)//for rev
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Splay_tree*rev(int x,int y)
    {
        Splay_tree*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y+2);
        now-&gt;ls-&gt;tag^=1;
        return now-&gt;fa;
    }
}*root;

int n,m;

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
    n=read();m=read();
    for(int i=0;i&lt;=n+1;i++)
        root=root-&gt;Insert(i);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        x=read();y=read();
        root=root-&gt;rev(x,y);
    }

    for(int i=1;i&lt;=n;i++)
    {
        root=root-&gt;Get_kth(i+1);
        printf("%d ",root-&gt;val);
    }
    printf("\n");

    return 0;
}
</pre><pre></pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;

int n,m;

struct Splay_tree
{
    int val,siz,tag;
    Splay_tree *ls,*rs,*fa;

    inline Splay_tree():val(0),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Splay_tree(const int&amp;x):val(x),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void New_node(int x)
    {
        *this=Splay_tree(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag)
        {
            Splay_tree*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag^=1;
            this-&gt;tag=0;
        }
    }
    inline void LR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
    }
    inline void RR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Insert(int x)
    {
        Splay_tree*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            if(x&lt;now-&gt;val)
                now=now-&gt;ls;
            else
                now=now-&gt;rs;
        }
        now=new Splay_tree;
        now-&gt;New_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)
            if(x&lt;prv-&gt;val)prv-&gt;ls=now;
            else prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Splay_tree*Get_kth(int x)
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }

    inline void Splay1()//for rev
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Get_kth1(int x)//for rev
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Splay_tree*rev(int x,int y)
    {
        Splay_tree*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y+2);
        now-&gt;ls-&gt;tag^=1;
        return now-&gt;fa;
    }
    inline Splay_tree*dfs()
    {
        this-&gt;push_down();
        if(this-&gt;ls)this-&gt;ls-&gt;dfs();
        if(this-&gt;val&gt;0&amp;&amp;this-&gt;val&lt;=n)printf("%d ",this-&gt;val);
        if(this-&gt;rs)this-&gt;rs-&gt;dfs();
    }
}*root;

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int main()
{
    n=read();m=read();
    for(int i=0;i&lt;=n+1;i++)
        root=root-&gt;Insert(i);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        x=read();y=read();
        root=root-&gt;rev(x,y);
    }

    root-&gt;dfs();
    printf("\n");

    return 0;
}
</pre><pre></pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;

const int BufS=1500000;
char buf[BufS],*p=buf;
inline int read()
{
	int res=0;
	while(*p&lt;48||*p&gt;57)++p;
	while(*p&gt;47&amp;&amp;*p&lt;58)res=res*10+*p++-48;
	return res;
}

int n,m;

struct Splay_tree
{
    int val,siz,tag;
    Splay_tree *ls,*rs,*fa;

    inline Splay_tree():val(0),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Splay_tree(const int&amp;x):val(x),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void New_node(int x)
    {
        *this=Splay_tree(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag)
        {
            Splay_tree*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag^=1;
            this-&gt;tag=0;
        }
    }
    inline void LR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
    }
    inline void RR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Insert(int x)
    {
        Splay_tree*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            if(x&lt;now-&gt;val)
                now=now-&gt;ls;
            else
                now=now-&gt;rs;
        }
        now=new Splay_tree;
        now-&gt;New_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)
            if(x&lt;prv-&gt;val)prv-&gt;ls=now;
            else prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Splay_tree*Get_kth(int x)
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }

    inline void Splay1()//for rev
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Get_kth1(int x)//for rev
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Splay_tree*rev(int x,int y)
    {
        Splay_tree*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y+2);
        now-&gt;ls-&gt;tag^=1;
        return now-&gt;fa;
    }
    inline Splay_tree*dfs()
    {
        this-&gt;push_down();
        if(this-&gt;ls)this-&gt;ls-&gt;dfs();
        if(this-&gt;val&gt;0&amp;&amp;this-&gt;val&lt;=n)printf("%d ",this-&gt;val);
        if(this-&gt;rs)this-&gt;rs-&gt;dfs();
    }
}*root;

int main()
{
    fread(p,1,BufS,stdin);
    n=read();m=read();
    for(int i=0;i&lt;=n+1;i++)
        root=root-&gt;Insert(i);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        x=read();y=read();
        root=root-&gt;rev(x,y);
    }

    root-&gt;dfs();
    printf("\n");

    return 0;
}
</pre><pre></pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

const int BufS=1500000;
char buf[BufS],*p=buf;
inline int read()
{
    int res=0;
    while(*p&lt;48||*p&gt;57)++p;
    while(*p&gt;47&amp;&amp;*p&lt;58)res=res*10+*p++-48;
    return res;
}

int n,m;

struct Splay_tree
{
    int val,siz,tag;
    Splay_tree *ls,*rs,*fa;

    inline Splay_tree():val(0),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Splay_tree(const int&amp;x):val(x),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void New_node(int x)
    {
        *this=Splay_tree(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag)
        {
            Splay_tree*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag^=1;
            this-&gt;tag=0;
        }
    }
    inline void LR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
    }
    inline void RR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Insert(int x)
    {
        Splay_tree*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            if(x&lt;now-&gt;val)
                now=now-&gt;ls;
            else
                now=now-&gt;rs;
        }
        now=new Splay_tree;
        now-&gt;New_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)
            if(x&lt;prv-&gt;val)prv-&gt;ls=now;
            else prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Splay_tree*Get_kth(int x)
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }

    inline void Splay1()//for rev
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Get_kth1(int x)//for rev
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Splay_tree*rev(int x,int y)
    {
        Splay_tree*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y+2);
        now-&gt;ls-&gt;tag^=1;
        return now-&gt;fa;
    }
    inline Splay_tree*dfs()
    {
        this-&gt;push_down();
        if(this-&gt;ls)this-&gt;ls-&gt;dfs();
        if(this-&gt;val&gt;0&amp;&amp;this-&gt;val&lt;=n)printf("%d ",this-&gt;val);
        if(this-&gt;rs)this-&gt;rs-&gt;dfs();
    }
}*root;

int v[100010];

int main()
{
    fread(p,1,BufS,stdin);
    n=read();m=read();
    for(int i=0;i&lt;=n+1;i++)
    {
        int x=rand()%(n+2);
        if(!v[x])
        {
            root=root-&gt;Insert(x);
            v[x]=1;
        }
    }
    for(int i=0;i&lt;=n+1;i++)
        if(!v[i])
            root=root-&gt;Insert(i);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        x=read();y=read();
        root=root-&gt;rev(x,y);
    }

    root-&gt;dfs();
    printf("\n");

    return 0;
}
</pre><pre></pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

const int BufS=1500000;
char buf[BufS],*p=buf;
inline int read()
{
    int res=0;
    while(*p&lt;48||*p&gt;57)++p;
    while(*p&gt;47&amp;&amp;*p&lt;58)res=res*10+*p++-48;
    return res;
}

int n,m;

struct Splay_tree
{
    int val,siz,tag;
    Splay_tree *ls,*rs,*fa;

    inline Splay_tree():val(0),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Splay_tree(const int&amp;x):val(x),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void New_node(int x)
    {
        *this=Splay_tree(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag)
        {
            Splay_tree*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag^=1;
            this-&gt;tag=0;
        }
    }
    inline void LR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
    }
    inline void RR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Insert(int x)
    {
        Splay_tree*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            now=now-&gt;rs;
        }
        now=new Splay_tree;
        now-&gt;New_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Splay_tree*Get_kth(int x)
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }

    inline void Splay1()//for rev
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Get_kth1(int x)//for rev
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Splay_tree*rev(int x,int y)
    {
        Splay_tree*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y+2);
        now-&gt;ls-&gt;tag^=1;
        return now-&gt;fa;
    }
    inline Splay_tree*dfs()
    {
        this-&gt;push_down();
        if(this-&gt;ls)this-&gt;ls-&gt;dfs();
        if(this-&gt;val&gt;0&amp;&amp;this-&gt;val&lt;=n)printf("%d ",this-&gt;val);
        if(this-&gt;rs)this-&gt;rs-&gt;dfs();
    }
}*root;

int main()
{
    fread(p,1,BufS,stdin);
    n=read();m=read();
    for(int i=0;i&lt;=n+1;i++)
        root=root-&gt;Insert(i);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        x=read();y=read();
        root=root-&gt;rev(x,y);
    }

    root-&gt;dfs();
    printf("\n");

    return 0;
}
</pre><pre></pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

const int BufS=1500000;
char buf[BufS],*p=buf;
inline int read()
{
    int res=0;
    while(*p&lt;48||*p&gt;57)++p;
    while(*p&gt;47&amp;&amp;*p&lt;58)res=res*10+*p++-48;
    return res;
}

int n,m;

struct Splay_tree
{
    int val,siz,tag;
    Splay_tree *ls,*rs,*fa;

    inline Splay_tree():val(0),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}
    inline Splay_tree(const int&amp;x):val(x),siz(1),tag(0),ls(NULL),rs(NULL),fa(NULL){}

    inline void New_node(const int&amp;x)
    {
        *this=Splay_tree(x);
    }
    inline void push_down()
    {
        if(this-&gt;tag)
        {
            Splay_tree*temp=this-&gt;ls;
            this-&gt;ls=this-&gt;rs;
            this-&gt;rs=temp;
            if(this-&gt;ls!=NULL)this-&gt;ls-&gt;tag^=1;
            if(this-&gt;rs!=NULL)this-&gt;rs-&gt;tag^=1;
            this-&gt;tag=0;
        }
    }
    inline void LR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;rs=this-&gt;ls;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;rs!=NULL)
        {
            f-&gt;rs-&gt;fa=f;
            f-&gt;siz+=f-&gt;rs-&gt;siz;
        }
        this-&gt;ls=f;
    }
    inline void RR()
    {
        Splay_tree*f=this-&gt;fa;
        f-&gt;siz-=this-&gt;siz;
        this-&gt;siz+=f-&gt;siz;
        f-&gt;ls=this-&gt;rs;
        if(f-&gt;fa!=NULL)
            if(f-&gt;fa-&gt;ls==f)
                f-&gt;fa-&gt;ls=this;
            else
                f-&gt;fa-&gt;rs=this;
        this-&gt;fa=f-&gt;fa;
        f-&gt;fa=this;


        if(f-&gt;ls!=NULL)
        {
            f-&gt;ls-&gt;fa=f;
            f-&gt;siz+=f-&gt;ls-&gt;siz;
        }
        this-&gt;rs=f;
    }
    inline void Splay()
    {
        while(this-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Insert(const int&amp;x)
    {
        Splay_tree*prv=NULL,*now=this;
        while(now!=NULL)
        {
            now-&gt;siz++;
            prv=now;
            now=now-&gt;rs;
        }
        now=new Splay_tree;
        now-&gt;New_node(x);
        now-&gt;fa=prv;
        if(prv!=NULL)prv-&gt;rs=now;
        now-&gt;Splay();
        return now;
    }
    inline Splay_tree*Get_kth(int x)
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay();
        return p;
    }

    inline void Splay1()//for rev
    {
        while(this-&gt;fa-&gt;fa!=NULL)
        {
            Splay_tree*f=this-&gt;fa;
            if(f-&gt;fa-&gt;fa==NULL)
            {
                if(this==f-&gt;ls)this-&gt;RR();
                else this-&gt;LR();
            }
            else
            {
                if(f==f-&gt;fa-&gt;ls)
                {
                    if(this==f-&gt;ls)
                    {f-&gt;RR();this-&gt;RR();}
                    else
                    {this-&gt;LR();this-&gt;RR();}
                }
                else
                {
                    if(this==f-&gt;ls)
                    {this-&gt;RR();this-&gt;LR();}
                    else
                    {f-&gt;LR();this-&gt;LR();}
                }
            }
        }
    }
    inline Splay_tree*Get_kth1(int x)//for rev
    {
        Splay_tree*p=this;
        while(x)
        {
            p-&gt;push_down();
            if(p-&gt;ls!=NULL)
                if(x&lt;=p-&gt;ls-&gt;siz)
                {
                    p=p-&gt;ls;
                    continue;
                }
                else
                    x-=p-&gt;ls-&gt;siz;
            x--;
            if(x)p=p-&gt;rs;
        }
        p-&gt;Splay1();
        return p;
    }
    inline Splay_tree*rev(const int&amp;x,const int&amp;y)
    {
        Splay_tree*now=this;
        now=now-&gt;Get_kth(x);
        now=now-&gt;Get_kth1(y+2);
        now-&gt;ls-&gt;tag^=1;
        return now-&gt;fa;
    }
    inline Splay_tree*dfs()
    {
        this-&gt;push_down();
        if(this-&gt;ls)this-&gt;ls-&gt;dfs();
        if(this-&gt;val&gt;0&amp;&amp;this-&gt;val&lt;=n)printf("%d ",this-&gt;val);
        if(this-&gt;rs)this-&gt;rs-&gt;dfs();
    }
}*root;

int main()
{
    fread(p,1,BufS,stdin);
    n=read();m=read();
    for(int i=0;i&lt;=n+1;i++)
        root=root-&gt;Insert(i);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        x=read();y=read();
        root=root-&gt;rev(x,y);
    }

    root-&gt;dfs();
    printf("\n");

    return 0;
}
</pre><pre></pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt;
int left[1000000],right[1000000],key[1000000],s[1000000];

inline void RR(int &amp;x)
{
    int y=left[x];
    left[x]=right[y];
    right[y]=x;
    s[y]=s[x];
    s[x]=s[left[x]]+s[right[x]]+1;
    x=y;
}
inline void LR(int &amp;x)
{
    int y=right[x];
    right[x]=left[y];
    left[y]=x;
    s[y]=s[x];
    s[x]=s[left[x]]+s[right[x]]+1;
    x=y;
}

inline void Maintain(int &amp;x,bool flag)
{
    if(!flag)
        if(s[left[left[x]]]&gt;s[right[x]])
            RR(x);
        else
            if(s[right[left[x]]]&gt;s[right[x]])
            {LR(left[x]);RR(x);}
            else
                return;
    else
        if(s[right[right[x]]]&gt;s[left[x]])
            LR(x);
        else
            if(s[left[right[x]]]&gt;s[left[x]])
            {RR(right[x]);LR(x);}
            else
                return;
    Maintain(left[x],false);
    Maintain(right[x],true);
    Maintain(x,false);
    Maintain(x,true);
}

inline int New_node(int v)
{
    key[++cnt]=v;
    s[cnt]=1;
    left[cnt]=0;
    right[cnt]=0;
    return cnt;
}
inline void ins(int &amp;x,int v)
{
    if(!x)
        x=New_node(v);
    else
    {
        s[x]++;
        if(v&lt;key[x])
            ins(left[x],v);
        else
            ins(right[x],v);
        Maintain(x,v&gt;=key[x]);
    }
}

inline int del(int &amp;x,int v)
{
    s[x]--;
    if((v==key[x])||(v&lt;key[x])&amp;&amp;(left[x]==0)||(v&gt;key[x])&amp;&amp;(right[x]==0))
    {
        int temp=key[x];
        if(left[x]==0||right[x]==0)
            x=left[x]+right[x];
        else
            key[x]=del(left[x],v+1);
        return temp;
    }
    else
        if(v&lt;key[x])
            return del(left[x],v);
        else
            return del(right[x],v);
}
/*
inline bool find(int x,int v)
{
    while(x)
    {
        if(v==key[x])return true;
        if(v&lt;key[x])
            x=left[x];
        else
            x=right[x];
    }
    return false;
}

inline int get_min(int x)
{
    while(left[x])x=left[x];
    return key[x];
}
inline int get_max(int x)
{
    while(right[x])x=right[x];
    return key[x];
}
*/

inline int rank(int x,int v)
{
    if(!x)return 1;

    if(v&lt;=key[x])
        return rank(left[x],v);
    else
        return s[left[x]]+1+rank(right[x],v);
}
inline int select(int x,int v)
{
    if(v==s[left[x]]+1)return key[x];
    if(v&lt;=s[left[x]])
        return select(left[x],v);
    else
        return select(right[x],v-s[left[x]]-1);
}

inline int pred(int x,int v)
{
    int temp=0;
    while(x)
    {
        if(key[x]&lt;v)
        {
            temp=key[x];
            x=right[x];
        }
        else
            x=left[x];
    }
    return temp;
}
inline int succ(int x,int v)
{
    int temp=0;
    while(x)
    {
        if(key[x]&gt;v)
        {
            temp=key[x];
            x=left[x];
        }
        else
            x=right[x];
    }
    return temp;
}

int main()
{
    scanf("%d",&amp;n);

    int x,root=0;
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;x);

        if(x==1)
        {
            scanf("%d",&amp;x);
            ins(root,x);
            continue;
        }
        if(x==2)
        {
            scanf("%d",&amp;x);
            del(root,x);
            continue;
        }
        if(x==3)
        {
            scanf("%d",&amp;x);
            printf("%d\n",rank(root,x));
            continue;
        }
        if(x==4)
        {
            scanf("%d",&amp;x);
            printf("%d\n",select(root,x));
            continue;
        }
        if(x==5)
        {
            scanf("%d",&amp;x);
            printf("%d\n",pred(root,x));
            continue;
        }
        scanf("%d",&amp;x);
        printf("%d\n",succ(root,x));
    }

    return 0;
}
</pre><pre></pre><h2>Problem3226</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int n=131073;

char ch[5];
int v[n];
struct seg_tree
{
    int l,r,val;
    int tag;
}seg[600010];

inline int read()
{
    int temp=0,f=0;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')
    {
        if(c=='(')f=-1;
        c=getchar();
    }
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
	if(c==')')f=1;
    return temp*2-f+1;
}

inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r)return;
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
}
inline void modify(int p,int v)
{
    if(v==1)
    {
        seg[p].val=0;
        seg[p].tag=1;
    }
    else
        if(v==2)
        {
            seg[p].val=1;
            seg[p].tag=2;
        }
        else
        {
            if(seg[p].val&gt;=0&amp;&amp;seg[p].val&lt;=1)seg[p].val=1-seg[p].val;
            seg[p].tag=3-seg[p].tag;
        }
}
inline void push_down(int p)
{
    if(!seg[p].tag)return;
    modify(p&lt;&lt;1,seg[p].tag);
    modify(p&lt;&lt;1|1,seg[p].tag);
    seg[p].tag=0;
}
inline void build1(int p)
{
    if(seg[p].l==seg[p].r)
    {
        v[seg[p].l]=seg[p].val;
        return;
    }
    push_down(p);
    build1(p&lt;&lt;1);
    build1(p&lt;&lt;1|1);
}

inline void update(int p,int l,int r,int v)
{
    if(l&gt;r)return;
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)
    {
        modify(p,v);
        return;
    }
    push_down(p);
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        update(p&lt;&lt;1,l,r,v);
    else
        if(l&gt;mid)
            update(p&lt;&lt;1|1,l,r,v);
        else
        {
            update(p&lt;&lt;1,l,r,v);
            update(p&lt;&lt;1|1,l,r,v);
        }
    if(seg[p&lt;&lt;1].val==seg[p&lt;&lt;1|1].val)
        seg[p].val=seg[p&lt;&lt;1].val;
    else
        seg[p].val=2;
}

int main()
{
    build(1,1,n);
    while(scanf("%s",ch)!=EOF)
	{
		int a=read(),b=read();
		switch(ch[0])
		{
            case 'U':update(1,a,b,2);break;
            case 'I':update(1,1,a-1,1);update(1,b+1,n,1);break;
            case 'D':update(1,a,b,1);break;
            case 'C':update(1,1,a-1,1);update(1,b+1,n,1);update(1,a,b,3);break;
            case 'S':update(1,a,b,3);break;
		}
	}
	build1(1);

	int h=-1,t=-1,flag=0;
	for(int i=1;i&lt;=n;i++)
		if(v[i])
		{
			if(h==-1)h=i;
			t=i;
		}
		else
        {
            if(h!=-1)
			{
				if(flag)printf(" ");
				else flag=1;
				if(h&amp;1)
                    printf("[");
				else
                    printf("(");
				printf("%d,%d",(h-1)&gt;&gt;1,t&gt;&gt;1);
				if(t&amp;1)
                    printf("]");
				else
                    printf(")");
			}
			h=-1;
			t=-1;
        }
	if(!flag)printf("empty set\n");

	return 0;
}
</pre><pre></pre><h2>Problem3236</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m;
int a[100010];
int cnt[100010],tra[100010],trb[100010];
int ans1[1000010],ans2[1000010];
int pos[1000010];
pair&lt;pair&lt;int,int&gt;,int&gt;Q[1000010];

struct size
{
    int l,r,a,b,id;
}q[1000010];

inline int read()
{
    int temp=0;
    char c=getchar();
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline int lowbit(int x)
{
    return x&amp;-x;
}

inline void modify1(int x,int num)
{
    for(;x&lt;=n;x+=lowbit(x))
        tra[x]+=num;
}
inline void modify3(int x,int num)
{
    for(;x&lt;=n;x+=lowbit(x))
    {
        tra[x]+=num;
        trb[x]+=num;
    }
}

inline int query1(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp+=tra[x];
    return temp;
}
inline int query2(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp+=trb[x];
    return temp;
}

inline void add(int x)
{
    cnt[x]++;
    if(cnt[x]==1)
        modify3(x,1);
    else
        modify1(x,1);
}
inline void dec(int x)
{
    cnt[x]--;
    if(cnt[x]==0)
        modify3(x,-1);
    else
        modify1(x,-1);
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read();

    int limit=0;
    while(limit*limit&lt;n)++limit;
    for(int i=1;i&lt;=m;i++)
    {
        q[i].l=read();q[i].r=read();
        q[i].a=read();q[i].b=read();
        Q[i].first.first=q[i].l/limit;
        Q[i].first.second=q[i].r;
		Q[i].second=i;
    }

    sort(Q+1,Q+m+1);
    a[0]=1;
    cnt[1]=1;
    modify3(1,1);
    for(int i=1,l=0,r=0;i&lt;=m;i++)
    {
        int temp=Q[i].second;
        while(l&lt;q[temp].l)dec(a[l++]);
        while(l&gt;q[temp].l)add(a[--l]);
        while(r&gt;q[temp].r)dec(a[r--]);
        while(r&lt;q[temp].r)add(a[++r]);
        ans1[temp]=query1(q[temp].b)-query1(q[temp].a-1);
        ans2[temp]=query2(q[temp].b)-query2(q[temp].a-1);
    }

    for(int i=1;i&lt;=m;i++)
        printf("%d %d\n",ans1[i],ans2[i]);
    return 0;
}
</pre><pre></pre><h2>Problem3251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,q,cnt;
int a[60];
int v[100010],g[100010],dep[100010];
int fa[100010][18];
struct edge
{
    int t,next;
}e[200010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void dfs(int x)
{
    for(int i=1;i&lt;18;i++)
        fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa[x][0])
        {
            fa[e[i].t][0]=x;
            dep[e[i].t]=dep[x]+1;
            dfs(e[i].t);
        }
}

inline void swim(int&amp;x,int h)
{
    for(int i=0;h;i++)
    {
        if(h&amp;1)x=fa[x][i];
        h&gt;&gt;=1;
    }
}

inline int lca(int x,int y)
{
    if(dep[x]&lt;dep[y])Swap(x,y);
    swim(x,dep[x]-dep[y]);
    while(x!=y)
    {
        int i;
        for(i=0;fa[x][i]!=fa[y][i];i++);
        if(i==0)return fa[x][0];
        x=fa[x][i-1];
        y=fa[y][i-1];
    }
    return x;
}

int main()
{
    n=read();q=read();
    for(int i=1;i&lt;=n;i++)
        v[i]=read();
    for(int i=1;i&lt;n;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(x,y);
        add_edge(y,x);
    }
    dep[1]=1;
    fa[1][0]=1;
    dfs(1);
    for(;q;q--)
    {
        int x,y;
        x=read();
        if(x==0)
        {
            x=read();y=read();
            int z=lca(x,y);
            int num=dep[x]+dep[y]-(dep[z]&lt;&lt;1)+1;
            if(num&gt;=52)
            {
                printf("Y\n");
                continue;
            }
            num=0;
            for(;x!=z;x=fa[x][0])
                a[++num]=v[x];
            for(;y!=z;y=fa[y][0])
                a[++num]=v[y];
            a[++num]=v[z];
            sort(a+1,a+num+1);
            bool flag=false;
            for(int i=3;i&lt;=num;i++)
                if(a[i-2]&gt;a[i]-a[i-1])
                {
                    flag=true;
                    break;
                }
            if(flag)
                printf("Y\n");
            else
                printf("N\n");
        }
        else
        {
            x=read();y=read();
            v[x]=y;
        }
    }
    return 0;
}
</pre><pre></pre><h2>Problem3258</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int inf=1000000000;
const long long Inf=(long long)1000000000*1000000000;

int n,m,cnt,cnt1,N;
int g[5010];
int G[410],a[410];

struct edge
{
    int s,t,c,next;
}e[50000],e1[50000];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
    e1[++cnt1].t=y;
    e1[cnt1].c=z;
    e1[cnt1].next=G[x];
    G[x]=cnt1;
}

inline void add_edge1(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].s=x;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline void init()
{
    cnt1=0;
    memset(G,0,sizeof(G));
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;n;i++)
        scanf("%d",a+i);
    a[n]=inf;
    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        add_edge(x,y,z);
        add_edge(y,x,z);
    }
}

int q[410],inque[410];
long long dist[410];
inline void spfa()
{
    dist[1]=0;
    for(int i=2;i&lt;=n;i++)
        dist[i]=Inf;
    int h=0,t=1;
    q[1]=1;
    inque[1]=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        inque[x]=0;

        for(int i=G[x];i;i=e1[i].next)
            if(dist[x]+e1[i].c&lt;dist[e1[i].t])
            {
                dist[e1[i].t]=dist[x]+e1[i].c;
                if(!inque[e1[i].t])
                {
                    inque[e1[i].t]=1;
                    t=t%n+1;
                    q[t]=e1[i].t;
                }
            }
    }
}

inline void make_graph()
{
    N=n;
    cnt=0;
    memset(g,0,sizeof(g));
    for(int i=1;i&lt;=n;i++)
        for(int j=G[i];j;j=e1[j].next)
            if(dist[i]+e1[j].c==dist[e1[j].t])
            {
                N++;
                add_edge1(i,N,a[i]);
                add_edge1(N,e1[j].t,a[e1[j].t]);
            }
}

inline int rev(int x)
{
    return x&amp;1?x+1:x-1;
}

int vh[5010],di[5010],dis[5010],pre[5010],his[5010];
inline long long isap()
{
    memset(vh,0,sizeof(vh));
    memset(dis,0,sizeof(dis));
    vh[0]=N;
    for(int i=1;i&lt;=N;i++)di[i]=g[i];
    int aug=inf,x=1;
    long long flow=0;

    while(dis[1]&lt;N)
    {
        bool flag=false;
        his[x]=aug;

        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                aug=min(aug,e[i].c);
                di[x]=i;
                pre[e[i].t]=rev(i);
                x=e[i].t;

                if(x==n)
                {
                    flow+=aug;

                    while(x!=1)
                    {
                        e[pre[x]].c+=aug;
                        e[rev(pre[x])].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=inf;
                }
                break;
            }

        if(flag)continue;

        vh[dis[x]]--;
        if(!vh[dis[x]])break;

        int mi=N,mii=0;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=1)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int block,idx,h;
int dfn[5010],low[5010],stack[5010],bel[5010];
bool instack[5010];
inline void dfs(int x)
{
    dfn[x]=low[x]=++idx;
    stack[++h]=x;
    instack[x]=true;

    for(int i=g[x];i;i=e[i].next)
        if(e[i].c)
            if(!dfn[e[i].t])
            {
                dfs(e[i].t);
                low[x]=min(low[x],low[e[i].t]);
            }
            else
                if(instack[e[i].t])
                    low[x]=min(low[x],dfn[e[i].t]);

    if(dfn[x]==low[x])
    {
        block++;
        while(stack[h]!=x)
        {
            bel[stack[h]]=block;
            instack[stack[h--]]=false;
        }
        bel[stack[h]]=block;
        instack[stack[h--]]=false;
    }
}
inline void tarjan_scc()
{
    block=0;
    h=0;
    idx=0;
    memset(dfn,0,sizeof(dfn));
    for(int i=1;i&lt;=N;i++)
        if(!dfn[i])
            dfs(i);
}

inline bool uniq()
{
    for(int i=1;i&lt;cnt;i+=2)
        if(!e[i].c)
            if(bel[e[i].s]!=bel[e[i].t])
                if(bel[1]!=bel[e[i].s]||bel[e[i].t]!=bel[n])
                    return false;
    return true;
}

int main()
{
    int T;
    scanf("%d",&amp;T);

    for(;T;T--)
    {
        init();
        spfa();
        make_graph();
        long long temp=isap();
        tarjan_scc();
        if(uniq())
            printf("Yes");
        else
            printf("No");
        printf(" %lld\n",temp);
    }

    return 0;
}</pre><pre></pre><h2>Problem3261</h2><pre>#include&lt;cstdio&gt;

int n,q,siz,S;
int b[30];
int root[600000];
int ls[15000000],rs[15000000],sum[15000000];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void ins(int pos,int val)
{
    int now=++siz,pre=root[pos-1];
    root[pos]=now;
    for(int i=23;i&gt;=0;i--)
    {
        ls[now]=ls[pre];rs[now]=rs[pre];
        if(val&amp;b[i])
        {
            rs[now]=++siz;
            now=siz;
            pre=rs[pre];
        }
        else
        {
            ls[now]=++siz;
            now=siz;
            pre=ls[pre];
        }
        sum[now]=sum[pre]+1;
    }
}
inline int query(int x,int y,int val)
{
    int temp=0;
    for(int i=23;i&gt;=0;i--)
    {
        if(val&amp;b[i])
        {
            if(sum[ls[y]]&gt;sum[ls[x]])
            {
                temp|=b[i];
                x=ls[x];y=ls[y];
            }
            else
            {
                x=rs[x];y=rs[y];
            }
        }
        else
        {
            if(sum[rs[y]]&gt;sum[rs[x]])
            {
                temp|=b[i];
                x=rs[x];y=rs[y];
            }
            else
            {
                x=ls[x];y=ls[y];
            }
        }
    }
    return temp;
}

int main()
{
    b[0]=1;
    for(int i=1;i&lt;=23;i++)
        b[i]=(b[i-1]&lt;&lt;1);

    ins(1,S=0);
    n=read();n++;q=read();
    for(int i=2;i&lt;=n;i++)
    {
        S^=read();
        ins(i,S);
    }

    for(;q;q--)
    {
        char ch[5];
        scanf("%s",ch);
        if(ch[0]=='A')
        {
            S^=read();
            ins(++n,S);
        }
        else
        {
            int l,r;
            l=read();r=read();
            printf("%d\n",query(root[l-1],root[r],S^read()));
        }
    }

    return 0;
}
</pre><pre></pre><h2>Problem3261</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,q,siz,S;
int b[30];
int root[600000];
int ls[15000000],rs[15000000],sum[15000000];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void ins(int pos,int val)
{
    bitset&lt;24&gt;v=val;
    int now=++siz,pre=root[pos-1];
    root[pos]=now;
    for(int i=23;i&gt;=0;i--)
    {
        ls[now]=ls[pre];rs[now]=rs[pre];
        if(v.test(i))
        {
            rs[now]=++siz;
            now=siz;
            pre=rs[pre];
        }
        else
        {
            ls[now]=++siz;
            now=siz;
            pre=ls[pre];
        }
        sum[now]=sum[pre]+1;
    }
}
inline int query(int x,int y,int val)
{
    bitset&lt;24&gt;v=val;
    int temp=0;
    for(int i=23;i&gt;=0;i--)
    {
        if(v.test(i))
        {
            if(sum[ls[y]]&gt;sum[ls[x]])
            {
                temp|=b[i];
                x=ls[x];y=ls[y];
            }
            else
            {
                x=rs[x];y=rs[y];
            }
        }
        else
        {
            if(sum[rs[y]]&gt;sum[rs[x]])
            {
                temp|=b[i];
                x=rs[x];y=rs[y];
            }
            else
            {
                x=ls[x];y=ls[y];
            }
        }
    }
    return temp;
}

int main()
{
    b[0]=1;
    for(int i=1;i&lt;=23;i++)
        b[i]=(b[i-1]&lt;&lt;1);

    ins(1,S=0);
    n=read();n++;q=read();
    for(int i=2;i&lt;=n;i++)
    {
        S^=read();
        ins(i,S);
    }

    for(;q;q--)
    {
        char ch[5];
        scanf("%s",ch);
        if(ch[0]=='A')
        {
            S^=read();
            ins(++n,S);
        }
        else
        {
            int l,r;
            l=read();r=read();
            printf("%d\n",query(root[l-1],root[r],S^read()));
        }
    }

    return 0;
}
</pre><pre></pre><h2>Problem3262</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,K,siz;
int root[200010],ans[100010];
int ls[20000010],rs[20000010],v[20000010];

struct flower
{
    int a,b,c;
    inline friend bool operator&lt;(const flower&amp;x,const flower&amp;y)
    {
        return x.a&lt;y.a;
    }
}s[100010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void modify(int l,int r,int&amp;y,int x,int pos)
{
    y=++siz;
    ls[y]=ls[x];rs[y]=rs[x];v[y]=v[x]+1;
    if(l==r)return;
    int mid=(l+r)&gt;&gt;1;
    if(pos&lt;=mid)
        modify(l,mid,ls[y],ls[x],pos);
    else
        modify(mid+1,r,rs[y],rs[x],pos);
}
inline int query(int p,int l,int r,int pos)
{
    if(r&lt;=pos)return v[p];
    int mid=(l+r)&gt;&gt;1;
    if(pos&lt;=mid)
        return query(ls[p],l,mid,pos);
    else
        return query(ls[p],l,mid,pos)+query(rs[p],mid+1,r,pos);
}

inline int lowbit(int x)
{
    return x&amp;-x;
}
inline void add(int x,int y)
{
    for(;x&lt;=K;x+=lowbit(x))
        modify(1,K,root[x],root[x],y);
}
inline int qry(int x,int y)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp+=query(root[x],1,K,y);
    return temp;
}

int main()
{
    n=read();K=read();
    for(int i=1;i&lt;=n;i++)
    {
        s[i].a=read();
        s[i].b=read();
        s[i].c=read();
    }
    sort(s+1,s+n+1);

    for(int i=1;i&lt;=n;i++)
    {
        int S=i;
        while(i&lt;n&amp;&amp;s[i+1].a==s[i].a)i++;
        for(int j=S;j&lt;=i;j++)
            add(s[j].b,s[j].c);
        for(int j=S;j&lt;=i;j++)
            ans[qry(s[j].b,s[j].c)-1]++;
    }

    for(int i=0;i&lt;n;i++)
        printf("%d\n",ans[i]);

    return 0;
}
</pre><pre></pre><h2>Problem3275</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const int INF=1000000000;

int n,m,S=1,T,cnt;
long long sum=0;
int a[3010];
int g[6010],vh[6010],di[6010],dis[6010],pre[6010],his[6010];
struct edge
{
    int t,c,next;
}e[5000000];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline int rev(int x)
{
    return x&amp;1?x+1:x-1;
}
inline int Gcd(int a,int b)
{
    return b==0?a:Gcd(b,a%b);
}

inline bool judge(int x,int y)
{
    long long z1=x*x+y*y;long long z2=(long long)sqrt(z1);
    if((long long)z2*z2!=z1)return false;
    if(Gcd(x,y)!=1)return false;
    return true;
}

inline long long isap()
{
    vh[0]=T;
    for(int i=S;i&lt;=T;i++)
        di[i]=g[i];
    int x=S,aug=INF;
    long long flow=0;

    while(dis[1]&lt;T)
    {
        his[x]=aug;
        bool flag=false;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[x]==dis[e[i].t]+1)
            {
                flag=true;
                di[x]=i;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=rev(i);
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[rev(pre[x])].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        int mi=T,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;
        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();
    T=n+n+2;
    for(int i=1;i&lt;=n;i++)
    {
        a[i]=read();sum+=a[i];
        add_edge(S,i+1,a[i]);
        add_edge(i+n+1,T,a[i]);
        for(int j=1;j&lt;i;j++)
            if(judge(a[i],a[j]))
            {
                add_edge(i+1,j+n+1,INF);
                add_edge(j+1,i+n+1,INF);
            }
    }

    printf("%lld\n",sum-isap()/2);

    return 0;
}
</pre><pre></pre><h2>Problem3275</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const int INF=1000000000;

int n,m,S=1,T,cnt;
long long sum=0;
int a[3010];
int g[6010],vh[6010],di[6010],dis[6010],pre[6010],his[6010];
struct edge
{
    int t,c,next;
}e[500000];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline int rev(int x)
{
    return x&amp;1?x+1:x-1;
}
inline int Gcd(int a,int b)
{
    return b==0?a:Gcd(b,a%b);
}

inline bool judge(int x,int y)
{
    long long z1=x*x+y*y;long long z2=(long long)sqrt(z1);
    if((long long)z2*z2!=z1)return false;
    if(Gcd(x,y)!=1)return false;
    return true;
}

inline long long isap()
{
    vh[0]=T;
    for(int i=S;i&lt;=T;i++)
        di[i]=g[i];
    int x=S,aug=INF;
    long long flow=0;

    while(dis[1]&lt;T)
    {
        his[x]=aug;
        bool flag=false;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[x]==dis[e[i].t]+1)
            {
                flag=true;
                di[x]=i;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=rev(i);
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[rev(pre[x])].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        int mi=T,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;
        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();
    T=n+n+2;
    for(int i=1;i&lt;=n;i++)
    {
        a[i]=read();sum+=a[i];
        add_edge(S,i+1,a[i]);
        add_edge(i+n+1,T,a[i]);
        for(int j=1;j&lt;i;j++)
            if(judge(a[i],a[j]))
            {
                add_edge(i+1,j+n+1,INF);
                add_edge(j+1,i+n+1,INF);
            }
    }

    printf("%lld\n",sum-isap()/2);

    return 0;
}
</pre><pre></pre><h2>Problem3280</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=0x3fffffff;

int tt;
int n,m,k,siz,sum;
int ans,sigflow;
int que[2010],dist[2010],flow[2010],pre[2010];

bitset&lt;2010&gt; inque;

struct size1
{
    int t,c,fe;
}edge[20000];

struct size
{
    int ch;
    size *next;
}*g[2010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int fx(int x)
{
    return x*2;
}

inline int gx(int x)
{
    return x*2+1;
}

inline int hx(int x)
{
    return n*2+1+x;
}

inline void add_edge(int x,int y,int z,int fe)
{
    edge[++siz].t=y;
    edge[siz].c=z;
    edge[siz].fe=fe;

    size *p=new size;
    p-&gt;ch=siz;
    p-&gt;next=g[x];
    g[x]=p;

    edge[++siz].t=x;
    edge[siz].c=0;
    edge[siz].fe=-fe;

    p=new size;
    p-&gt;ch=siz;
    p-&gt;next=g[y];
    g[y]=p;
}

inline bool spfa()
{
    memset(dist,63,sizeof(dist));
    memset(flow,0,sizeof(flow));
    dist[1]=0;
    flow[1]=inf;

    inque.reset();
    inque.set(1);
    int h=0,t=1;
    que[1]=1;

    while(h!=t)
    {
        h=h%n+1;
        int x=que[h];
        inque.flip(x);

        for(size *p=g[x];p;p=p-&gt;next)
            if(edge[p-&gt;ch].c&amp;&amp;dist[x]+edge[p-&gt;ch].fe&lt;dist[edge[p-&gt;ch].t])
        {
            int child=edge[p-&gt;ch].t;
            dist[child]=dist[x]+edge[p-&gt;ch].fe;
            flow[child]=min(flow[x],edge[p-&gt;ch].c);
            pre[child]=1^p-&gt;ch;

            if(!inque.test(child))
            {
                inque.set(child);
                t=t%n+1;
                que[t]=child;
            }
        }
    }

    return flow[n]==0?false:true;
}

int main()
{
    scanf("%d",&amp;tt);
    for(int t=1;t&lt;=tt;t++)
    {
        ans=sigflow=sum=0;
        siz=-1;

        scanf("%d%d%d",&amp;n,&amp;m,&amp;k);

        for(int i=1;i&lt;=n;i++)
        {
            int x;
            scanf("%d",&amp;x);
            sum+=x;
            add_edge(fx(i),n*2+m+2,x,0);
            add_edge(1,gx(i),x,0);
            if(i&lt;n)add_edge(fx(i),fx(i+1),inf,0);
        }

        for(int i=1;i&lt;=m;i++)
        {
            int x,y;
            scanf("%d%d",&amp;x,&amp;y);
            add_edge(1,hx(i),x,0);
            add_edge(hx(i),fx(1),inf,y);
        }

        for(int i=1;i&lt;=k;i++)
        {
            int x,y;
            scanf("%d%d",&amp;x,&amp;y);
            for(int j=1;j&lt;=n;j++)
                if(j&lt;n-x)
                    add_edge(gx(j),fx(j+x+1),inf,y);
                else
                    break;
        }

        n=n*2+m+2;

        while(spfa())
        {
            ans+=dist[n]*flow[n];
            sigflow+=flow[n];
            for(int i=n;i!=1;i=edge[pre[i]].t)
            {
                edge[pre[i]].c+=flow[n];
                edge[1^pre[i]].c-=flow[n];
            }
        }

        printf("Case %d: ",t);
        if(sigflow&lt;sum)
            printf("impossible\n");
        else
            printf("%d\n",ans);
        for(int i=1;i&lt;=n;i++)g[i]=NULL;
    }

    return 0;
}
/*
4 1 2 3 2 1
8 2 1 6
*/
</pre><pre></pre><h2>Problem3289</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;

using namespace std;

int n,num,N;
int S[230],T[230],bel[50010];
int a[50010],b[50010];
int tr[50010];
long long ans[230][230];
int les[230][50010],mor[230][50010];
map&lt;int,int&gt;h;

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline int lowbit(int x)
{
    return x&amp;-x;
}
inline void modify(int x,int val)
{
    for(;x&lt;=N;x+=lowbit(x))
        tr[x]+=val;
}
inline int query(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp+=tr[x];
    return temp;
}

inline void make_block()
{
    int temp=0;
    while(num*num&lt;n)num++;
    S[1]=1;
    bel[1]=1;
    for(int i=1;i&lt;=n;i++)
    {
        temp++;
        if(temp==num+1)
        {
            temp=1;
            bel[i]=1;
            T[bel[i-1]]=i-1;
            S[bel[i-1]+1]=i;
        }
        bel[i]+=bel[i-1];
    }
    T[bel[n]]=n;
}
inline void init()
{
    n=read();
    make_block();
    for(int i=1;i&lt;=n;i++)
    {
        a[i]=read();
        b[i]=a[i];
    }
    sort(b+1,b+n+1);
    int temp=0;
    for(int i=1;i&lt;=n;i++)
        if(b[i]!=b[i-1])
            h[b[i]]=++temp;
    for(int i=1;i&lt;=n;i++)
        a[i]=h[a[i]];
    N=temp;


    long long sum=0;
    for(int i=1;i&lt;=n;i++)
    {
        sum+=i-1-query(a[i]);
        modify(a[i],1);
        if(i==T[bel[i]])
        {
            ans[1][bel[i]]=sum;
            for(int j=1;j&lt;=N;j++)
            {
                les[bel[i]][j]=query(j-1);
                mor[bel[i]][j]=i-query(j);
            }
        }
    }

    for(int i=2;i&lt;=bel[n];i++)
    {
        sum=0;
        memset(tr,0,sizeof(tr));
        for(int j=S[i];j&lt;=n;j++)
        {
            sum+=j-S[i]-query(a[j]);
            modify(a[j],1);
            if(j==T[bel[j]])ans[i][bel[j]]=sum;
        }
    }
    memset(tr,0,sizeof(tr));
}

inline int calc(int l,int r)
{
    int temp=0;
    for(int i=l;i&lt;=r;i++)
    {
        temp+=i-l-query(a[i]);
        modify(a[i],1);
    }
    for(int i=l;i&lt;=r;i++)
        modify(a[i],-1);
    return temp;
}
inline int calc1(int M)
{
    int temp=0;
    for(int i=1;i&lt;=M;i++)
    {
        temp+=i-1-query(b[i]);
        modify(b[i],1);
    }
    for(int i=1;i&lt;=M;i++)
        modify(b[i],-1);
    return temp;
}

int main()
{
    init();

    long long lastans=0;
    for(int m=read();m;m--)
    {
        long long l,r;
        l=read();r=read();
        //l^=lastans;r^=lastans;
        lastans=0;
        if(bel[l]+1&gt;=bel[r])
        {
            if(l==S[bel[l]]&amp;&amp;r==T[bel[r]])
                lastans=ans[bel[l]][bel[r]];
            else
                lastans=calc(l,r);
        }
        else
        {
            int A=bel[l],B=bel[l]+1,C=bel[r]-1,D=bel[r];
            int temp=0;
            if(l==S[A]&amp;&amp;r==T[D])
                lastans=ans[A][D];
            else
                if(l==S[A])
                {
                    lastans=ans[A][C];
                    for(int i=S[D];i&lt;=r;i++)
                    {
                        lastans+=mor[C][a[i]]-mor[A-1][a[i]];
                        b[++temp]=a[i];
                    }
                    lastans+=calc1(temp);
                }
                else
                    if(r==T[D])
                    {
                        lastans=ans[B][D];
                        for(int i=l;i&lt;=T[A];i++)
                        {
                            lastans+=les[D][a[i]]-les[A][a[i]];
                            b[++temp]=a[i];
                        }
                        lastans+=calc1(temp);
                    }
                    else
                    {
                        lastans=ans[B][C];
                        for(int i=l;i&lt;=T[A];i++)
                        {
                            lastans+=les[C][a[i]]-les[A][a[i]];
                            b[++temp]=a[i];
                        }
                        for(int i=S[D];i&lt;=r;i++)
                        {
                            lastans+=mor[C][a[i]]-mor[A][a[i]];
                            b[++temp]=a[i];
                        }
                        lastans+=calc1(temp);
                    }
        }
        printf("%lld\n",lastans);
    }

    return 0;
}
</pre><pre></pre><h2>Problem3299</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,m,cnt,S,T;
int g[1000010],dist[1000010],q[1000010],ma[1000010];
int w[30][5];
bitset&lt;1000010&gt;v;
char str[1010][1010];
struct edge
{
    int t,next;
}e[5000010];

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int calc(int x,int y)
{
    return (x-1)*m+y;
}

inline void bfs(int x)
{
    dist[x]=0;
    int h=1,t=1;
    q[1]=x;
    v.set(x);

    while(h&lt;=t)
    {
        int x=q[h++];
        for(int i=g[x];i;i=e[i].next)
            if(!v.test(e[i].t))
            {
                int temp=e[i].t;
                v.set(temp);
                if(ma[temp])
                {
                    int c=ma[temp];
                    if(temp==w[c][1])temp=w[c][2];else temp=w[c][1];
                }
                dist[temp]=dist[x]+1;
                q[++t]=temp;
                if(e[i].t==T)return;
            }
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%s",str[i]);
        for(int j=1;j&lt;=m;j++)
        {
            char c=str[i][j-1];
            if(c=='@')
                S=calc(i,j);
            else
                if(c=='=')
                    T=calc(i,j);
                else
                    if(c&gt;='A'&amp;&amp;c&lt;='Z')
                    {
                        int temp=c-'A'+1;
                        w[temp][++w[temp][0]]=calc(i,j);
                        ma[calc(i,j)]=temp;
                    }
            if(c!='#'&amp;&amp;i&gt;1&amp;&amp;str[i-1][j-1]!='#')
            {
                int x=calc(i,j),y=calc(i-1,j);
                add_edge(x,y);
                add_edge(y,x);
            }
            if(c!='#'&amp;&amp;j&gt;1&amp;&amp;str[i][j-2]!='#')
            {
                int x=calc(i,j),y=calc(i,j-1);
                add_edge(x,y);
                add_edge(y,x);
            }
        }
    }

    bfs(S);
    printf("%d\n",dist[T]);

    return 0;
}</pre><pre></pre><h2>Problem3306</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,q,cnt,idx;
int g[100010],dfn[100010],v[100010];
int dep[100010],l[100010],r[100010];
int pos[100010];
int fa[100010][18];

struct seg
{
    int l,r,v;
}seg[400010];
struct edge
{
    int t,next;
}e[100010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void dfs(int x)
{
    dep[x]=dep[fa[x][0]]+1;
    l[x]=++idx;dfn[idx]=x;
    for(int i=1;i&lt;18;i++)
        fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int i=g[x];i!=0;i=e[i].next)
        dfs(e[i].t);
    r[x]=idx;
}

inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r)
    {
        pos[l]=p;
        seg[p].v=v[dfn[l]];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
    seg[p].v=Min(seg[p&lt;&lt;1].v,seg[p&lt;&lt;1|1].v);
}
inline void modify(int p,int val)
{
    seg[p].v=val;
    p&gt;&gt;=1;
    while(p)
    {
        seg[p].v=Min(seg[p&lt;&lt;1].v,seg[p&lt;&lt;1|1].v);
        p&gt;&gt;=1;
    }
    return;
}
inline int query(int p,int l,int r)
{
    if(r&lt;l)return inf;
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p].v;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        return query(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            return query(p&lt;&lt;1|1,l,r);
        else
            return Min(query(p&lt;&lt;1,l,mid),query(p&lt;&lt;1|1,mid+1,r));
}

inline int swim(int x,int h)
{
    for(int i=0;h;i++)
    {
        if(h&amp;1)x=fa[x][i];
        h&gt;&gt;=1;
    }
    return x;
}

int main()
{
    n=read();q=read();
    for(int i=1;i&lt;=n;i++)
    {
        fa[i][0]=read();
        if(fa[i][0]!=0)
            add_edge(fa[i][0],i);
        v[i]=read();
    }

    int root=1;
    fa[1][0]=1;
    dfs(1);
    build(1,1,n);

    for(;q;q--)
    {
        char ch[5];
        scanf("%s",ch);
        if(ch[0]=='V')
        {
            int x,y;
            x=read();y=read();
            modify(pos[l[x]],y);
        }
        else
            if(ch[0]=='E')
                root=read();
            else
            {
                int x=read();
                if(x==root)printf("%d\n",seg[1].v);
                else
                    if(l[x]&lt;=l[root]&amp;&amp;r[root]&lt;=r[x])
                    {
                        int y=swim(root,dep[root]-dep[x]-1);
                        printf("%d\n",Min(query(1,1,l[y]-1),query(1,r[y]+1,n)));
                    }
                    else
                        printf("%d\n",query(1,l[x],r[x]));
            }
    }
    return 0;
}
</pre><pre></pre><h2>Problem3310</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,t,x,y,a,b,k,temp,temp1;
int c[5000010],fa[5000010];

int main()
{
	scanf("%d%d",&amp;n,&amp;t);
	
	for(int i=0;i&lt;n-1;i++)
		fa[i]=i+1,c[i]=0;
	
	fa[n-1]=0,c[n-1]=0;
	
	for(;t;t--)
	{
		scanf("%d%d%d%d",&amp;x,&amp;y,&amp;a,&amp;b);
		a%=n;
		b%=n;
		
		for(;x;x--)
			for(int j=1;j&lt;=y;j++)
			{
				k=temp=(j*a%n+b)%n;
				while(c[k])k=fa[k];
				c[k]=1;
				k=fa[k];
				while(temp!=k)
					temp1=fa[temp],fa[temp]=k,temp=temp1;
			}
	}
	
	for(t=0;t&lt;n;t++)if(!c[t])break;
	
	printf("%d\n",t);
	
	return 0;
}</pre><pre></pre><h2>Problem3310</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,t,x,y,a,b,temp;
int c[3000010],fa[3000010];

int find(int x)
{
	if(!c[x])
	{
		c[x]=1;
		return fa[x];
	}
	return fa[x]=find(fa[x]);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;t);
	
	for(int i=0;i&lt;n-1;i++)
		fa[i]=i+1,c[i]=0;
	
	fa[n-1]=0,c[n-1]=0;
	
	for(;t;t--)
	{
		scanf("%d%d%d%d",&amp;x,&amp;y,&amp;a,&amp;b);
		a%=n;
		b%=n;
		
		for(;x;x--)
			for(int j=1;j&lt;=y;j++)
				temp=find((j*a%n+b)%n);
	}
	
	for(t=0;t&lt;n;t++)if(!c[t])break;
	
	printf("%d\n",t);
	
	return 0;
}</pre><pre></pre><h2>Problem3339</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;

using namespace std;

int n,m;
int a[200010],b[200010],nxt[200010];
int ans[200010];
bool num[200010];
map&lt;int,int&gt;h;
struct qry
{
    int l,r,id;
    inline friend bool operator&lt;(const qry&amp;a,const qry&amp;b)
    {
        return a.l&lt;b.l;
    }
}q[200010];
struct seg_tree
{
    int l,r,v;
}seg[800010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r)
    {
        seg[p].v=b[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
    seg[p].v=Max(seg[p&lt;&lt;1].v,seg[p&lt;&lt;1|1].v);
}
inline void push_down(int p)
{
    seg[p&lt;&lt;1].v=Min(seg[p&lt;&lt;1].v,seg[p].v);
    seg[p&lt;&lt;1|1].v=Min(seg[p&lt;&lt;1|1].v,seg[p].v);
}
inline void modify(int p,int l,int r,int val)
{
    if(seg[p].v&lt;=val)return;
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)
    {
        seg[p].v=val;
        return;
    }
    push_down(p);
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        modify(p&lt;&lt;1,l,r,val);
    else
        if(l&gt;mid)
            modify(p&lt;&lt;1|1,l,r,val);
        else
        {
            modify(p&lt;&lt;1,l,mid,val);
            modify(p&lt;&lt;1|1,mid+1,r,val);
        }
    seg[p].v=Max(seg[p&lt;&lt;1].v,seg[p&lt;&lt;1|1].v);
}
inline int query(int p,int pos)
{
    int l=1,r=n;
    while(l!=r)
    {
        push_down(p);
        int mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)
        {
            r=mid;p&lt;&lt;=1;
        }
        else
        {
            l=mid+1;p=p&lt;&lt;1|1;
        }
    }
    return seg[p].v;
}

int main()
{
    n=read();m=read();
    int temp=0;
    for(int i=1;i&lt;=n;i++)
	{
		a[i]=read();
		h[a[i]]=n+1;
		if(a[i]&lt;n)
		{
			num[a[i]]=true;
			while(num[temp])temp++;
		}
		b[i]=temp;
	}
	for(int i=n;i;i--)
    {
        nxt[i]=h[a[i]]-1;
        h[a[i]]=i;
    }

    for(int i=1;i&lt;=m;i++)
    {
        q[i].l=read();
        q[i].r=read();
        q[i].id=i;
    }
    sort(q+1,q+m+1);

    build(1,1,n);
    temp=1;
    for(int i=1;i&lt;=m;i++)
    {
        while(temp&lt;q[i].l)
        {
            modify(1,temp,nxt[temp],a[temp]);
            temp++;
        }
        ans[q[i].id]=query(1,q[i].r);
    }

    for(int i=1;i&lt;=m;i++)
        printf("%d\n",ans[i]);

    return 0;
}
</pre><pre></pre><h2>Problem3357</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int P=1000003;

int n,ans=1;
int a[2010];
int d[2010][2010],f[2010][2010];
struct Hash
{
	int num,pos;
	Hash *next;
}*h[1000010];
inline int find(int x)
{
	x=x%P;
	for(Hash *p=h[x];p;p=p-&gt;next)
		if(p-&gt;num==x)
			return p-&gt;pos;
}
inline void insert(int x,int pos)
{
	x=x%P;
	for(Hash *p=h[x];p;p=p-&gt;next)
		if(p-&gt;num==x)
		{
			p-&gt;pos=pos;
			return;
		}
	Hash *p=new Hash;
	p-&gt;num=x;p-&gt;pos=pos;
	p-&gt;next=h[x];h[x]=p;
}
struct Hash1
{
	int num,pos;
	Hash1 *next;
}*h1[1000010];
inline int find1(int x)
{
	x=x%P;
	for(Hash1 *p=h1[x];p;p=p-&gt;next)
		if(p-&gt;num==x)
			return p-&gt;pos;
	return 0;
}
inline void insert1(int x,int pos)
{
	x=x%P;
	Hash1 *p=new Hash1;
	p-&gt;num=x;p-&gt;pos=pos;
	p-&gt;next=h1[x];h1[x]=p;
}

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;=48&amp;&amp;c&lt;=57)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}
inline int Max(const int &amp;a,const int&amp;b)
{
	return a&gt;b?a:b;
}

inline int find2(int x,int num)
{
	int temp=find1(num);
	if(temp==0||temp&gt;=x)return 0;
	return d[x][temp];
}

int main()
{
	n=read();
	for(int i=1;i&lt;=n;i++)
	{
		f[i][0]=1;
		a[i]=read();
		for(int j=1;j&lt;i;j++)
		{
			ans=Max(ans,f[i][j]=Max(f[i][j],f[j][find2(j,(a[j]&lt;&lt;1)-a[i])]+1));
			d[i][j]=find(a[j]);
		}
		insert(a[i],i);
		if(!find1(a[i]))insert1(a[i],i);
	}
	
	printf("%d\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem3357</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int P=1000003;

int n,ans=1;
int a[2010];
int d[2010][2010],f[2010][2010];

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int &amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}

struct Hash
{
    int num,be,en;
    Hash *next;
}*h[1000010];
inline int find1(int x)
{
    x=x%P;if(x&lt;0)x+=P;
    for(Hash *p=h[x];p;p=p-&gt;next)
        if(p-&gt;num==x)
            return p-&gt;be;
    return 0;
}
inline int find2(int x)
{
    x=x%P;if(x&lt;0)x+=P;
    for(Hash *p=h[x];p;p=p-&gt;next)
        if(p-&gt;num==x)
            return p-&gt;en;
}
inline void insert(int x,int pos)
{
    x=x%P;if(x&lt;0)x+=P;
    for(Hash *p=h[x];p;p=p-&gt;next)
        if(p-&gt;num==x)
        {
            p-&gt;en=pos;
            return;
        }
    Hash *p=new Hash;
    p-&gt;num=x;p-&gt;be=pos;p-&gt;en=pos;
    p-&gt;next=h[x];h[x]=p;
}
inline int find(int x,int num)
{
    int temp=find1(num);
    if(temp==0||temp&gt;=x)return 0;
    return d[x][temp];
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
    {
        f[i][0]=1;
        a[i]=read();
        for(int j=1;j&lt;i;j++)
        {
            ans=Max(ans,f[i][j]=Max(f[i][j],f[j][find(j,(a[j]&lt;&lt;1)-a[i])]+1));
            d[i][j]=find2(a[j]);
        }
        insert(a[i],i);
    }

    printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3357</h2><pre>#include&lt;cstdio&gt;
 
using namespace std;
 
const int P=8000003;
 
int n,ans=1;
int a[2010];
int d[2010][2010],f[2010][2010];
 
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int &amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}
 
struct Hash
{
    int num,be,en;
    Hash *next;
}*h[8000010];
inline int find1(int x)
{
    x=x%P;if(x&lt;0)x+=P;
    for(Hash *p=h[x];p;p=p-&gt;next)
        if(p-&gt;num==x)
            return p-&gt;be;
    return 0;
}
inline int find2(int x)
{
    x=x%P;if(x&lt;0)x+=P;
    for(Hash *p=h[x];p;p=p-&gt;next)
        if(p-&gt;num==x)
            return p-&gt;en;
}
inline void insert(int x,int pos)
{
    x=x%P;if(x&lt;0)x+=P;
    for(Hash *p=h[x];p;p=p-&gt;next)
        if(p-&gt;num==x)
        {
            p-&gt;en=pos;
            return;
        }
    Hash *p=new Hash;
    p-&gt;num=x;p-&gt;be=pos;p-&gt;en=pos;
    p-&gt;next=h[x];h[x]=p;
}
inline int find(int x,int num)
{
    int temp=find1(num);
    if(temp==0||temp&gt;=x)return 0;
    return d[x][temp];
}
 
int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
    {
        f[i][0]=1;
        a[i]=read();
        for(int j=1;j&lt;i;j++)
        {
            ans=Max(ans,f[i][j]=Max(f[i][j],f[j][find(j,(a[j]&lt;&lt;1)-a[i])]+1));
            d[i][j]=find2(a[j]);
        }
        insert(a[i],i);
    }
 
    printf("%d\n",ans);
 
    return 0;
}</pre><pre></pre><h2>Problem3384</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,w,x,ans;
int f[35][3];

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;w);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;x);
		
		for(int j=w;j&gt;=1;j--)
		{
			f[j][x]=max(f[j][x],f[j-1][3-x])+1;
			f[j][3-x]=f[j][3-x];
		}
		f[0][x]=f[0][x]+1;
		f[0][3-x]=f[0][3-x];
	}
	
	for(int i=0;i&lt;=w;i++)
		ans=max(ans,max(f[i][1],f[i][2]));
	
	printf("%d\n",ans);
	
	return 0;
}</pre><pre></pre><h2>Problem3385</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,ans;
char str[110];
int dx[10],dy[10];
int v[110][110];

inline bool check(int x,int y)
{
	return x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=m;
}

inline void dfs(int x,int y)
{
	v[x][y]=0;
	for(int i=1;i&lt;=8;i++)
		if(check(x+dx[i],y+dy[i])&amp;&amp;v[x+dx[i]][y+dy[i]])
			dfs(x+dx[i],y+dy[i]);
}

int main()
{
	dx[1]=1;dx[2]=1;dx[3]=0;dx[4]=-1;dx[5]=-1;dx[6]=-1;dx[7]=0;dx[8]=1;
	dy[1]=0;dy[2]=-1;dy[3]=-1;dy[4]=-1;dy[5]=0;dy[6]=1;dy[7]=1;dy[8]=1;
	
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%s",str);
		for(int j=0;j&lt;m;j++)
			if(str[j]=='W')
				v[i][j+1]=1;
	}
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			if(v[i][j])
			{
				dfs(i,j);
				ans++;
			}
	printf("%d\n",ans);
	
	return 0;
}
</pre><pre></pre><h2>Problem3390</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,num,ans;
int fa[1010],rank[1010];
struct edge
{
  int x,y,c;
  inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
  {
    return a.c&gt;b.c;
  }
}e[20010];

inline int read()
{
  int c=getchar(),temp=0;
  while(c&lt;48||c&gt;57)c=getchar();
  while(c&gt;=48&amp;&amp;c&lt;=57)
    {
      temp=temp*10+c-48;
      c=getchar();
    }
  return temp;
}

inline int find(int x)
{
  return fa[x]=x==fa[x]?x:find(fa[x]);
}
inline void unio(int x,int y)
{
  int f1=find(x),f2=find(y);
  if(rank[f1]&lt;rank[f2])
    fa[f1]=f2;
  else
    {
      fa[f2]=f1;
      if(rank[f1]==rank[f2])rank[f1]++;
    }
}

int main()
{
  n=read();m=read();
  for(int i=1;i&lt;=n;i++)
    fa[i]=i;
  for(int i=1;i&lt;=m;i++)
    {
      e[i].x=read();e[i].y=read();e[i].c=read();
    }
  sort(e+1,e+m+1);

  for(int i=1;i&lt;=m;i++)
    {
      if(find(e[i].x)!=find(e[i].y))
	{
	  unio(e[i].x,e[i].y);
	  num++;
	  ans+=e[i].c;
	  if(num==n-1)break;
	}
    }
  if(num==n-1)
    printf("%d\n",ans);
  else
    printf("-1\n");
  return 0;
}
</pre><pre></pre><h2>Problem3396</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;

using namespace std;

const int INF=1000000000;

int n,N,cnt=1,S,T;
int g[710];
int vh[710],dis[710],di[710],his[710],pre[710];
map&lt;char,int&gt;h;
struct edge
{
    int t,c,next;
}e[10010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=z;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int isap()
{
    vh[0]=N;
    for(int i=1;i&lt;=N;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;

    while(dis[S]&lt;N)
    {
        bool flag=false;
        his[x]=aug;

        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                di[x]=i;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;

        int mi=N,mii=0;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }

        di[x]=mii;
        dis[x]=mi+1;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
    {
        char ch1[5],ch2[5];
        scanf("%s",ch1);
        scanf("%s",ch2);
        int x=read();
        if(!h[ch1[0]])h[ch1[0]]=++N;
        if(!h[ch2[0]])h[ch2[0]]=++N;
        add_edge(h[ch1[0]],h[ch2[0]],x);
    }
    S=h['A'];T=h['Z'];
    printf("%d\n",isap());

    return 0;
}
</pre><pre></pre><h2>Problem3400</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int P=100000000;

int n,F;
int a[2010],f[2010][1010];

inline int calc(int x)
{
    if(x&gt;=F)x-=F;
    return x;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;F);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",a+i);
        a[i]%=F;
    }

    f[0][0]=1;
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;F;j++)
        {
            int temp=(j+a[i])%F;
            f[i][j]=(f[i][j]+f[i-1][j])%P;
            f[i][temp]=(f[i][temp]+f[i-1][j])%P;
        }

    printf("%d\n",f[n][0]-1);

    return 0;
}
</pre><pre></pre><h2>Problem3401</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,top;
int a[100010],stack[100010],ans[100005];

int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
        scanf("%d",a+i);

    for(int i=n;i;i--)
    {
        while(top&amp;&amp;a[stack[top]]&lt;=a[i])top--;
        ans[i]=stack[top];
        stack[++top]=i;
    }

    for(int i=1;i&lt;=n;i++)
        printf("%d\n",ans[i]);

    return 0;
}</pre><pre></pre><h2>Problem3402</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,cnt;
int g[20010],q[20010],dist[20010];

struct edge
{
    int t,next;
}e[100010];

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void bfs(int x)
{
    q[1]=1;
    int h=0,t=1;

    while(h!=t)
    {
        h++;
        for(int i=g[q[h]];i;i=e[i].next)
            if(!dist[e[i].t])
            {
                dist[e[i].t]=dist[q[h]]+1;
                q[++t]=e[i].t;
            }
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(x,y);
        add_edge(y,x);
    }

    dist[1]=1;
    bfs(1);

    int ma=0,mai;

    for(int i=1;i&lt;=n;i++)
        if(dist[i]&gt;ma)
        {
            ma=dist[i];
            mai=i;
            cnt=1;
        }
        else
            if(dist[i]==ma)
                cnt++;

    printf("%d %d %d\n",mai,ma-1,cnt);

    return 0;
}
</pre><pre></pre><h2>Problem3403</h2><pre>#include&lt;cstdio&gt;
#include&lt;deque&gt;

using namespace std;

int n,cnt,x;
deque&lt;int&gt; q;
char str1[5],str2[5];

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%s%s",str1,str2);

        if(str1[0]=='A')
        {
            ++cnt;
            if(str2[0]=='L')
                q.push_front(cnt);
            else
                q.push_back(cnt);
        }
        else
        {
            scanf("%d",&amp;x);
            if(str2[0]=='L')
                for(;x;x--)q.pop_front();
            else
                for(;x;x--)q.pop_back();
        }
    }

    while(!q.empty())
    {
        printf("%d\n",q.front());
        q.pop_front();
    }

    return 0;
}
</pre><pre></pre><h2>Problem3404</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n;
int f[1000010];

int main()
{
    for(int i=1;i&lt;=1000000;i++)
    {
        int temp=i,ma=0,mi=10;
        while(temp)
        {
            int x=temp%10;
            if(x&gt;ma)ma=x;
            if(x&amp;&amp;x&lt;mi)mi=x;
            temp/=10;
        }
        if(!f[i-ma]||!f[i-mi])f[i]=1;
    }

    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        if(f[x])
            printf("YES\n");
        else
            printf("NO\n");
    }

    return 0;
}
</pre><pre></pre><h2>Problem3406</h2><pre>#include&lt;cstdio&gt;

using namespace std;

struct que
{
	int x,y;
}q[10010],q1[10010],ch[10];

int size=1,size1,n,m,x,y,ma[110][110],t,num;
char c;

inline bool check1(int x,int y)
{
	return (x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m&amp;&amp;ma[x][y]==0);
}

inline void put(int x,int y)
{
	for(int i=1;i&lt;=8;i++)
		if(check1(x+ch[i].x,y+ch[i].y))
	  	{
			q1[++size1].x=x+ch[i].x;
			q1[size1].y=y+ch[i].y;
			ma[x+ch[i].x][y+ch[i].y]=t+1;
			num--;
		}
}

int main()
{
	scanf("%d%d%d%d",&amp;m,&amp;n,&amp;y,&amp;x);
	ch[1].x=-1,ch[1].y=-1;
	ch[2].x=-1,ch[2].y=0;
	ch[3].x=-1,ch[3].y=1;
	ch[4].x=0,ch[4].y=-1;
	ch[5].x=0,ch[5].y=1;
	ch[6].x=1,ch[6].y=-1;
	ch[7].x=1,ch[7].y=0;
	ch[8].x=1,ch[8].y=1;
	
	for(int i=1;i&lt;=n;i++)
	{
	  c=getchar();
	  for(int j=1;j&lt;=m;j++)
	  {
	  	 c=getchar();
	  	 if(c=='*')
	  	   ma[i][j]=32767;
	  	 else
	  	   ma[i][j]=0,num++;
	  } 
	}
	
	ma[n-x+1][y]=1;
	q[1].x=n-x+1,q[1].y=y;
	num--;
	
	while(num)
	{
		t++;
		size1=0;
		for(int i=1;i&lt;=size;i++)
		  put(q[i].x,q[i].y);
		size=size1;
		for(int i=1;i&lt;=size;i++)
		  q[i].x=q1[i].x,q[i].y=q1[i].y;
	}
	
	printf("%d\n",t);
	
	return 0;
}</pre><pre></pre><h2>Problem3408</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const long long maxint=(long long)1000000000*(long long)1000000000;

int que2[1000010],pl[1000010];
long long que1[1000010],dist[1000010];
int size,n,e,s,t,temp,ltemp,x,y,z;
char c;

struct edge
{
	int ch,len;
	edge *next;
}*tr[1000010],*p;

inline int read()
{
	c=getchar();
	temp=0;
	
	while(c!=' '&amp;&amp;c!='\n')
	{
		temp=temp*10+(c-'0');
		c=getchar();
	}
	return temp;
}

inline void add_edge(int x,int y,int z)
{
	p=new edge;
	p-&gt;ch=y;
	p-&gt;len=z;
	p-&gt;next=tr[x];
	tr[x]=p;
}

inline void swap(int x,int y)
{
	temp=que1[x];
	que1[x]=que1[y];
	que1[y]=temp;
	
	temp=que2[x];
	que2[x]=que2[y];
	que2[y]=temp;
	
	pl[que2[x]]=x;
	pl[que2[y]]=y;
}

void heapfy(int x)
{
	int xx=x,minn=que1[x];
	
	if((x&lt;&lt;1)&lt;=size&amp;&amp;que1[x&lt;&lt;1]&lt;minn)
		xx=x&lt;&lt;1,minn=que1[xx];
	
	if((x&lt;&lt;1|1)&lt;=size&amp;&amp;que1[x&lt;&lt;1|1]&lt;minn)
		xx=x&lt;&lt;1|1,minn=que1[xx];
	
	if(x!=xx)
	{
		swap(x,xx);
		heapfy(xx);
	}
}

void up(int x)
{
	if(x&gt;1)
		if(que1[x]&lt;que1[x&gt;&gt;1])
		{
			swap(x,x&gt;&gt;1);
			up(x&gt;&gt;1);
		}
}

inline void insert(long long x,int y)
{
	que1[++size]=x;
	que2[size]=y;
	pl[y]=size; 
	
	up(size);
}

inline void dij()
{
	for(int i=1;i&lt;=n;i++)dist[i]=maxint;
	pl[s]=1;
	que1[1]=0;
	que2[1]=s;
	size=1;
	
	while(size)
	{
		x=que2[1];
		dist[x]=que1[1];
		if(x==t)return;
		
		swap(1,size--);
		heapfy(1);
		p=tr[x];
		
		while(p!=NULL)
		{
			if(dist[p-&gt;ch]==maxint)
			{
				ltemp=dist[x]+p-&gt;len;
				if(pl[p-&gt;ch])
				{
					if(ltemp&lt;que1[pl[p-&gt;ch]])
					{
						que1[pl[p-&gt;ch]]=ltemp;
						up(pl[p-&gt;ch]);
					}
				}
				else
				  insert(ltemp,p-&gt;ch);
			}
			p=p-&gt;next;
		}
	}
}

int main()
{
	n=read();
	e=read();
	s=read();
	t=read();
	
	for(int i=0;i&lt;e;i++)
	{
		x=read();
		y=read();
		z=read();
		add_edge(x,y,z);
		add_edge(y,x,z);
	}
	
	dij();

	printf("%lld\n",dist[t]);
	
	return 0;
}</pre><pre></pre><h2>Problem3420</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;


#define N 300010

int n,ans,m;
int fa[N],num[N],f[N];
int s[N];

bitset&lt;N&gt; v;

struct size
{
	int ch;
	size *next;
}*g[N];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int read()
{
    char c=getchar();
    int temp=0;

    while(c&lt;'0'||c&gt;'9')
        c=getchar();

    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }

    return temp;
}

inline void add_edge(int x,int y)
{
    size *p=new size;
    p-&gt;ch=y;
    p-&gt;next=g[x];
    g[x]=p;

    p=new size;
    p-&gt;ch=x;
    p-&gt;next=g[y];
    g[y]=p;
}

void dfs()
{
    v.reset();

    int top;

    s[top=1]=1;

    while(top)
    {
        int x=s[top--];

        v.set(x);

        for(size*p=g[x];p;p=p-&gt;next)
            if(!v.test(p-&gt;ch))
            {
                fa[p-&gt;ch]=x;
                num[x]++;
                s[++top]=p-&gt;ch;
            }
    }
}

int dfs1()
{
    v.reset();

    int top;
    s[top=1]=1;

    while(top)
    {
        int x=s[top];

        if(v.test(x))
        {
            f[x]=num[x]-m;
            for(size*p=g[x];p;p=p-&gt;next)
                if(p-&gt;ch!=fa[x])
                    f[x]+=f[p-&gt;ch];
            f[x]=max(0,f[x]);

            top--;
        }

        v.set(x);

        for(size*p=g[x];p;p=p-&gt;next)
            if(!v.test(p-&gt;ch))
                s[++top]=p-&gt;ch;
    }

    return f[1];
}

int main()
{
    n=read();

	for(int i=1,x,y;i&lt;n;i++)
		x=read(),y=read(),add_edge(x,y);

	if(n==1)
	{
	    printf("0\n");
	    return 0;
	}

	int l=1,r=ans=n-1;

	dfs();

	while(l&lt;=r)
    {
		m=(l+r)/2;
		if(dfs1())
            l=m+1;
		else
            ans=min(ans,m),r=m-1;
	}

	printf("%d\n",ans);

	return 0;
}
</pre><pre></pre><h2>Problem3437</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n;
int a[1000010],b[1000010],q[1000010];
long long f[1000010],sum[1000010],sum1[1000010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline long long calc1(int x,int y)
{
    return sum1[x]-sum1[y]-(long long)(sum[x]-sum[y])*(n-y);
}
inline long long calc2(int x)
{
    return f[x]-sum1[x]+(long long)sum[x]*n-(long long)sum[x]*x;
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read();
    for(int i=1;i&lt;=n;i++)
        b[i]=read();
    for(int i=n;i&gt;=0;i--)
    {
        sum1[i]=sum1[i+1]+(long long)b[i]*(n-i);
        sum[i]=sum[i+1]+b[i];
    }

    int h=1,t=1;
    f[n]=a[n];
    q[1]=n;
    for(int i=n-1;i&gt;=0;i--)
    {
        while(h&lt;t&amp;&amp;calc2(q[h+1])-calc2(q[h])&lt;(long long)sum[i+1]*(q[h]-q[h+1]))h++;
        f[i]=f[q[h]]+calc1(i+1,q[h])+a[i];
        while(h&lt;t&amp;&amp;(calc2(q[t])-calc2(q[t-1]))*(q[t-1]-i)&gt;=(calc2(i)-calc2(q[t-1]))*(q[t-1]-q[t]))t--;
        q[++t]=i;
    }
    printf("%lld\n",f[0]);
    return 0;
}</pre><pre></pre><h2>Problem3467</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

using namespace std;

const int base=13331;

struct Operation
{
	int t,v;
	char c;
}op[100000];

int s1[100010],s2[100010],sa[100010],rank[100010],up[100010];
int depth1[100010],depth2[100010],pre[100010][20];
long long hash[100010],pow[20];

pair&lt;int,int&gt; range[100010];

bool cmp(int a,int b)
{
	int lg=0;
	while(1&lt;&lt;lg&lt;=depth2[a]&amp;&amp;1&lt;&lt;lg&lt;=depth2[b])lg++;
	for(int i=lg-1;i&gt;=0;i--)
    {
		long long t1=hash[a]-hash[pre[a][i]]*pow[i];
		long long t2=hash[b]-hash[pre[b][i]]*pow[i];
		if(t1==t2)
		{
			a=pre[a][i];
			b=pre[b][i];
		}
	}
	return up[a]&lt;up[b];
}

int goUp(int x,int step)
{
	for(int i=0;1&lt;&lt;i&lt;=step;i++)
		if(step&amp;1&lt;&lt;i)
            x=pre[x][i];
	return x;
}

int main()
{
	int n;
	scanf("%d",&amp;n);
	for(int i=0;i&lt;n;i++)
    {
		int x,y;
		char tmp[11];
		scanf("%d%d%s",&amp;x,&amp;y,tmp);
		op[i].t=x;
		op[i].v=y-1;
		op[i].c=tmp[0];
	}

	hash[0]=0;
	up[0]=0;
	depth1[0]=0;
	memset(pre,-1,sizeof(pre));
	int tot=1;
	for(int i=0;i&lt;n;i++)
		if(op[i].t==2)
        {
			depth2[tot]=depth2[op[i].v]+1;
			hash[tot]=hash[op[i].v]*base+op[i].c;
			up[tot]=op[i].c;
			pre[tot][0]=op[i].v;
			for(int j=1;1&lt;&lt;j&lt;=depth2[tot];j++)
				pre[tot][j]=pre[pre[tot][j-1]][j-1];
			tot++;
		}

	pow[0]=base;
	for(int i=1;1&lt;&lt;i&lt;=tot;i++)
        pow[i]=pow[i-1]*pow[i-1];
	for(int i=0;i&lt;tot;i++)
        sa[i]=i;

	sort(sa,sa+tot,cmp);

	for(int i=0;i&lt;tot;i++)
        rank[sa[i]]=i;

	memset(s1,0,sizeof(s1));
	memset(s2,0,sizeof(s2));

	long long ans=0;
	int cur1=1,cur2=1;
	range[0]=make_pair(0,tot);
	depth1[0]=0;
	for(int i=0;i&lt;n;i++)
    {
		if(op[i].t==1)
		{
			depth1[cur1]=depth1[op[i].v]+1;
			if(range[op[i].v].first!=-1)
            {
				int head,tail;
				head=range[op[i].v].first;
				tail=range[op[i].v].second-1;
				while(head&lt;=tail)
				{
					int mid=(head+tail)&gt;&gt;1;
					if(up[goUp(sa[mid],depth1[op[i].v])]&lt;op[i].c)
                        head=mid+1;
					else
						tail=mid-1;
				}
				int l=head;
				head=range[op[i].v].first;
				tail=range[op[i].v].second-1;
				while(head&lt;=tail)
				{
					int mid=(head+tail)&gt;&gt;1;
					if(up[goUp(sa[mid],depth1[op[i].v])]&gt;op[i].c)
						tail=mid-1;
					else
						head=mid+1;
				}
				int r=tail+1;
				if(l&gt;=r)
					range[cur1]=make_pair(-1,-1);
				else
				{
				    range[cur1]=make_pair(l,r);
					for(int j=r;j&gt;0;j-=j&amp;-j)ans+=s1[j];
					for(int j=l;j&gt;0;j-=j&amp;-j)ans-=s1[j];
					for(int j=l+1;j&lt;=tot;j+=j&amp;-j)s2[j]++;
					if(r&lt;tot)
						for(int j=r+1;j&lt;=tot;j+=j&amp;-j)
                            s2[j]--;
				}
			}
			else
				range[cur1]=make_pair(-1,-1);
			cur1++;
		}
		else
        {
			int t=rank[cur2];
			for(int j=t+1;j&lt;=tot;j+=j&amp;-j)s1[j]++;
			for(int j=t+1;j&gt;0;j-=j&amp;-j)ans+=s2[j];
			cur2++;
		}
		printf("%lld\n",ans+cur2);
	}

	return 0;
}
</pre><pre></pre><h2>Problem3468</h2><pre>#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;

using namespace std;

const int modulo=12345;
const int u[4][2]={{0, 1},{0, -1},{1, 0},{-1, 0}};

int h[300][300],stack[90000],f[90000][201],ind[90000],stirling2[201][201],sum[201];

int main()
{
	int n, m, k;
	scanf("%d%d%d", &amp;n, &amp;m, &amp;k);
	for (int i = 0; i &lt; n; i ++)
		for (int j = 0; j &lt; m; j ++)
			scanf("%d", &amp;h[i][j]);

	memset(stirling2, 0, sizeof(stirling2));
	stirling2[0][0] = 1;
	for (int i = 1; i &lt;= k; i ++)
		for (int j = 1; j &lt;= i; j ++)
			stirling2[i][j] = (stirling2[i - 1][j] * j + stirling2[i - 1][j - 1]) % modulo;

	memset(ind, 0, sizeof(ind));
	for (int i = 0; i &lt; n; i ++)
		for (int j = 0; j &lt; m; j ++)
			for (int k = 0; k &lt; 4; k ++) {
				int t1 = i + u[k][0];
				int t2 = j + u[k][1];
				if (0 &lt;= t1 &amp;&amp; t1 &lt; n &amp;&amp; 0 &lt;= t2 &amp;&amp; t2 &lt; m &amp;&amp; h[i][j] &lt; h[t1][t2]) {
					ind[t1 * m + t2] ++;
				}
			}

	int top = 0;
	memset(f, 0, sizeof(f));
	for (int i = 0; i &lt; n * m; i ++) {
		if (ind[i] == 0) stack[top ++] = i;
		f[i][0] = 1;
	}
	while (top &gt; 0) {
		int now = stack[-- top];
		for (int i = 0; i &lt; 4; i ++) {
			int x = now / m + u[i][0];
			int y = now % m + u[i][1];
			if (0 &gt; x || x &gt;= n || 0 &gt; y || y &gt;= m || h[now / m][now % m] &gt;= h[x][y])
				continue;
			int t = x * m + y;
			ind[t] --;
			if (ind[t] == 0) stack[top ++] = t;
			for (int j = 0; j &lt;= k; j ++) {
				f[t][j] = (f[t][j] + f[now][j]) % modulo;
				if (j &gt; 0) f[t][j] = (f[t][j] + f[now][j - 1]) % modulo;
			}
		}
	}

	for (int i = 0; i &lt;= k; i ++) {
		sum[i] = 0;
		for (int j = 0; j &lt; n * m; j ++)
			sum[i] = (sum[i] + f[j][i]) % modulo;
	}

	for (int i = 0; i &lt;= k; i ++) {
		int fac = 1, ans = 0;
		for (int j = 0; j &lt;= i; j ++) {
			if (j &gt; 0) fac = fac * j % modulo;
			ans = (ans + stirling2[i][j] * fac % modulo * sum[j]) % modulo;
		}
		if (i == 0) ans = ((ans - n * m) % modulo + modulo) % modulo;
		printf("%d\n", ans);
	}

	return 0;
}
</pre><pre></pre><h2>Problem3504</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int INF=1000000000;

int n,a1,a2,an,b1,b2,bn,N,cnt,S,T;
char mp[55][55];
int g[3000];
int vh[3000],pre[3000],dis[3000],his[3000],di[3000];
struct edge
{
    int t,c,next;
}e[50000];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline int isap()
{
    memset(vh,0,sizeof(vh));
    memset(dis,0,sizeof(dis));
    vh[0]=N;
    for(int i=1;i&lt;=N;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;

    while(dis[S]&lt;N)
    {
        bool flag=false;
        his[x]=aug;

        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                di[x]=i;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(!vh[dis[x]])break;

        int mi=N,mii=0;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }
        di[x]=mii;
        dis[x]=mi+1;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

inline void build()
{
    for(int i=0;i&lt;n;i++)
        for(int j=i+1;j&lt;n;j++)
            if(mp[i][j]=='O')
            {
                N++;
                add_edge(i+1,N,1000);
                add_edge(j+1,N,1000);
                add_edge(N,N+1,2);
                N++;
                add_edge(N,i+1,1000);
                add_edge(N,j+1,1000);
            }
            else
                if(mp[i][j]=='N')
                {
                    add_edge(i+1,j+1,1000);
                    add_edge(j+1,i+1,1000);
                }
}
inline bool test1()
{
    memset(g,0,sizeof(g));
    N=n;cnt=1;
    build();
    S=++N;T=++N;
    add_edge(S,a1,an);add_edge(S,b1,bn);
    add_edge(a2,T,an);add_edge(b2,T,bn);
    return isap()==an+bn;
}
inline bool test2()
{
    memset(g,0,sizeof(g));
    N=n;cnt=1;
    build();
    S=++N;T=++N;
    add_edge(S,a1,an);add_edge(S,b2,bn);
    add_edge(a2,T,an);add_edge(b1,T,bn);
    return isap()==an+bn;
}

int main()
{
    while(scanf("%d%d%d%d%d%d%d",&amp;n,&amp;a1,&amp;a2,&amp;an,&amp;b1,&amp;b2,&amp;bn)!=EOF)
    {
        a1++;a2++;b1++;b2++;
        an&lt;&lt;=1;bn&lt;&lt;=1;
        for(int i=0;i&lt;n;i++)
            scanf("%s",mp[i]);
        if(test1()&amp;&amp;test2())
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}
</pre><pre></pre><h2>Problem3524</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,size=0;
int root[500010];
int ls[10000010],rs[10000010],sum[10000010];

inline void build(int l,int r,int pre,int &amp;now,int v)
{
    now=++size;

    sum[now]=sum[pre]+1;

    if(l==r)return;

    ls[now]=ls[pre];
    rs[now]=rs[pre];

    int mid=(l+r)&gt;&gt;1;

    if(v&lt;=mid)
        build(l,mid,ls[pre],ls[now],v);
    else
        build(mid+1,r,rs[pre],rs[now],v);
}

inline int query(int L,int R)
{
    int x=root[L-1],y=root[R];
    int l=1,r=n,mid,num=(R-L+1)&gt;&gt;1;

    while(l!=r)
    {
        int mid=(l+r)&gt;&gt;1;

        if(sum[ls[y]]-sum[ls[x]]&gt;num)
            r=mid,x=ls[x],y=ls[y];
        else
            if(sum[rs[y]]-sum[rs[x]]&gt;num)
                l=mid+1,x=rs[x],y=rs[y];
            else
                return 0;
    }

    return l;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);

        build(1,n,root[i-1],root[i],x);
    }

    for(;m;m--)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);

        printf("%d\n",query(x,y));
    }

    return 0;
}</pre><pre></pre><h2>Problem3544</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;

using namespace std;

int n;
set&lt;long long&gt; s;
long long m,ans,x,pre;

inline long long max(long long a,long long b)
{
	return a&gt;b?a:b;
}

int main()
{
    scanf("%d%lld",&amp;n,&amp;m);
    
	s.insert(0);
    
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%lld",&amp;x);
        
        pre=(pre+x)%m;
        while(pre&lt;0)pre+=m;
        ans=max(ans,pre);
        
		set&lt;long long&gt;::iterator it;
        it=s.upper_bound(pre);
        
        if(it!=s.end())
        {
            long long temp=pre-*it;
            while(temp&lt;0)temp+=m;
            ans=max(ans,temp);
        }
        
        s.insert(pre);
    }
    printf("%lld\n",ans);
    
    return 0;
}</pre><pre></pre><h2>Problem3545</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;

using namespace std;

int n,N,m,cnt,idx,Q;
int g[200010],f[200010],st[200010],en[200010],pre[200010],root[200010];
int h[200010],H[200010],G[200010];
int fa[200010][20];
int siz;
int ls[5000010],rs[5000010],sum[5000010];
map&lt;int,int&gt;h1;
struct edge
{
    int x,y,z;
    inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
    {
        return a.z&lt;b.z;
    }
}E[500010];
struct size
{
    int t,next;
}e[200010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int find(int x)
{
    return f[x]=x==f[x]?x:find(f[x]);
}

inline void kruscal()
{
    sort(E+1,E+m+1);
    for(int i=1;i&lt;=m;i++)
    {
        if(find(E[i].x)!=find(E[i].y))
        {
            ++N;
            G[N]=E[i].z;
            h[N]=-1;
            int x=find(E[i].x),y=find(E[i].y);
            add_edge(N,x);
            add_edge(N,y);
            f[x]=N;
            f[y]=N;
            f[N]=N;
        }
    }
}

inline void modify(int l,int r,int&amp;y,int x,int val)
{
    y=++siz;sum[y]=sum[x]+1;
    if(l==r)return;
    ls[y]=ls[x];rs[y]=rs[x];
    int mid=(l+r)&gt;&gt;1;
    if(val&lt;=mid)
        modify(l,mid,ls[y],ls[x],val);
    else
        modify(mid+1,r,rs[y],rs[x],val);
}
inline int query(int x,int y,int k)
{
    int l=1,r=n+1;
    while(l!=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(sum[ls[y]]-sum[ls[x]]&gt;=k)
        {
            x=ls[x];y=ls[y];r=mid;
        }
        else
        {
            k-=sum[ls[y]]-sum[ls[x]];
            x=rs[x];y=rs[y];l=mid+1;
        }
    }
    return l;
}

inline void dfs(int x)
{
    st[x]=++idx;
    if(x==fa[x][0])
        pre[idx]=0;
    else
        pre[idx]=idx-1;
    modify(1,n+1,root[idx],root[pre[idx]],h1[h[x]]);
    for(int i=1;i&lt;=17;i++)
        fa[x][i]=fa[fa[x][i-1]][i-1];

    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa[x][0])
        {
            fa[e[i].t][0]=x;
            dfs(e[i].t);
        }
    en[x]=idx;
}

inline void swim(int&amp;x,int val)
{
    while(x!=fa[x][0])
    {
        int i=-1;
        while(G[fa[x][i+1]]&lt;=val&amp;&amp;i&lt;17)i++;
        if(i==-1)return;
        x=fa[x][i];
    }
}

inline bool cmp(const int&amp;a,const int&amp;b)
{
    return a&gt;b;
}

int main()
{
    n=read();m=read();Q=read();
    for(int i=1;i&lt;=n;i++)
    {
        f[i]=i;
        h[i]=read();
        H[i]=h[i];
    }
    sort(H+1,H+n+1,cmp);
    for(int i=1;i&lt;=n;i++)
        h1[H[i]]=i;
    h1[-1]=n+1;

    for(int i=1;i&lt;=m;i++)
    {
        E[i].x=read();
        E[i].y=read();
        E[i].z=read();
    }
    N=n;
    kruscal();

    for(int i=N;i;i--)
        if(!st[i])
        {
            fa[i][0]=i;
            dfs(i);
        }
    int lastans=0;
    for(;Q;Q--)
    {
        int v,x,k;
        x=read();v=read();k=read();
        swim(x,v);
        lastans=query(root[pre[st[x]]],root[en[x]],k);
        if(lastans==n+1)lastans=-1;else lastans=H[lastans];
        printf("%d\n",lastans);
    }

    return 0;
}
</pre><pre></pre><h2>Problem3549</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,h=1,t=1;
int sum[100010],f[100010],g[100010],q[100010];

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)
    {
        int x;
        scanf("%d",&amp;x);
        sum[i]=sum[i-1]+x;
    }

    q[1]=n+1;

    for(int i=n;i;i--)
    {
        while(t&gt;h&amp;&amp;sum[q[h+1]-1]-sum[i-1]&gt;=f[q[h+1]])h++;
        f[i]=sum[q[h]-1]-sum[i-1];
        g[i]=g[q[h]]+1;
        while(t&gt;h&amp;&amp;f[i]-sum[i-1]&lt;f[q[t]]-sum[q[t]-1])t--;
        q[++t]=i;
    }

    printf("%d\n",g[1]);

    return 0;
}
</pre><pre></pre><h2>Problem3551</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;

using namespace std;

int n,N,m,cnt,idx,Q;
int g[200010],f[200010],st[200010],en[200010],pre[200010],root[200010];
int h[200010],H[200010],G[200010];
int fa[200010][20];
int siz;
int ls[5000010],rs[5000010],sum[5000010];
map&lt;int,int&gt;h1;
struct edge
{
    int x,y,z;
    inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
    {
        return a.z&lt;b.z;
    }
}E[500010];
struct size
{
    int t,next;
}e[200010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int find(int x)
{
    return f[x]=x==f[x]?x:find(f[x]);
}

inline void kruscal()
{
    sort(E+1,E+m+1);
    for(int i=1;i&lt;=m;i++)
    {
        if(find(E[i].x)!=find(E[i].y))
        {
            ++N;
            G[N]=E[i].z;
            h[N]=-1;
            int x=find(E[i].x),y=find(E[i].y);
            add_edge(N,x);
            add_edge(N,y);
            f[x]=N;
            f[y]=N;
            f[N]=N;
        }
    }
}

inline void modify(int l,int r,int&amp;y,int x,int val)
{
    y=++siz;sum[y]=sum[x]+1;
    if(l==r)return;
    ls[y]=ls[x];rs[y]=rs[x];
    int mid=(l+r)&gt;&gt;1;
    if(val&lt;=mid)
        modify(l,mid,ls[y],ls[x],val);
    else
        modify(mid+1,r,rs[y],rs[x],val);
}
inline int query(int x,int y,int k)
{
    int l=1,r=n+1;
    while(l!=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(sum[ls[y]]-sum[ls[x]]&gt;=k)
        {
            x=ls[x];y=ls[y];r=mid;
        }
        else
        {
            k-=sum[ls[y]]-sum[ls[x]];
            x=rs[x];y=rs[y];l=mid+1;
        }
    }
    return l;
}

inline void dfs(int x)
{
    st[x]=++idx;
    if(x==fa[x][0])
        pre[idx]=0;
    else
        pre[idx]=idx-1;
    modify(1,n+1,root[idx],root[pre[idx]],h1[h[x]]);
    for(int i=1;i&lt;=17;i++)
        fa[x][i]=fa[fa[x][i-1]][i-1];

    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa[x][0])
        {
            fa[e[i].t][0]=x;
            dfs(e[i].t);
        }
    en[x]=idx;
}

inline void swim(int&amp;x,int val)
{
    while(x!=fa[x][0])
    {
        int i=-1;
        while(G[fa[x][i+1]]&lt;=val&amp;&amp;i&lt;17)i++;
        if(i==-1)return;
        x=fa[x][i];
    }
}

inline bool cmp(const int&amp;a,const int&amp;b)
{
    return a&gt;b;
}

int main()
{
    n=read();m=read();Q=read();
    for(int i=1;i&lt;=n;i++)
    {
        f[i]=i;
        h[i]=read();
        H[i]=h[i];
    }
    sort(H+1,H+n+1,cmp);
    for(int i=1;i&lt;=n;i++)
        h1[H[i]]=i;
    h1[-1]=n+1;

    for(int i=1;i&lt;=m;i++)
    {
        E[i].x=read();
        E[i].y=read();
        E[i].z=read();
    }
    N=n;
    kruscal();

    for(int i=N;i;i--)
        if(!st[i])
        {
            fa[i][0]=i;
            dfs(i);
        }
    int lastans=0;
    for(;Q;Q--)
    {
        int v,x,k;
        x=read();v=read();k=read();
        if(lastans!=-1)
        {
            x^=lastans;
            v^=lastans;
            k^=lastans;
        }
        swim(x,v);
        lastans=query(root[pre[st[x]]],root[en[x]],k);
        if(lastans==n+1)lastans=-1;else lastans=H[lastans];
        printf("%d\n",lastans);
    }

    return 0;
}
</pre><pre></pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

using namespace std;

const int p1=10007;
const int p2=3000017;

int n,m;
long long ans;
char str[210];
int h1[30010][210],h3[30010][210];
unsigned int h2[30010][210],h4[30010][210];

struct Hash
{
	int h1,h3;
	unsigned int h2,h4;
	inline Hash():h1(0),h2(0),h3(0),h4(0){}
	inline Hash(int H1,unsigned int H2,int H3,unsigned int H4):h1(H1),h2(H2),h3(H3),h4(H4){}
	inline friend bool operator&lt;(const Hash&amp;a,const Hash&amp;b)
		{
			return a.h1&lt;b.h1||(a.h1==b.h1&amp;&amp;a.h2&lt;b.h2||(a.h2==b.h2&amp;&amp;a.h3&lt;b.h3||(a.h3==b.h3&amp;&amp;a.h4&lt;b.h4)));
		}
	inline friend bool operator==(const Hash&amp;a,const Hash&amp;b)
		{
			return a.h1==b.h1&amp;&amp;a.h2==b.h2&amp;&amp;a.h3==b.h3&amp;&amp;a.h4==b.h4;
		}
}h[30010];

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}

inline void init(int i,int len)
{
	for(int j=1;j&lt;=len;j++)
	{
		h1[i][j]=((long long)h1[i][j-1]*p1+str[j-1])%p2;
		h2[i][j]=h2[i][j-1]*p2+str[j-1];
	}
	for(int j=len;j;j--)
	{
		h3[i][j]=((long long)h3[i][j+1]*p1+str[j-1])%p2;
		h4[i][j]=h4[i][j+1]*p2+str[j-1];
	}
}

int main()
{
	n=read();m=read();ans=read();ans=0;
    for(int i=1;i&lt;=n;i++)
	{
		scanf("%s",str);
		init(i,m);
	}
	
	for(int j=1;j&lt;=m;j++)
	{
		for(int i=1;i&lt;=n;i++)
			h[i]=Hash(h1[i][j-1],h2[i][j-1],h3[i][j+1],h4[i][j+1]);
	    sort(h+1,h+n+1);
		int temp=1;
		for(int i=2;i&lt;=n;i++)
			if(h[i]==h[i-1])
			{
				ans+=temp;
				temp++;
			}
			else
				temp=1;
	}
	printf("%lld\n",ans);		
			
	return 0;
}
</pre><pre></pre><h2>Problem3563</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,m,q,num,pre,ans;
int fa[100010];
int e[500010];

char c;

bitset&lt;500010&gt; v;

struct size
{
	int s,t;
}edge[500010];

int find(int x)
{
	return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline int read()
{
	int temp=0;
	
	c=getchar();
	
	while(c&lt;'0'||c&gt;'9')c=getchar();
	
	while(c&gt;='0'&amp;&amp;c&lt;='9')
	{
		temp=temp*10+(int)(c-'0');
		c=getchar();
	}
	
	return temp;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	
	for(int i=1;i&lt;=m;i++)
		scanf("%d%d",&amp;edge[i].s,&amp;edge[i].t);
	
	scanf("%d",&amp;q);

	int k=read();

	for(num=0;c!='\n'&amp;&amp;c!='\r';e[++num]=read());
		
	for(q--;q;q--)
	{
		int k=read();
		
		for(num=0;c!='\n'&amp;&amp;c!='\r';e[++num]=read());
		
		if((k^num)-pre==1)
			printf("Connected\n");
		else
			printf("Disconnected\n");
		pre=k^num;
	}
	
	v.reset();
	
	for(int i=1;i&lt;=num;i++)
		v.set(e[i]^num);
	
	for(int i=1;i&lt;=n;i++)
		fa[i]=i;
	
	for(int i=1;i&lt;=m;i++)
		if(!v.test(i))
			if(find(edge[i].s)!=find(edge[i].t))
			{
				ans++;
				fa[fa[edge[i].s]]=fa[edge[i].t];
			}
	
	if(ans==n-1)
		printf("Connected\n");
	else
		printf("Disconnected\n");
	
	return 0;
}</pre><pre></pre><h2>Problem3570</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const int inf=1e9;

int n,q,C;

struct size
{
	int num,L,R;
	size *fa,*l,*r;
}*root=new size;

inline void left(size *temp)
{
	size *p=temp-&gt;fa;

	p-&gt;r=temp-&gt;l;

	p-&gt;R=temp-&gt;L;
	temp-&gt;L+=p-&gt;L+1;

	if(p-&gt;r!=NULL)
		p-&gt;r-&gt;fa=p;

	temp-&gt;fa=p-&gt;fa;

	if(p-&gt;fa!=NULL)
		if(p==p-&gt;fa-&gt;l)
			p-&gt;fa-&gt;l=temp;
		else
			p-&gt;fa-&gt;r=temp;

	p-&gt;fa=temp;
	temp-&gt;l=p;
}

inline void right(size *temp)
{
	size *p=temp-&gt;fa;

	p-&gt;l=temp-&gt;r;

	p-&gt;L=temp-&gt;R;
	temp-&gt;R+=p-&gt;R+1;

	if(p-&gt;l!=NULL)
		p-&gt;l-&gt;fa=p;

	temp-&gt;fa=p-&gt;fa;

	if(p-&gt;fa!=NULL)
		if(p==p-&gt;fa-&gt;l)
			p-&gt;fa-&gt;l=temp;
		else
			p-&gt;fa-&gt;r=temp;

	p-&gt;fa=temp;
	temp-&gt;r=p;
}

inline void splay(size *temp)
{
	while(temp-&gt;fa!=NULL)
	{
		size *p=temp-&gt;fa;

		if(p-&gt;fa==NULL)
			if(temp==p-&gt;r)
				left(temp);
			else
				right(temp);
		else
			if(p==p-&gt;fa-&gt;l)
				if(temp==p-&gt;l)
				{
					right(p);
					right(temp);
				}
				else
				{
					left(temp);
					right(temp);
				}
			else
				if(temp==p-&gt;l)
				{
					right(temp);
					left(temp);
				}
				else
				{
					left(p);
					left(temp);
				}
	}

	root=temp;
}

inline void insert(int x)
{
	size *p=root,*temp=new size;
	temp-&gt;num=x;
	temp-&gt;l=temp-&gt;r=NULL;
	temp-&gt;L=temp-&gt;R=0;

	while(1)
	{
		if(x&lt;p-&gt;num)
			if(p-&gt;l!=NULL)
				p-&gt;L++,p=p-&gt;l;
			else
			{
			    p-&gt;L++;
				p-&gt;l=temp;
				temp-&gt;fa=p;
				break;
			}
		else
			if(p-&gt;r!=NULL)
				p-&gt;R++,p=p-&gt;r;
			else
			{
			    p-&gt;R++;
				p-&gt;r=temp;
				temp-&gt;fa=p;
				break;
			}
	}

	splay(temp);
}

inline int find(int x)
{
	size *p=root;

	while(1)
	{
		if(p-&gt;L+1==x)
			break;

		if(p-&gt;L&gt;=x)
			p=p-&gt;l;
		else
		{
		    x-=p-&gt;L+1;
		    p=p-&gt;r;
		}
	}

	splay(p);

	return root-&gt;num;
}

inline double calc(int x,int y)
{
    return (double)sqrt((long long)2*C*x+(long long)y*y);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;C);

	int x,y,z;
	scanf("%d%d%d",&amp;x,&amp;y,&amp;z);

	root-&gt;num=x;
	root-&gt;fa=root-&gt;l=root-&gt;r=NULL;
	root-&gt;L=root-&gt;R=0;

	for(int i=1;i&lt;n;i++)
	{
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);

		insert(x);
	}

	scanf("%d",&amp;q);

	while(q--)
    {
        scanf("%d",&amp;x);
        if(x)
        {
            scanf("%d%d",&amp;x,&amp;y);

            printf("%.3lf\n",calc(x,find(y)));
        }
        else
        {
            scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
            insert(x);
        }
    }

	return 0;
}</pre><pre></pre><h2>Problem3576</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
#include&lt;cmath&gt;

using namespace std;

int n,f;
int sg[100010];

bitset&lt;10010&gt; v;

inline void calc(int x)
{
    for(int i=f+1;i&lt;=x;i++)
    {
        v.reset();
        int q=(int)ceil(sqrt(i));

        for(int j=1;j&lt;=q;j++)
        {
            int a=j,b=j+1;
            int x=i/a,y=i-x*a;
            x-=y;
            if(x&lt;0)break;

            int temp=sg[(x&amp;1)*a]^sg[(y&amp;1)*b];

            v.set(temp);
            if(a%2&amp;&amp;x&gt;=b)v.set(temp^sg[b]);
            if(a%2==0&amp;&amp;b*(y+a)&lt;=i)v.set(temp^sg[a]);
        }

        for(int m=1;m&lt;=q;m++)
        {
            int a=i/m,b=a+1;
            int y=i-a*m,x=m-y;
            if(x&lt;0)break;

            v.set(sg[(x&amp;1)*a]^sg[(y&amp;1)*b]);
        }

        for (int j=0;j&lt;=10000;j++)
            if(!v.test(j))
            {
                sg[i]=j;
                break;
            }
    }

    f=x;
}
int main()
{
	scanf("%d%d",&amp;n,&amp;f);
	if(f==1)f=2;
	f--;

	for(int i=1;i&lt;n;i++)
	{
		int x,j,temp=0;
		scanf("%d",&amp;j);

		for(;j;j--)
		{
			scanf("%d",&amp;x);
			if(x&gt;f)calc(x);
			temp^=sg[x];
		}

		printf("%d ",temp?1:0);
	}

	int x,j,temp=0;
    scanf("%d",&amp;j);

    for(;j;j--)
    {
        scanf("%d",&amp;x);
        if(x&gt;f)calc(x);
        temp^=sg[x];
    }

    printf("%d\n",temp?1:0);

	return 0;
}
</pre><pre></pre><h2>Problem3577</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1e9;

int n,r,c,a,b,num=-1,S,T;
int pow[10],log[70];
int fs[70][70][10],ft[70][70][10];
int dis[60010],vh[60010],his[60010],pre[60010];

struct size
{
	int ch;
	size *next;
}*g[60010],*di[60010];

struct size1
{
	int t,c;
}edge[500010];

inline int min(int a,int b)
{
	return a&lt;b?a:b;
}

inline void add_edge(int x,int y,int z)
{
	edge[++num].t=y;
	edge[num].c=z;

	size *p=new size;
	p-&gt;ch=num;
	p-&gt;next=g[x];
	g[x]=p;

	edge[++num].t=x;
	edge[num].c=0;

	p=new size;
	p-&gt;ch=num;
	p-&gt;next=g[y];
	g[y]=p;
}

inline int isap()
{
	vh[0]=T;
	for(int i=1;i&lt;=T;i++)
		di[i]=g[i];

	int aug=inf,i=S,flow=0;

	while(dis[S]&lt;T)
	{
		bool flag=false;
		his[i]=aug;

		for(size *p=di[i];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&amp;&amp;dis[i]==dis[edge[p-&gt;ch].t]+1)
			{
				di[i]=p;
				flag=true;
				aug=min(aug,edge[p-&gt;ch].c);
				pre[edge[p-&gt;ch].t]=1^p-&gt;ch;
				i=edge[p-&gt;ch].t;

				if(i==T)
				{
					flow+=aug;
					for(;i!=S;i=edge[pre[i]].t)
					{
						edge[pre[i]].c+=aug;
						edge[1^pre[i]].c-=aug;
					}
					aug=inf;
				}

				break;
			}

		if(flag)continue;

		int mi=T;
		size *pp;

		for(size *p=g[i];p;p=p-&gt;next)
			if(edge[p-&gt;ch].c&amp;&amp;dis[edge[p-&gt;ch].t]+1&lt;mi)
				mi=dis[edge[p-&gt;ch].t]+1,pp=p;

		di[i]=pp;
		vh[dis[i]]--;
		if(!vh[dis[i]])break;
		dis[i]=mi;
		vh[dis[i]]++;

		if(i!=S)
		{
			i=edge[pre[i]].t;
			aug=his[i];
		}
	}

	return flow;
}

int main()
{
    int i,j,k;

    scanf("%d%d%d%d",&amp;r,&amp;c,&amp;a,&amp;b);

    for(pow[0]=i=1;i&lt;8;i++)
        pow[i]=pow[i-1]&lt;&lt;1;

    for(i=1;i&lt;62;i++)
        for(j=i;j&gt;1;j&gt;&gt;=1,log[i]++);

    for(i=1;i&lt;=r;i++)
        for(j=1;j&lt;=c;j++)
        {
            int x;
            scanf("%d",&amp;x);

            fs[i][j][0]=++n;
            ft[i][j][0]=++n;

            add_edge(fs[i][j][0],ft[i][j][0],x);
        }

    for(k=1;k&lt;6;k++)
        for(i=1;i&lt;=r;i++)
            for(j=1;j&lt;=c;j++)
                if(i+pow[k]-1&lt;=r&amp;&amp;j+pow[k]-1&lt;=c)
                {
                    fs[i][j][k]=++n;
                    ft[i][j][k]=++n;

                    add_edge(fs[i][j][k],fs[i][j][k-1],inf);
                    add_edge(ft[i][j][k-1],ft[i][j][k],inf);

                    add_edge(fs[i][j][k],fs[i+pow[k-1]][j][k-1],inf);
                    add_edge(ft[i+pow[k-1]][j][k-1],ft[i][j][k],inf);

                    add_edge(fs[i][j][k],fs[i][j+pow[k-1]][k-1],inf);
                    add_edge(ft[i][j+pow[k-1]][k-1],ft[i][j][k],inf);

                    add_edge(fs[i][j][k],fs[i+pow[k-1]][j+pow[k-1]][k-1],inf);
                    add_edge(ft[i+pow[k-1]][j+pow[k-1]][k-1],ft[i][j][k],inf);
                }

    S=n+a+b+1;
    T=S+1;

    while(a--)
    {
        int w,x1,y1,x2,y2;

        scanf("%d%d%d%d%d",&amp;w,&amp;x1,&amp;y1,&amp;x2,&amp;y2);

        add_edge(S,i=++n,w);
        k=log[j=x2-x1+1];

        add_edge(i,fs[x1][y1][k],inf);
        add_edge(i,fs[x1][y2-pow[k]+1][k],inf);

        add_edge(i,fs[x2-pow[k]+1][y1][k],inf);
        add_edge(i,fs[x2-pow[k]+1][y2-pow[k]+1][k],inf);
    }

    while(b--)
    {
        int w,x1,y1,x2,y2;

        scanf("%d%d%d%d%d",&amp;w,&amp;x1,&amp;y1,&amp;x2,&amp;y2);

        add_edge(i=++n,T,w);
        k=log[j=x2-x1+1];

        add_edge(ft[x1][y1][k],i,inf);
        add_edge(ft[x1][y2-pow[k]+1][k],i,inf);

        add_edge(ft[x2-pow[k]+1][y1][k],i,inf);
        add_edge(ft[x2-pow[k]+1][y2-pow[k]+1][k],i,inf);
    }
    
    printf("%d\n",isap());

	return 0;
}
</pre><pre></pre><h2>Problem3585</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;

using namespace std;

int n,m;
int a[200010],b[200010],nxt[200010];
int ans[200010];
bool num[200010];
map&lt;int,int&gt;h;
struct qry
{
    int l,r,id;
    inline friend bool operator&lt;(const qry&amp;a,const qry&amp;b)
    {
        return a.l&lt;b.l;
    }
}q[200010];
struct seg_tree
{
    int l,r,v;
}seg[800010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}
inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r)
    {
        seg[p].v=b[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
    seg[p].v=Max(seg[p&lt;&lt;1].v,seg[p&lt;&lt;1|1].v);
}
inline void push_down(int p)
{
    seg[p&lt;&lt;1].v=Min(seg[p&lt;&lt;1].v,seg[p].v);
    seg[p&lt;&lt;1|1].v=Min(seg[p&lt;&lt;1|1].v,seg[p].v);
}
inline void modify(int p,int l,int r,int val)
{
    if(seg[p].v&lt;=val)return;
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)
    {
        seg[p].v=val;
        return;
    }
    push_down(p);
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        modify(p&lt;&lt;1,l,r,val);
    else
        if(l&gt;mid)
            modify(p&lt;&lt;1|1,l,r,val);
        else
        {
            modify(p&lt;&lt;1,l,mid,val);
            modify(p&lt;&lt;1|1,mid+1,r,val);
        }
    seg[p].v=Max(seg[p&lt;&lt;1].v,seg[p&lt;&lt;1|1].v);
}
inline int query(int p,int pos)
{
    int l=1,r=n;
    while(l!=r)
    {
        push_down(p);
        int mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)
        {
            r=mid;p&lt;&lt;=1;
        }
        else
        {
            l=mid+1;p=p&lt;&lt;1|1;
        }
    }
    return seg[p].v;
}

int main()
{
    n=read();m=read();
    int temp=0;
    for(int i=1;i&lt;=n;i++)
	{
		a[i]=read();
		h[a[i]]=n+1;
		if(a[i]&lt;n)
		{
			num[a[i]]=true;
			while(num[temp])temp++;
		}
		b[i]=temp;
	}
	for(int i=n;i;i--)
    {
        nxt[i]=h[a[i]]-1;
        h[a[i]]=i;
    }

    for(int i=1;i&lt;=m;i++)
    {
        q[i].l=read();
        q[i].r=read();
        q[i].id=i;
    }
    sort(q+1,q+m+1);

    build(1,1,n);
    temp=1;
    for(int i=1;i&lt;=m;i++)
    {
        while(temp&lt;q[i].l)
        {
            modify(1,temp,nxt[temp],a[temp]);
            temp++;
        }
        ans[q[i].id]=query(1,q[i].r);
    }

    for(int i=1;i&lt;=m;i++)
        printf("%d\n",ans[i]);

    return 0;
}
</pre><pre></pre><h2>Problem3624</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,k;
int num,sum1,sum2;
int fa[20010];

struct size
{
    int x,y,use;
}edgea[100010],edgeb[100010];

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline void unio(int x,int y)
{
    fa[find(x)]=find(y);
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);

        if(z)
        {
            edgea[++sum1].x=x;
            edgea[sum1].y=y;
        }
        else
        {
            edgeb[++sum2].x=x;
            edgeb[sum2].y=y;
        }
    }

    for(int i=1;i&lt;=n;i++)fa[i]=i;

    for(int i=1;i&lt;=sum1;i++)
        if(find(edgea[i].x)!=find(edgea[i].y))
            unio(edgea[i].x,edgea[i].y);

    for(int i=1;i&lt;=sum2;i++)
        if(find(edgeb[i].x)!=find(edgeb[i].y))
        {
            unio(edgeb[i].x,edgeb[i].y);
            edgeb[i].use=1;
            num++;
        }

    if(num&gt;k)
    {
        printf("no solution\n");

        return 0;
    }

    for(int i=1;i&lt;=n;i++)fa[i]=i;

    for(int i=1;i&lt;=sum2;i++)
        if(edgeb[i].use==1)
            unio(edgeb[i].x,edgeb[i].y);

    for(int i=1;i&lt;=sum2;i++)
        if(edgeb[i].use==0&amp;&amp;find(edgeb[i].x)!=find(edgeb[i].y)&amp;&amp;num&lt;k)
    {
        unio(edgeb[i].x,edgeb[i].y);
        edgeb[i].use=1;
        num++;
    }

    for(int i=1;i&lt;=sum1;i++)
        if(find(edgea[i].x)!=find(edgea[i].y))
    {
        unio(edgea[i].x,edgea[i].y);
        edgea[i].use=1;
    }

    for(int i=1;i&lt;=sum1;i++)
        if(edgea[i].use)
            printf("%d %d 1\n",edgea[i].x,edgea[i].y);

    for(int i=1;i&lt;=sum2;i++)
        if(edgeb[i].use)
            printf("%d %d 0\n",edgeb[i].x,edgeb[i].y);

    return 0;
}
</pre><pre></pre><h2>Problem3631</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt;
int g[300010],a[300010];
int dep[300010],tag[300010];
int fa[300010][20];

struct edge
{
    int t,next;
}e[1000000];

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void dfs(int x,int depth)
{
    dep[x]=depth;
    for(int i=1;i&lt;20;i++)
        fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int i=g[x];i;i=e[i].next)
        if(!dep[e[i].t])
        {
            fa[e[i].t][0]=x;
            dfs(e[i].t,depth+1);
        }
}
inline void dfs2(int x)
{
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa[x][0])
        {
            dfs2(e[i].t);
            tag[x]+=tag[e[i].t];
        }
}

inline void swim(int &amp;x,int h)
{
    for(int i=0;h;i++,h&gt;&gt;=1)
        if(h&amp;1)
            x=fa[x][i];
}

inline int LCA(int x,int y)
{
    if(dep[x]&lt;dep[y])
    {
        int temp=x;
        x=y;
        y=temp;
    }
    swim(x,dep[x]-dep[y]);
    if(x==y)return x;
    int i=19;
    while(true)
    {
        for(;fa[x][i]==fa[y][i]&amp;&amp;i&gt;=0;i--);
        if(i==-1)return fa[x][0];
        x=fa[x][i];
        y=fa[y][i];
    }
}

int main()
{
    scanf("%d",&amp;n);

    for(int i=1;i&lt;=n;i++)scanf("%d",a+i);

    for(int i=1;i&lt;n;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        add_edge(x,y);
        add_edge(y,x);
    }
    fa[1][0]=1;
    dfs(1,1);

    for(int i=2;i&lt;=n;i++)
    {
        int x=a[i-1],y=a[i];
        int z=LCA(x,y);
        tag[x]++;
        tag[y]++;
        tag[z]--;
        if(z!=1)tag[fa[z][0]]--;
    }
    dfs2(1);

    for(int i=1;i&lt;=n;i++)
        printf("%d\n",i==a[1]?tag[i]:tag[i]-1);

    return 0;
}</pre><pre></pre><h2>Problem3632</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,ans,f[55],flo[55][55];
bool g[55][55];

inline bool DFS(int cur,int res)
{
	if(!cur)
	{
		if(res&gt;ans)
		{
			ans=res;
			return true;
		}
		return false;
	}

	for(int i=0;i&lt;cur;i++)
	{
		if(res+cur-i&lt;=ans)
			return false;
		int u=flo[res][i];
		if(res+f[u]&lt;=ans)
			return false;
		int suf=0;
		for(int j=i+1;j&lt;cur;j++)
			if(g[u][flo[res][j]])
				flo[res+1][suf++]=flo[res][j];
		if(DFS(suf,res+1))
			return true;
	}

	return false;
}

int maxclique()
{
	for(int i=n-1;i&gt;=0;i--)
	{
		int cur=0;
		for(int j=i+1;j&lt;n;j++)
			if(g[i][j])
				flo[1][cur++]=j;
		DFS(cur,1);
		f[i]=ans;
	}

	return ans;
}

int main()
{
	scanf("%d",&amp;n);

	int u,v;
	while(scanf("%d%d",&amp;u,&amp;v)!=EOF)
		g[u-1][v-1]=g[v-1][u-1]=true;

	printf("%d\n",maxclique());
	
	return 0;
}</pre><pre></pre><h2>Problem3644</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;

using namespace std;

struct TreeEdge {
	int data;
	TreeEdge *next;
} *ge[100000];

struct SplayNode {
	SplayNode *ch[2], *pre;
	int no, size;
	bool kind;
} *loc1[100000], *loc2[100000], *null;

int q[100000], size[100000], next[100000], leave[100000];
int top[100000], depth[100000], chain[100000], a[100000];
int pre[100000][18], up[100000], down[100000];
bool v[100000];

void insertEdge(int a, int b) {
	static TreeEdge buf[200000];
	static int top = 0;
	TreeEdge *p = &amp;buf[top ++];
	p-&gt;data = b;
	p-&gt;next = ge[a];
	ge[a] = p;
}

SplayNode* newSplayNode(int x) {
	static SplayNode buf[200001];
	static int top = 0;
	SplayNode *p = &amp;buf[top ++];
	p-&gt;pre = p-&gt;ch[0] = p-&gt;ch[1] = null;
	p-&gt;kind = false;
	p-&gt;no = x;
	p-&gt;size = 1;
	return p;
}

void rotate(SplayNode *x, int c) {
	SplayNode *y = x-&gt;pre;
	x-&gt;pre = y-&gt;pre;
	if (y-&gt;kind) y-&gt;pre-&gt;ch[y == y-&gt;pre-&gt;ch[1]] = x;
	y-&gt;ch[! c] = x-&gt;ch[c];
	if (x-&gt;ch[c] != null) x-&gt;ch[c]-&gt;pre = y;
	x-&gt;ch[c] = y;
	y-&gt;pre = x;
	if (! y-&gt;kind) {
		x-&gt;kind = false;
		y-&gt;kind = true;
	}
	y-&gt;size = y-&gt;ch[0]-&gt;size + y-&gt;ch[1]-&gt;size + 1;
	x-&gt;size = x-&gt;ch[0]-&gt;size + x-&gt;ch[1]-&gt;size + 1;
}

void splay(SplayNode *x) {
	while (x-&gt;kind)
		if (! x-&gt;pre-&gt;kind) {
			rotate(x, x == x-&gt;pre-&gt;ch[0]);
		} else {
			SplayNode *y = x-&gt;pre, *z = y-&gt;pre;
			if (y == z-&gt;ch[0]) {
				if (x == y-&gt;ch[0]) {
					rotate(y, 1);
					rotate(x, 1);
				} else {
					rotate(x, 0);
					rotate(x, 1);
				}
			} else {
				if (x == y-&gt;ch[1]) {
					rotate(y, 0);
					rotate(x, 0);
				} else {
					rotate(x, 1);
					rotate(x, 0);
				}
			}
		}
}

void expose(SplayNode *x) {
	SplayNode *u = x, *v = null;
	while (u != null) {
		splay(u);
		if (u-&gt;ch[1] != null) u-&gt;ch[1]-&gt;kind = false;
		u-&gt;ch[1] = v;
		if (v != null) {
			v-&gt;kind = true;
			v-&gt;pre = u;
		}
		u-&gt;size = u-&gt;ch[0]-&gt;size + u-&gt;ch[1]-&gt;size + 1;
		v = u;
		u = u-&gt;pre;
	}
}

void decompose(int n) {
	int head = 0, tail = 1;
	memset(v, false, sizeof(v));
	v[0] = true;
	q[0] = 0;
	depth[0] = 0;
	memset(pre, -1, sizeof(pre));
	while (head &lt; tail) {
		int now = q[head ++];
		for (TreeEdge *p = ge[now]; p; p = p-&gt;next)
			if (! v[p-&gt;data]) {
				v[p-&gt;data] = true;
				depth[p-&gt;data] = depth[now] + 1;
				pre[p-&gt;data][0] = now;
				for (int i = 1; 1 &lt;&lt; i &lt;= depth[p-&gt;data]; i ++)
					pre[p-&gt;data][i] = pre[pre[p-&gt;data][i - 1]][i - 1];
				q[tail ++] = p-&gt;data;
			}
	}
	for (int i = tail - 1; i &gt;= 0; i --) {
		int now = q[i];
		v[now] = false;
		size[now] = 1;
		next[now] = -1;
		for (TreeEdge *p = ge[now]; p; p = p-&gt;next)
			if (! v[p-&gt;data]) {
				size[now] += size[p-&gt;data];
				if (next[now] == -1 || size[p-&gt;data] &gt; size[next[now]])
					next[now] = p-&gt;data;
			}
	}
	for (int i = 0; i &lt; n; i ++) {
		loc1[i] = newSplayNode(i);
		loc2[i] = newSplayNode(i);
		up[i] = down[i] = -1;
	}
	for (int i = 0; i &lt; tail; i ++) {
		int now = q[i];
		if (v[now]) continue;
		int tot = 0;
		while (now != -1) {
			chain[tot ++] = now;
			v[now] = true;
			now = next[now];
		}
		for (int j = 0; j &lt; tot; j ++) top[chain[j]] = chain[0];
		for (int j = 0; j &lt; tot; j ++) {
			if (j - a[chain[j]] &gt;= 0) {
				int maxv = 0, d = 0;
				for (int k = 1; k &lt;= a[chain[j]]; k ++)
					if (k + a[chain[j - k]] &gt; maxv) {
						maxv = k + a[chain[j - k]];
						d = k;
					}
				up[chain[j]] = chain[j - d];
				loc1[chain[j]]-&gt;pre = loc1[chain[j - d]];
			}
			if (j + a[chain[j]] &lt; tot) {
				int maxv = 0, d = 0;
				for (int k = 1; k &lt;= a[chain[j]]; k ++)
					if (k + a[chain[j + k]] &gt; maxv) {
						maxv = k + a[chain[j + k]];
						d = k;
					}
				down[chain[j]] = chain[j + d];
				loc2[chain[j]]-&gt;pre = loc2[chain[j + d]];
			}
		}
	}
}

int getLca(int a, int b) {
	if (depth[a] &lt; depth[b]) swap(a, b);
	int lg = 0;
	while (1 &lt;&lt; lg &lt;= depth[a]) lg ++;
	for (int i = lg - 1; i &gt;= 0; i --)
		if (depth[a] - (1 &lt;&lt; i) &gt;= depth[b]) a = pre[a][i];
	if (a == b) return a;
	for (int i = lg - 1; i &gt;= 0; i --)
		if (pre[a][i] != pre[b][i]) {
			a = pre[a][i];
			b = pre[b][i];
		}
	return pre[a][0];
}

pair&lt;int, int&gt; goUp(int x, int y) {
	expose(loc1[x]);
	splay(loc1[x]);
	SplayNode *now = loc1[x], *last;
	int res = 0;
	while (now != null) {
		if (depth[now-&gt;no] - a[now-&gt;no] &gt;= depth[y]) {
			last = now;
			res += now-&gt;ch[1]-&gt;size + 1;
			now = now-&gt;ch[0];
		} else {
			now = now-&gt;ch[1];
		}
	}
	return make_pair(res, up[last-&gt;no]);
}

pair&lt;int, int&gt; goDown(int x, int y) {
	expose(loc2[x]);
	splay(loc2[x]);
	SplayNode *now = loc2[x], *last;
	int res = 0;
	while (now != null) {
		if (depth[now-&gt;no] + a[now-&gt;no] &lt;= depth[y]) {
			last = now;
			res += now-&gt;ch[1]-&gt;size + 1;
			now = now-&gt;ch[0];
		} else {
			now = now-&gt;ch[1];
		}
	}
	return make_pair(res, down[last-&gt;no]);
}

int query(int s, int t) {
	int lca = getLca(s, t);
	leave[top[t]] = -1;
	for (int i = t; top[i] != top[lca]; )
		if (i != top[i]) {
			i = top[i];
		} else {
			leave[top[pre[i][0]]] = i;
			i = pre[i][0];
		}

	int res = 1, now = s;
	while (depth[now] - depth[lca] &gt; a[now]) {
		if (top[now] == top[lca]) {
			pair&lt;int, int&gt; tmp = goUp(now, next[lca]);
			res += tmp.first;
			now = tmp.second;
		} else if (depth[now] - depth[top[now]] &lt; a[now]) {
			int maxv = 0, cur = now, target;
			for (int i = 1; i &lt;= a[now]; i ++) {
				cur = pre[cur][0];
				if (i + a[cur] &gt; maxv) {
					maxv = i + a[cur];
					target = cur;
				}
			}
			res ++;
			now = target;
		} else {
			pair&lt;int, int&gt; tmp = goUp(now, top[now]);
			res += tmp.first;
			now = tmp.second;
		}
	}

	bool flag = false;
	while (! flag || depth[t] - depth[now] &gt; a[now]) {
		if (! flag) {
			bool flag2 = false;
			int maxv = 0, cur = now, target;
			for (int i = 1; i &lt;= a[now]; i ++) {
				if (cur == lca) flag2 = true;
				if (flag2) {
					if (leave[top[cur]] != -1 &amp;&amp; pre[leave[top[cur]]][0] == cur) {
						cur = leave[top[cur]];
					} else {
						cur = next[cur];
					}
				} else {
					cur = pre[cur][0];
				}
				if (cur == t) return res;
				if (i + a[cur] &gt; maxv) {
					maxv = i + a[cur];
					target = cur;
					if (flag2) flag = true;
				}
			}
			res ++;
			now = target;
		} else if (leave[top[now]] == -1) {
			pair&lt;int, int&gt; tmp = goDown(now, pre[t][0]);
			res += tmp.first;
			now = tmp.second;
		} else {
			int bottom = pre[leave[top[now]]][0];
			if (depth[bottom] - depth[now] &lt; a[now]) {
				int maxv = 0, cur = now, target;
				for (int i = 1; i &lt;= a[now]; i ++) {
					if (leave[top[cur]] != -1 &amp;&amp; pre[leave[top[cur]]][0] == cur) {
						cur = leave[top[cur]];
					} else {
						cur = next[cur];
					}
					if (i + a[cur] &gt; maxv) {
						maxv = i + a[cur];
						target = cur;
					}
				}
				res ++;
				now = target;
			} else {
				pair&lt;int, int&gt; tmp = goDown(now, bottom);
				res += tmp.first;
				now = tmp.second;
			}
		}
	}

	return res;
}

void updateUp(int x) {
	if (up[x] != -1) {
		expose(loc1[up[x]]);
		splay(loc1[x]);
		loc1[x]-&gt;pre = null;
		up[x] = -1;
	}
	int maxv = 0, cur = x, target;
	for (int i = 1; i &lt;= a[x]; i ++) {
		if (cur == top[cur]) return;
		cur = pre[cur][0];
		if (i + a[cur] &gt; maxv) {
			maxv = i + a[cur];
			target = cur;
		}
	}
	up[x] = target;
	expose(loc1[target]);
	splay(loc1[x]);
	loc1[x]-&gt;pre = loc1[target];
}

void updateDown(int x) {
	if (down[x] != -1) {
		expose(loc2[down[x]]);
		splay(loc2[x]);
		loc2[x]-&gt;pre = null;
		down[x] = -1;
	}
	int maxv = 0, cur = x, target;
	for (int i = 1; i &lt;= a[x]; i ++) {
		cur = next[cur];
		if (cur == -1) return;
		if (i + a[cur] &gt; maxv) {
			maxv = i + a[cur];
			target = cur;
		}
	}
	down[x] = target;
	expose(loc2[target]);
	splay(loc2[x]);
	loc2[x]-&gt;pre = loc2[target];
}

void change(int x) {
	updateUp(x);
	updateDown(x);

	int cur = x;
	for (int i = 1; i &lt;= 20; i ++) {
		cur = next[cur];
		if (cur == -1) break;
		if (i &lt;= a[cur] &amp;&amp; up[cur] != -1) updateUp(cur);
	}
	cur = x;
	for (int i = 1; i &lt;= 20; i ++) {
		if (cur == top[cur]) break;
		cur = pre[cur][0];
		if (i &lt;= a[cur] &amp;&amp; down[cur] != -1) updateDown(cur);
	}
}

int main() {

	null = newSplayNode(-1);
	null-&gt;ch[0] = null-&gt;ch[1] = null-&gt;pre = null;
	null-&gt;size = 0;

	int n;
	scanf("%d", &amp;n);
	for (int i = 0; i &lt; n; i ++) scanf("%d", &amp;a[i]);
	for (int i = 0; i &lt; n; i ++) ge[i] = 0;
	for (int i = 0; i &lt; n - 1; i ++) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		a --;
		b --;
		insertEdge(a, b);
		insertEdge(b, a);
	}

	decompose(n);

	int m;
	scanf("%d", &amp;m);
	for (int i = 0; i &lt; m; i ++) {
		char ctrl[11];
		scanf("%s", ctrl);
		if (ctrl[0] == 'C') {
			int t, x;
			scanf("%d%d", &amp;t, &amp;x);
			t --;
			a[t] = x;
			change(t);
		} else {
			int s, t;
			scanf("%d%d", &amp;s, &amp;t);
			s --;
			t --;
			printf("%d\n", query(s, t));
		}
	}

	return 0;
}
</pre><pre></pre><h2>Problem3653</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;

using namespace std;

struct size
{
    int k,p;
};

int n,m;
int num=0,idx=0,t1,t2,t3,t4;
int fa[300010],dep[300010],que[300010],siz[300010],root[300010];
int left[6000010],right[6000010],c[6000010],next[600010],ref[600010];

int first[300010];

long long sum[6000010],ans[300010];

vector&lt;size&gt; q[300010];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline void add_edge(int u,int v)
{
	next[++num]=first[u];
	first[u]=num;
	ref[num]=v;
}

inline void getdepth()
{
	int head=1,tail=1;
	que[1]=1;
	dep[1]=1;
	fa[1]=0;

	while(head&lt;=tail)
	{
		int u=que[head++];
		for(int i=first[u];i;i=next[i])
		{
			int v=ref[i];
			if (v==fa[u])
                continue;
			que[++tail]=v;
			fa[v]=u;
			dep[v]=dep[u]+1;
		}
	}
}

inline void merge(int &amp;cur,int p,int l,int r)
{
	if(!p)
        return;
	if(!cur)
	{
	    cur=p;
        return;
    }

	if(l==r)
    {
        sum[cur]+=sum[p];
        return;
    }

	int m=(l+r)&gt;&gt;1;
	merge(left[cur],left[p],l,m);
	merge(right[cur],right[p],m+1,r);

	c[cur]=c[left[cur]]+c[right[cur]];
	sum[cur]=sum[left[cur]]+sum[right[cur]];
}

inline void update(int &amp;cur,int l,int r)
{
	if(!cur)
	{
	    cur=++idx;
	    left[cur]=0;
	    right[cur]=0;
	    c[cur]=0;
	    sum[cur]=0;
	}

	if(l==r)
    {
        c[cur]=1;
        sum[cur]+=t4;
        return;
    }

	int m=(l+r)&gt;&gt;1;
	if(t3&lt;=m)
        update(left[cur],l,m);
    else
        update(right[cur],m+1,r);

	c[cur]=c[left[cur]]+c[right[cur]];
	sum[cur]=sum[left[cur]]+sum[right[cur]];
}

inline long long query(int p,int l,int r)
{
	if(!p)
        return 0;

	if((t1&lt;=l)&amp;&amp;(r&lt;=t2))
        return sum[p];

	int m=(l+r)&gt;&gt;1;
	long long ret=0;
	if(t1&lt;=m)
        ret+=query(left[p],l,m);
	if(m&lt;t2)
        ret+=query(right[p],m+1,r);

	return ret;
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	num=0;

	for(int i=1;i&lt;n;i++)
	{
	    int u,v;
		scanf("%d%d",&amp;u,&amp;v);
		add_edge(u,v);
        add_edge(v,u);
	}

	getdepth();

	int maxdep=0;
	for(int i=1;i&lt;=n;i++)
        maxdep=max(maxdep,dep[i]);

	for(int i=1;i&lt;=n;i++)
        q[i].clear(),siz[i]=1;

	for(int i=n;i;i--)
        siz[fa[que[i]]]+=siz[que[i]];

	for(int i=1;i&lt;=m;i++)
	{
	    int x,y;
		scanf("%d%d",&amp;x,&amp;y);

		size t;
        t.k=y;
        t.p=i;
		q[x].push_back(t);
		if(dep[x]&gt;y)
            ans[i]=(long long)y*(siz[x]-1);
		else
            ans[i]=(long long)(dep[x]-1)*(siz[x]-1);
	}

	c[0]=0;
	sum[0]=0;

	for(int i=n;i;i--)
	{
	    int u,temp;
		u=que[i];
		root[u]=0;

		for(int j=first[u];j;j=next[j])
		{
			temp=ref[j];
			if(temp==fa[u])
                continue;

			if(c[root[temp]]&lt;c[root[u]])
                merge(root[u],root[temp],1,maxdep);
			else
            {
                merge(root[temp],root[u],1,maxdep);
                root[u]=root[temp];
            }

			t3=dep[temp];
			t4=siz[temp]-1;

			if(t4)
                update(root[u],1,maxdep);
		}

		int s=q[u].size();

		for(int j=0;j&lt;s;j++)
		{
			t1=dep[u]+1;
			t2=dep[u]+q[u][j].k;
			ans[q[u][j].p]+=query(root[u],1,maxdep);
		}
	}

	for(int i=1;i&lt;=m;i++)
        printf("%lld\n",ans[i]);

	return 0;
}
</pre><pre></pre><h2>Problem3661</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

const int K=804,N=1400004,M=5500004,oo=2000000000;

int n,m,k,l,T,num[K][K],d[N],q[N];
int E,first[N],cur[N],des[M],next[M],cap[M];
char s[K];

inline void addv(int u,int v,int c)
{
	next[++E]=first[u];
	first[u]=E; des[E]=v; cap[E]=c;
}
inline void add(int u,int v,int c)
{
    addv(u,v,c);
    addv(v,u,0);
}

inline bool augment(int u,int &amp;f)
{
	if (u==T) return true;
	for (int &amp;i=cur[u];i;i=next[i])
	{
		if ((d[u]+1!=d[des[i]])||(!cap[i])) continue;
		int ff=(cap[i]&lt;f)?cap[i]:f;
		if (augment(des[i],ff))
		{
			cap[i]-=ff; cap[((i-1)^1)+1]+=ff;
			f=ff; return true;
		}
	}
	return false;
}
inline bool dinic(int &amp;flow)
{
	int head=1,tail=1,i;
	for (i=1;i&lt;=T;i++) d[i]=0;
	q[1]=0; d[0]=1;
	while (head&lt;=tail)
	{
		int u=q[head++];
		for (i=first[u];i;i=next[i])
		{
			int v=des[i];
			if ((!cap[i])||(d[v])) continue;
			d[v]=d[u]+1;
			q[++tail]=v;
		}
	}
	if (!d[T]) return false;
	for (i=0;i&lt;=T;i++) cur[i]=first[i];
	int delta; while (augment(0,delta=oo)) flow+=delta;
	return true;
}
inline int maxflow()
{
	int flow=0;
	while (dinic(flow));
	return flow;
}

int main()
{
	int i,j;
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;l);
	T=0;
	for (i=1;i&lt;=n;i++)
	{
		scanf("%s",s);
		for(j=1;j&lt;=m;j++)
            num[j][i]=(s[j-1]-'0')?(++T):0;
	}
	E=0;
	for(i=0;i&lt;=T*2+2*m;i++)
        first[i]=0;
	int tot=T;
	for(i=1;i&lt;=T;i++)
        add(i*2-1,i*2,1);
	T*=2;
	add(0,T+1,k);
	for(i=1;i&lt;=n;i++)
        if(num[1][i])
            add(T+1,num[1][i]*2-1,1);

	for(i=1;i&lt;m;i++)
	{
		add(T+2*i,T+2*i+1,l);
		for (j=1;j&lt;=n;j++)
		{
			if(!num[i][j])continue;
			add(num[i][j]*2,T+2*i,1);
			if(num[i+1][j])add(num[i][j]*2,num[i+1][j]*2-1,1);
		}
		for (j=1;j&lt;=n;j++)
            if(num[i+1][j])
                add(T+2*i+1,num[i+1][j]*2-1,1);
	}

	T+=2*m;
	for(i=1;i&lt;=n;i++)
        if(num[m][i])
            add(num[m][i]*2,T,1);

	if(maxflow()==k)
	{
		for(i=1;i&lt;=tot;i++)
            d[i]=1-cap[i*2-1];
		for(i=1;i&lt;=m;i++)
		{
			int cnt=0;
			for (j=1;j&lt;=n;j++)
			{
				if(!num[i][j])continue;
				if(!d[num[i][j]])continue;
				printf("%d",j); cnt++;
				if(cnt==k)
                    putchar('\n');
                else
                    putchar(' ');
			}
		}
	}
	else
        printf("-1\n");

	return 0;
}
</pre><pre></pre><h2>Problem3662</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;

using namespace std;

char s[271][35]=
{"0",
"0",
"00",
"000",
"495",
"0000",
"6174",
"00000",
"000000",
"631764",
"549945",
"0000000",
"00000000",
"63317664",
"97508421",
"000000000",
"864197532",
"554999445",
"0000000000",
"6333176664",
"9753086421",
"9975084201",
"00000000000",
"86431976532",
"000000000000",
"633331766664",
"975330866421",
"997530864201",
"999750842001",
"555499994445",
"0000000000000",
"8643319766532",
"00000000000000",
"63333317666664",
"97533308666421",
"97755108844221",
"99753308664201",
"99975308642001",
"99997508420001",
"000000000000000",
"864333197666532",
"555549999944445",
"0000000000000000",
"6333333176666664",
"9753333086666421",
"9775531088644221",
"9975333086664201",
"9977551088442201",
"9997533086642001",
"9999753086420001",
"9999975084200001",
"00000000000000000",
"98765420987543211",
"86433331976666532",
"000000000000000000",
"633333331766666664",
"975333330866666421",
"977553310886644221",
"997533330866664201",
"997755310886442201",
"999753330866642001",
"999775510884422001",
"999975330866420001",
"999997530864200001",
"999999750842000001",
"886644219977553312",
"555554999999444445",
"0000000000000000000",
"9987654209875432101",
"9876543209876543211",
"8643333319766666532",
"00000000000000000000",
"63333333317666666664",
"97533333308666666421",
"97755333108866644221",
"97775551108884442221",
"99753333308666664201",
"99775533108866442201",
"99975333308666642001",
"99977553108864422001",
"99997533308666420001",
"99997755108844220001",
"99999753308664200001",
"99999975308642000001",
"99999997508420000001",
"88664432199776553312",
"000000000000000000000",
"999876542098754321001",
"998765432098765432101",
"987654332098766543211",
"864333333197666666532",
"555555499999994444445",
"0000000000000000000000",
"6333333333176666666664",
"9753333333086666666421",
"9775533331088666644221",
"9777555311088864442221",
"9975333333086666664201",
"9977553331088666442201",
"9977755511088844422201",
"9997533333086666642001",
"9997755331088664422001",
"9999753333086666420001",
"9999775531088644220001",
"9999975333086664200001",
"9999977551088442200001",
"9999997533086642000001",
"9999999753086420000001",
"9999999975084200000001",
"8866443321997766553312",
"00000000000000000000000",
"99998765420987543210001",
"99987654320987654321001",
"99876543320987665432101",
"98776554210988754432211",
"98765433320987666543211",
"86433333331976666666532",
"87765443219997765543222",
"000000000000000000000000",
"633333333331766666666664",
"975333333330866666666421",
"977553333310886666644221",
"977755533110888664442221",
"997533333330866666664201",
"997755333310886666442201",
"997775553110888644422201",
"999753333330866666642001",
"999775533310886664422001",
"999777555110888444222001",
"999975333330866666420001",
"999977553310886644220001",
"999997533330866664200001",
"999997755310886442200001",
"999999753330866642000001",
"999999775510884422000001",
"999999975330866420000001",
"999999997530864200000001",
"999999999750842000000001",
"886644333219977666553312",
"555555549999999944444445",
"0000000000000000000000000",
"9999987654209875432100001",
"9999876543209876543210001",
"9998765433209876654321001",
"9987765542109887544322101",
"9987654333209876665432101",
"9877655432109887654432211",
"9876543333209876666543211",
"8643333333319766666666532",
"00000000000000000000000000",
"63333333333317666666666664",
"97533333333308666666666421",
"97755333333108866666644221",
"97775553331108886664442221",
"97777555511108888444422221",
"99753333333308666666664201",
"99775533333108866666442201",
"99777555331108886644422201",
"99975333333308666666642001",
"99977553333108866664422001",
"99977755531108886444222001",
"99997533333308666666420001",
"99997755333108866644220001",
"99997775551108884442220001",
"99999753333308666664200001",
"99999775533108866442200001",
"99999975333308666642000001",
"99999977553108864422000001",
"99999997533308666420000001",
"99999997755108844220000001",
"99999999753308664200000001",
"99999999975308642000000001",
"99999999997508420000000001",
"98876654422099877554332111",
"88664433332199776666553312",
"000000000000000000000000000",
"999999876542098754321000001",
"999998765432098765432100001",
"999987654332098766543210001",
"999877655421098875443221001",
"999876543332098766654321001",
"998776554321098876544322101",
"998765433332098766665432101",
"987765543321098876654432211",
"987654333332098766666543211",
"864333333333197666666666532",
"888666444221999777555333112",
"555555554999999999444444445",
"0000000000000000000000000000",
"6333333333333176666666666664",
"9753333333333086666666666421",
"9775533333331088666666644221",
"9777555333311088866664442221",
"9777755553111088886444422221",
"9975333333333086666666664201",
"9977553333331088666666442201",
"9977755533311088866644422201",
"9977775555111088884444222201",
"9997533333333086666666642001",
"9997755333331088666664422001",
"9997775553311088866444222001",
"9999753333333086666666420001",
"9999775533331088666644220001",
"9999777555311088864442220001",
"9999975333333086666664200001",
"9999977553331088666442200001",
"9999977755511088844422200001",
"9999997533333086666642000001",
"9999997755331088664422000001",
"9999999753333086666420000001",
"9999999775531088644220000001",
"9999999975333086664200000001",
"9999999977551088442200000001",
"9999999997533086642000000001",
"9999999999753086420000000001",
"9999999999975084200000000001",
"9988766544220998775543321101",
"9887665443220998776554332111",
"8866443333321997766666553312",
"00000000000000000000000000000",
"99999998765420987543210000001",
"99999987654320987654321000001",
"99999876543320987665432100001",
"99998776554210988754432210001",
"99998765433320987666543210001",
"99987765543210988765443221001",
"99987654333320987666654321001",
"99877655433210988766544322101",
"99876543333320987666665432101",
"98777655542110988875444322211",
"98776554333210988766654432211",
"98765433333320987666666543211",
"86433333333331976666666666532",
"88866644432219997776555333112",
"000000000000000000000000000000",
"633333333333331766666666666664",
"975333333333330866666666666421",
"977553333333310886666666644221",
"977755533333110888666664442221",
"977775555331110888866444422221",
"997533333333330866666666664201",
"997755333333310886666666442201",
"997775553333110888666644422201",
"997777555531110888864444222201",
"999753333333330866666666642001",
"999775533333310886666664422001",
"999777555333110888666444222001",
"999777755551110888844442222001",
"999975333333330866666666420001",
"999977553333310886666644220001",
"999977755533110888664442220001",
"999997533333330866666664200001",
"999997755333310886666442200001",
"999997775553110888644422200001",
"999999753333330866666642000001",
"999999775533310886664422000001",
"999999777555110888444222000001",
"999999975333330866666420000001",
"999999977553310886644220000001",
"999999997533330866664200000001",
"999999997755310886442200000001",
"999999999753330866642000000001",
"999999999775510884422000000001",
"999999999975330866420000000001",
"999999999997530864200000000001",
"999999999999750842000000000001",
"999887665442209987755433211001",
"998876654432209987765543321101",
"988766544332209987766554332111",
"886644333333219977666666553312",
"555555555499999999994444444445"};

int n,m=270;

long long p;

int main()
{
	scanf("%d%lld",&amp;n,&amp;p);
	long long ans=0;
	for(int i=1;i&lt;=m;i++)
	{
		if(int(strlen(s[i]))!=n)continue;
		long long tmp=0;
		for (int j=0;j&lt;n;j++)
            tmp=(tmp*10+s[i][j]-'0')%p;
		ans=(ans+tmp*tmp)%p;
	}

	printf("%lld\n",ans);

	return 0;
}
</pre><pre></pre><h2>Problem3668</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,ans=0;
int b[35][5];

int main()
{
    //freopen("sleep.in","r",stdin);
    //freopen("sleep.out","w",stdout);

    scanf("%d%d",&amp;n,&amp;m);

    memset(b,0,sizeof(b));

    for(int i=1;i&lt;=n;i++)
    {
        int num;
        string str;

        cin&gt;&gt;str&gt;&gt;num;

        if(str=="OR")
        {
            for(int i=1;i&lt;=31;i++)
            {
                if((num&amp;1)==1)
                {
                    b[i][1]=1;
                    b[i][2]=1;
                }
                num/=2;
            }
        }

        if(str=="AND")
        {
            for(int i=1;i&lt;=31;i++)
            {
                if((num&amp;1)==0)
                {
                    b[i][1]=0;
                    b[i][2]=1;
                }
                num/=2;
            }
        }

        if(str=="XOR")
        {
            for(int i=1;i&lt;=31;i++)
            {
                b[i][1]^=(num&amp;1);
                if(b[i][2]==0)
                    b[i][2]=2;

                num/=2;
            }
        }
        /*
        for(int i=1;i&lt;=5;i++)
            printf("%d %d %d\n",i,b[i][1],b[i][2]);
        printf("*\n");

        printf("%d\n",num);
        */

    }

    for(int i=31;i;i--)
    {
        if(b[i][1]==1)
            ans+=(1&lt;&lt;(i-1));
        else
            if(b[i][2]==2||b[i][2]==0)
                if(m&gt;=(1&lt;&lt;(i-1)))
                {
                    m-=(1&lt;&lt;(i-1));
                    ans+=(1&lt;&lt;(i-1));
                }


        //printf("%d %d %d\n",i,b[i][1],b[i][2]);
    }

    printf("%d\n",ans);

    return 0;
}

/*
3 10
AND 5
OR 6
XOR 7

1 2560
AND 1000000000
*/
</pre><pre></pre><h2>Problem3668</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m;
char str[10];
int a[50],b[50];

int main()
{
  //    freopen("sleep.in","r",stdin);
  //    freopen("sleep.out","w",stdout);
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
    {
	int x;
	scanf("%s%d",str,&amp;x);
	if(str[0]=='A')
	{
	    for(int wei=0;wei&lt;=29;wei++)
	    {
		if(x%2==0)
		    a[wei]=1;
		x&gt;&gt;=1;
//		wei++;
	    }
	}
	else
	    if(str[0]=='O')
	    {
		for(int wei=0;wei&lt;=29;wei++)
		{
		    if(x&amp;1)a[wei]=2;
		    x&gt;&gt;=1;
//		    wei++;
		}
	    }
	    else
	    {
		for(int wei=0;wei&lt;=29;wei++)
		{
//		    printf("%d\n",x);
		    if(a[wei])
		    {
//			printf("%d\n",wei);
			if(a[wei]-1==(x&amp;1))
			    a[wei]=1;
			else
			    a[wei]=2;
		    }
		    else
			b[wei]^=(x&amp;1);
//		    wei++;
		    x&gt;&gt;=1;
		}
	    }
//	printf("%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]);
    }
    int ans=0;
    for(int i=29;i&gt;=0;i--)
    {
//	printf("%d %d %d\n",i,a[i],b[i]);
	if(a[i])
	{
	    if(a[i]==2)
		ans+=1&lt;&lt;i;
	}
	else
	{
	    if(b[i]==0&amp;&amp;(1&lt;&lt;i)&lt;=m)
	    {
		m-=(1&lt;&lt;i);
		ans+=(1&lt;&lt;i);
	    }
	    else
		if(b[i]==1)
		    ans+=1&lt;&lt;i;
	}
    }
    printf("%d\n",ans);
    
    return 0;
}
/*
3 10
AND 5
OR 6
XOR 7
*/
</pre><pre></pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1000000000;

struct size
{
    int t,len;
};

struct size1
{
    int x,y,a,b;
}edge[150000],edge1[150000];

int n,m,num,ans=inf;
int fa[50010],ch[50010];
int que[150010],dist[50010];
vector&lt;size&gt; g[50010];
bitset&lt;50010&gt; inque;

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline void merge(int x,int y)
{
    fa[find(x)]=find(y);
}

inline void add_edge(int x,int y,int z)
{
    ch[x]++;
    size temp;
    temp.t=y;
    temp.len=z;

    g[x].push_back(temp);

    ch[y]++;
    temp.t=x;

    g[y].push_back(temp);
}

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline bool cmp_dot(size1 a,size1 b)
{
    return (a.x&lt;b.x)||((a.x==b.x)&amp;&amp;(a.y&lt;b.y));
}

inline bool cmp_a(size1 a,size1 b)
{
    return (a.a&lt;b.a)||((a.a==b.a)&amp;&amp;(a.b&lt;b.b));
}

inline void spfa()
{
    inque.reset();
    for(int i=1;i&lt;=n;i++)
        dist[i]=inf;

    dist[1]=0;
    que[1]=1;
    int h=0,t=1;

    while(h!=t)
    {
        h=h%n+1;
        int x=que[h];
        inque.flip(x);

        for(int i=0;i&lt;ch[x];i++)
        {
            int child=g[x][i].t,len=g[x][i].len;

            if(max(dist[x],len)&lt;dist[child])
            {
                dist[child]=max(dist[x],len);

                if(!inque.test(child))
                {
                    t=t%n+1;
                    que[t]=child;
                    inque.set(child);
                }
            }
        }
    }
}

inline void spfa1(int x)
{
    inque.reset();

    que[1]=x;
    int h=0,t=1;

    while(h!=t)
    {
        h=h%n+1;
        int x=que[h];
        inque.flip(x);

        for(int i=0;i&lt;ch[x];i++)
        {
            int child=g[x][i].t,len=g[x][i].len;

            if(max(dist[x],len)&lt;dist[child])
            {
                dist[child]=max(dist[x],len);

                if(!inque.test(child))
                {
                    t=t%n+1;
                    que[t]=child;
                    inque.set(child);
                }
            }
        }
    }
}

int main()
{

    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=m;i++)
        scanf("%d%d%d%d",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].a,&amp;edge[i].b);

    sort(edge+1,edge+m+1,cmp_dot);

    edge[m+1].x=edge[m+1].y=0;

    int aa=0,bb=0;

    for(int i=1;i&lt;=m;i++)
    {
        edge1[++num].x=edge[i].x;
        edge1[num].y=edge[i].y;
        edge1[num].a=edge[i].a;
        edge1[num].b=edge[i].b;
    }

    sort(edge1+1,edge1+num+1,cmp_a);
    edge1[num+1].a=0;

    if(edge1[num].a&lt;=30)
    {
        for(int i=1;i&lt;=n;i++)
            fa[i]=i;

        for(int i=1;i&lt;=num;i++)
        {
            add_edge(edge1[i].x,edge1[i].y,edge1[i].b);
            merge(edge1[i].x,edge1[i].y);

            if(find(1)!=find(n))continue;

            if(edge1[i].a!=edge1[i+1].a)
            {
                //printf("%d\n",i);
                spfa();
                ans=min(ans,edge1[i].a+dist[n]);
                //printf("%d\n*\n",ans);
            }
        }
        if(find(1)!=find(n))
        {
            printf("-1\n");
            return 0;
        }
    }
    else
    {
        for(int i=1;i&lt;=n;i++)
        {
            fa[i]=i;
            dist[i]=inf;
        }
        dist[1]=0;

        for(int i=1;i&lt;=num;i++)
        {
            add_edge(edge1[i].x,edge1[i].y,edge1[i].b);
            merge(edge1[i].x,edge1[i].y);

            if(max(dist[edge1[i].x],edge1[i].b)&lt;dist[edge1[i].y])
            {
                dist[edge1[i].y]=max(dist[edge1[i].x],edge1[i].b);
                spfa1(edge1[i].y);
            }

            if(max(dist[edge1[i].y],edge1[i].b)&lt;dist[edge1[i].x])
            {
                dist[edge1[i].x]=max(dist[edge1[i].y],edge1[i].b);
                spfa1(edge1[i].x);
            }

            ans=min(ans,edge1[i].a+dist[n]);
            //printf("%d\n",ans);
        }
        if(find(1)!=find(n))
        {
            printf("-1\n");
            return 0;
        }
    }

    printf("%d\n",ans);

    return 0;
}
/*
4 5
1 2 19 1
2 3 8 12
2 4 12 15
1 3 17 8
3 4 1 17

3 1
1 2 1 1
*/
</pre><pre></pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;bitset&gt;

using namespace std;

const int inf=1000000000;

struct size
{
    int t,len;
};

struct size1
{
    int x,y,a,b;
}edge[150000],edge1[150000];

int n,m,num,ans=inf;
int fa[50010],ch[50010];
int que[150010],dist[50010];
vector&lt;size&gt; g[50010];
bitset&lt;50010&gt; inque;

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}

inline void merge(int x,int y)
{
    fa[find(x)]=find(y);
}

inline void add_edge(int x,int y,int z)
{
    ch[x]++;
    size temp;
    temp.t=y;
    temp.len=z;

    g[x].push_back(temp);

    ch[y]++;
    temp.t=x;

    g[y].push_back(temp);
}

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}

inline bool cmp_dot(size1 a,size1 b)
{
    return (a.x&lt;b.x)||((a.x==b.x)&amp;&amp;(a.y&lt;b.y));
}

inline bool cmp_a(size1 a,size1 b)
{
    return (a.a&lt;b.a)||((a.a==b.a)&amp;&amp;(a.b&lt;b.b));
}

inline void spfa(int x)
{
    inque.reset();

    que[1]=x;
    int h=0,t=1;

    while(h!=t)
    {
        h=h%n+1;
        int x=que[h];
        inque.flip(x);

        for(int i=0;i&lt;ch[x];i++)
        {
            int child=g[x][i].t,len=g[x][i].len;

            if(max(dist[x],len)&lt;dist[child])
            {
                dist[child]=max(dist[x],len);

                if(!inque.test(child))
                {
                    t=t%n+1;
                    que[t]=child;
                    inque.set(child);
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);

    for(int i=1;i&lt;=m;i++)
        scanf("%d%d%d%d",&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].a,&amp;edge[i].b);

    sort(edge+1,edge+m+1,cmp_dot);

    edge[m+1].x=edge[m+1].y=0;

    int aa=0,bb=0;

    for(int i=1;i&lt;=m;i++)
    {
        edge1[++num].x=edge[i].x;
        edge1[num].y=edge[i].y;
        edge1[num].a=edge[i].a;
        edge1[num].b=edge[i].b;
    }

    sort(edge1+1,edge1+num+1,cmp_a);
    edge1[num+1].a=0;

    for(int i=1;i&lt;=n;i++)
    {
        fa[i]=i;
        dist[i]=inf;
    }
    dist[1]=0;

    for(int i=1;i&lt;=num;i++)
    {
        add_edge(edge1[i].x,edge1[i].y,edge1[i].b);
        merge(edge1[i].x,edge1[i].y);
        if(max(dist[edge1[i].x],edge1[i].b)&lt;dist[edge1[i].y])
        {
            dist[edge1[i].y]=max(dist[edge1[i].x],edge1[i].b);
            spfa(edge1[i].y);
        }

        if(max(dist[edge1[i].y],edge1[i].b)&lt;dist[edge1[i].x])
        {
            dist[edge1[i].x]=max(dist[edge1[i].y],edge1[i].b);
            spfa(edge1[i].x);
        }
        ans=min(ans,edge1[i].a+dist[n]);
    }

    if(find(1)!=find(n))
        printf("-1\n");
    else
        printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int INF=1000000000;

int n,m,cnt,ans=INF;
int g[50010],dist[50010];
int q[50010],inq[50010];
struct edge1
{
    int x,y,a,b;
    inline friend bool operator&lt;(const edge1&amp;a,const edge1&amp;b)
	{
	    return a.a&lt;b.a||a.a==b.a&amp;&amp;a.b&lt;b.b;
	}
}E[100010];
struct edge
{
    int t,c,next;
}e[200010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

inline void spfa(int X)
{
    q[1]=X;
    inq[X]=1;
    int h=0,t=1;
    while(h!=t)
    {
	h=h%n+1;
	int x=q[h];
	inq[x]=0;
	for(int i=g[x];i;i=e[i].next)
	    if(Max(dist[x],e[i].c)&lt;dist[e[i].t])
	    {
		dist[e[i].t]=Max(dist[x],e[i].c);
		if(!inq[e[i].t])
		{
		    inq[e[i].t]=1;
		    t=t%n+1;
		    q[t]=e[i].t;
		}
	    }
    }
}

int main()
{
    //freopen("forest.in","r",stdin);
    //freopen("forest.out","w",stdout);

    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)
    {
	scanf("%d%d%d%d",&amp;E[i].x,&amp;E[i].y,&amp;E[i].a,&amp;E[i].b);
    }
    sort(E+1,E+m+1);
    for(int i=2;i&lt;=n;i++)
	dist[i]=INF;
    for(int i=1;i&lt;=m;i++)
    {
//	printf("%d %d %d %d\n",E[i].x,E[i].y,E[i].a,E[i].b);
	add_edge(E[i].x,E[i].y,E[i].b);
	add_edge(E[i].y,E[i].x,E[i].b);
	if(Max(dist[E[i].x],E[i].b)&lt;dist[E[i].y])
	{
	    dist[E[i].y]=Max(dist[E[i].x],E[i].b);
	    spfa(E[i].y);
	}
	if(Max(dist[E[i].y],E[i].b)&lt;dist[E[i].x])
	{
	    dist[E[i].x]=Max(dist[E[i].y],E[i].b);
	    spfa(E[i].x);
	}
//	printf("%d %d\n",E[i].a,dist[n]);
	ans=Min(ans,E[i].a+dist[n]);
    }
    if(ans==INF)
	printf("-1\n");
    else
	printf("%d\n",ans);
    return 0;
}
/*
4 5
1 2 19 1
2 3 8 12
2 4 12 15
1 3 17 8
3 4 1 17
*/
</pre><pre></pre><h2>Problem3670</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int P=1000000007;

int n,len;
int next[1000010],f[1000010],num[1000010];
char str[1000010];

inline void calcNext()
{
	next[0]=-1;
	f[0]=1;
	int j=-1;

	for(int i=1;i&lt;len;i++)
	{
		while(j!=-1&amp;&amp;str[i]!=str[j+1])
            j=next[j];

		if(str[j+1]==str[i])
		    next[i]=++j;
		else
			next[i]=j;

        f[i]=(j&gt;=0?f[j]:0)+1;
	}
}

inline void calcNum()
{
	int j=-1;

	for(int i=0;i&lt;len;i++)
	{
		while(j!=-1&amp;&amp;str[i]!=str[j+1])
            j=next[j];

		if(str[i]==str[j+1])
            ++j;

        while((j&lt;&lt;1)&gt;=i)
            j=next[j];

        num[i]=j&gt;=0?f[j]:0;
	}
}

inline int calcAns()
{
    long long temp=1;
    for(int i=0;i&lt;len;i++)
    {
        temp=(long long)temp*(num[i]+1);
        temp%=P;
    }

    temp%=P;
    while(temp&lt;0)temp+=P;
    temp%=P;

    return (int)temp;
}

int main()
{

    scanf("%d",&amp;n);

    for(;n;n--)
    {
        scanf("%s",str);

        len=strlen(str);

        calcNext();

        calcNum();

        printf("%d\n",calcAns());
    }

    return 0;
}
</pre><pre></pre><h2>Problem3671</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int x,a,b,c,d;
int n,m,q;
int t[25000010],f[25000010];
int minn[5010],maxx[5010];

int main()
{

    scanf("%d%d%d%d%d",&amp;x,&amp;a,&amp;b,&amp;c,&amp;d);
    scanf("%d%d%d",&amp;n,&amp;m,&amp;q);

    int sum=n*m,temp,u,v,tt;

    for(int i=1;i&lt;=sum;i++)
        t[i]=i;

    for(int i=1;i&lt;=sum;i++)
    {
        x=(((long long)a*x+b)*x+c)%d;

        u=i;
        v=x%i+1;

        tt=t[u];
        t[u]=t[v];
        t[v]=tt;
    }

    for(;q;q--)
    {
        scanf("%d%d",&amp;u,&amp;v);
        tt=t[u];
        t[u]=t[v];
        t[v]=tt;
    }

    int tot=n+m-1,num=0;

    for(int i=1;i&lt;=sum;i++)
        f[t[i]]=i;

    for(int i=1;i&lt;=m;i++)
    {
        minn[i]=1;
        maxx[i]=n;
    }

    int x,y;
    for(int i=1;i&lt;=sum;i++)
    {
        x=(int)((f[i]+m-1)/m);
        y=f[i]%m;
        if(y==0)y=m;

        if(x&gt;=minn[y]&amp;&amp;x&lt;=maxx[y])
        {
            num++;
            if(num==1)
                printf("%d",i);
            else
                printf(" %d",i);

            if(num==tot)
                break;

            for(temp=y-1;temp&gt;0;temp--)
                if(x&lt;maxx[temp])
                    maxx[temp]=x;
                else
                    break;

            for(temp=y+1;temp&lt;=m;temp++)
                if(x&gt;minn[temp])
                    minn[temp]=x;
                else
                    break;
        }
    }
    printf("\n");

    return 0;
}
/*
1 3 5 1 71
3 4 3
1 7
9 9
4 9

654321 209 111 23 70000001
10 10 0

123456 137 701 101 10000007
20 20 0
*/
</pre><pre></pre><h2>Problem3673</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,sz;
int root[200005],ls[7500005],rs[7500005],v[7500005],dep[7500005];

inline void build(int &amp;k,int l,int r)
{
	if(!k)k=++sz;
	if(l==r){v[k]=l;return;}
	int mid=(l+r)&gt;&gt;1;
	build(ls[k],l,mid);
	build(rs[k],mid+1,r);
}

inline void modify(int l,int r,int x,int &amp;y,int pos,int val)
{
	y=++sz;
	if(l==r){v[y]=val;return;}
	ls[y]=ls[x];rs[y]=rs[x];
	int mid=(l+r)&gt;&gt;1;
	if(pos&lt;=mid)
		modify(l,mid,ls[x],ls[y],pos,val);
	else modify(mid+1,r,rs[x],rs[y],pos,val);
}

inline int query(int k,int l,int r,int pos)
{
	if(l==r)return k;
	int mid=(l+r)&gt;&gt;1;
	if(pos&lt;=mid)return query(ls[k],l,mid,pos);
	else return query(rs[k],mid+1,r,pos);
}

inline void add(int k,int l,int r,int pos)
{
	if(l==r){dep[k]++;return;}
	int mid=(l+r)&gt;&gt;1;
	if(pos&lt;=mid)add(ls[k],l,mid,pos);
	else add(rs[k],mid+1,r,pos);
}

inline int find(int k,int x)
{
    int p=query(k,1,n,x);
	if(x==v[p])return p;
    return find(k,v[p]);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);

	build(root[0],1,n);
	int f,k,a,b;
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d",&amp;f);

		if(f==1)
		{
			root[i]=root[i-1];
			scanf("%d%d",&amp;a,&amp;b);
			int p=find(root[i],a),q=find(root[i],b);
			if(v[p]==v[q])continue;
			if(dep[p]&gt;dep[q])swap(p,q);
			modify(1,n,root[i-1],root[i],v[p],v[q]);
			if(dep[p]==dep[q])add(root[i],1,n,v[q]);
		}
		if(f==2)
		{scanf("%d",&amp;k);root[i]=root[k];}
		if(f==3)
		{
			root[i]=root[i-1];
			scanf("%d%d",&amp;a,&amp;b);
		    int p=find(root[i],a),q=find(root[i],b);
			printf("%d\n",v[p]==v[q]?1:0);
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem3674</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,sz,lastans;
int root[200005],ls[15000005],rs[15000005],v[15000005],dep[15000005];

inline void build(int &amp;k,int l,int r)
{
	if(!k)k=++sz;
	if(l==r){v[k]=l;return;}
	int mid=(l+r)&gt;&gt;1;
	build(ls[k],l,mid);
	build(rs[k],mid+1,r);
}

inline void modify(int l,int r,int x,int &amp;y,int pos,int val)
{
	y=++sz;
	if(l==r){v[y]=val;return;}
	ls[y]=ls[x];rs[y]=rs[x];
	int mid=(l+r)&gt;&gt;1;
	if(pos&lt;=mid)
		modify(l,mid,ls[x],ls[y],pos,val);
	else modify(mid+1,r,rs[x],rs[y],pos,val);
}

inline int query(int k,int l,int r,int pos)
{
	if(l==r)return k;
	int mid=(l+r)&gt;&gt;1;
	if(pos&lt;=mid)return query(ls[k],l,mid,pos);
	else return query(rs[k],mid+1,r,pos);
}

inline void add(int k,int l,int r,int pos)
{
	if(l==r){dep[k]++;return;}
	int mid=(l+r)&gt;&gt;1;
	if(pos&lt;=mid)add(ls[k],l,mid,pos);
	else add(rs[k],mid+1,r,pos);
}

inline int find(int k,int x)
{
    int p=query(k,1,n,x);
	if(x==v[p])return p;
    return find(k,v[p]);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);

	build(root[0],1,n);
	int f,k,a,b;
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%d",&amp;f);

		if(f==1)
		{
			root[i]=root[i-1];
			scanf("%d%d",&amp;a,&amp;b);
			a^=lastans;b^=lastans;
			int p=find(root[i],a),q=find(root[i],b);
			if(v[p]==v[q])continue;
			if(dep[p]&gt;dep[q])swap(p,q);
			modify(1,n,root[i-1],root[i],v[p],v[q]);
			if(dep[p]==dep[q])add(root[i],1,n,v[q]);
		}
		if(f==2)
		{scanf("%d",&amp;k);k=k^lastans;root[i]=root[k];}
		if(f==3)
		{
			root[i]=root[i-1];
			scanf("%d%d",&amp;a,&amp;b);a^=lastans;b^=lastans;
		    int p=find(root[i],a),q=find(root[i],b);
			printf("%d\n",lastans=v[p]==v[q]?1:0);
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem3680</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const double eps=0.00000001;
const double delt=0.98;

int n;
double x,y;

struct size
{
    double x,y;
    int w;
}dot[10010];

inline double f2(double x)
{
    return (double)x*x;
}

inline double calc(int k)
{
    return (double)sqrt(f2(dot[k].x-x)+f2(dot[k].y-y));
}

int main()
{
    scanf("%d",&amp;n);

    x=0.0;
    y=0.0;

    for(int i=1;i&lt;=n;i++)
    {
        scanf("%lf%lf%d",&amp;dot[i].x,&amp;dot[i].y,&amp;dot[i].w);
        x+=(double)dot[i].x*dot[i].w;
        y+=(double)dot[i].y*dot[i].w;
    }

    x/=(double)n;
    y/=(double)n;

    double P=1000.0;

    while(P&gt;eps)
    {
        double xx=0.0;
        double yy=0.0;

        for(int i=1;i&lt;=n;i++)
        {
            xx+=(double)(dot[i].x-x)*dot[i].w/calc(i);
            yy+=(double)(dot[i].y-y)*dot[i].w/calc(i);
        }

        x+=(double)xx*P;
        y+=(double)yy*P;
        P*=delt;
    }

    printf("%.3lf %.3lf\n",x,y);

    return 0;
}
</pre><pre></pre><h2>Problem3685</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m;

struct size
{
    int l,r,v;
}seg[4000000];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void build(int p,int l,int r)
{
    seg[p].l=l;
    seg[p].r=r;
    if(l==r)return;
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
}

inline void ins(int p,int v)
{
    if(seg[p].l==seg[p].r)
    {
        seg[p].v=1;
        return;
    }
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(v&lt;=mid)
        ins(p&lt;&lt;1,v);
    else
        ins(p&lt;&lt;1|1,v);
    seg[p].v=seg[p&lt;&lt;1].v+seg[p&lt;&lt;1|1].v;
}
inline void del(int p,int v)
{
    if(seg[p].l==seg[p].r)
    {
        seg[p].v=0;
        return;
    }
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(v&lt;=mid)
        del(p&lt;&lt;1,v);
    else
        del(p&lt;&lt;1|1,v);
    seg[p].v=seg[p&lt;&lt;1].v+seg[p&lt;&lt;1|1].v;
}

inline int find(int p,int v)
{
    if(!seg[p].v)return -1;
    if(seg[p].l==seg[p].r)return 1;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(v&lt;=mid)
        return find(p&lt;&lt;1,v);
    else
        return find(p&lt;&lt;1|1,v);
}

inline int fmax(int p)
{
    if(!seg[p].v)return -1;
    if(seg[p].l==seg[p].r)return seg[p].l;
    if(seg[p&lt;&lt;1|1].v)
        return fmax(p&lt;&lt;1|1);
    else
        return fmax(p&lt;&lt;1);
}
inline int fmin(int p)
{
    if(!seg[p].v)return -1;
    if(seg[p].l==seg[p].r)return seg[p].l;
    if(seg[p&lt;&lt;1].v)
        return fmin(p&lt;&lt;1);
    else
        return fmin(p&lt;&lt;1|1);
}

inline int pred(int p,int v)
{
    if(v&lt;0)return -1;
    if(!seg[p].v)return -1;
    if(seg[p].l==seg[p].r)return seg[p].l;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(v&lt;=mid)
        return pred(p&lt;&lt;1,v);
    else
    {
        int temp=pred(p&lt;&lt;1|1,v);
        if(temp==-1)
            return fmax(p&lt;&lt;1);
        else
            return temp;
    }
}
inline int succ(int p,int v)
{
    if(!seg[p].v)return -1;
    if(seg[p].l==seg[p].r)return seg[p].l;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(v&gt;mid)
        return succ(p&lt;&lt;1|1,v);
    else
    {
        int temp=succ(p&lt;&lt;1,v);
        if(temp==-1)
            return fmin(p&lt;&lt;1|1);
        else
            return temp;
    }
}

int main()
{
    n=read();
    m=read();
    build(1,0,n);

    for(;m;m--)
    {
        int opt=read();

        switch(opt)
        {
            case 1:opt=read();ins(1,opt);break;
            case 2:opt=read();del(1,opt);break;
            case 3:printf("%d\n",fmin(1));break;
            case 4:printf("%d\n",fmax(1));break;
            case 5:opt=read();printf("%d\n",pred(1,opt-1));break;
            case 6:opt=read();printf("%d\n",succ(1,opt+1));break;
            case 7:opt=read();printf("%d\n",find(1,opt));
        }
    }

    return 0;
}
</pre><pre></pre><h2>Problem3687</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

int n,sum,ans;
bitset&lt;2000001&gt;v;

int main()
{
    v[0]=1;
    for(scanf("%d",&amp;n);n;n--)
    {
        int x;
        scanf("%d",&amp;x);
        sum+=x;
        v^=(v&lt;&lt;x);
    }
    for(int i=1;i&lt;=sum;i++)
        if(v.test(i))
            ans^=i;
    printf("%d\n",ans);
    return 0;
}
</pre><pre></pre><h2>Problem3688</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

const int P=100007;

int n,k,maxy,ans=0;
int tr[100010];
int up[100010][12],down[100010][12];

struct size
{
    int x,y;
}dot[100010];

inline int lowbit(int x)
{
    return x&amp;-x;
}

inline int max(int x,int y)
{
    return x&gt;y?x:y;
}

inline bool cmp(size a,size b)
{
    return a.x&lt;b.x;
}

inline void add(int x)
{
    for(;x&lt;=maxy;x+=lowbit(x))
        tr[x]=(tr[x]+1)%P;
}

inline void upadd(int x,int k,int num)
{
    for(;x&lt;=maxy;x+=lowbit(x))
        up[x][k]=(up[x][k]+num)%P;
}

inline void downadd(int x,int k,int num)
{
    for(;x&lt;=maxy;x+=lowbit(x))
        down[x][k]=(down[x][k]+num)%P;
}

inline int calc(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp=(temp+tr[x])%P;
    return temp;
}

inline int upcalc(int x,int k)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp=(temp+up[x][k])%P;
    return temp;
}

inline int downcalc(int x,int k)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp=(temp+down[x][k])%P;
    return temp;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;k);

    for(int i=1;i&lt;=n;i++)
        scanf("%d%d",&amp;dot[i].x,&amp;dot[i].y),maxy=max(maxy,dot[i].y);

    sort(dot+1,dot+n+1,cmp);

    add(dot[1].y);

    for(int i=2;i&lt;=n;i++)
    {
        add(dot[i].y);
        int tempup=calc(dot[i].y-1)+upcalc(dot[i].y-1,1);
        int tempdown=calc(maxy)-calc(dot[i].y)+downcalc(maxy,1)-downcalc(dot[i].y,1);
        tempup%=P;
        tempdown%=P;
        upadd(dot[i].y,1,tempup);
        downadd(dot[i].y,1,tempdown);
        if(k==1)ans=(ans+tempup+tempdown)%P;

        for(int j=2;j&lt;=k;j++)
        {
            tempup=upcalc(dot[i].y-1,j)+downcalc(dot[i].y-1,j-1);
            tempdown=upcalc(maxy,j-1)-upcalc(dot[i].y,j-1)+downcalc(maxy,j)-downcalc(dot[i].y,j);
            tempup%=P;
            tempdown%=P;
            upadd(dot[i].y,j,tempup);
            downadd(dot[i].y,j,tempdown);

            if(j==k)ans=(ans+tempup+tempdown)%P;
        }
    }

    ans%=P;
    if(ans&lt;0)ans+=P;
    printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3689</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;

using namespace std;

int next[5000000][2];
int a[100010],b[1000010];
int end=0,root;
int n,k,cnt;
int t[35];

bool tag;

priority_queue&lt;int&gt; q;

inline int newnode()
{
    next[end][0]=next[end][1]=-1;
    return end++;
}

inline int newnode1()
{
    next[end][0]=-1;
    next[end][1]=0;
    return end++;
}

inline void init()
{
    end=0;
    root=newnode();
}

inline void insert(int s)
{
    int a[35];
    for(a[0]=1;a[0]&lt;=32;++a[0],s&gt;&gt;=1)a[a[0]]=s&amp;1;

    int u=root;
    for(int i=32;i;i--)
    {
        if(next[u][a[i]]==-1)
            if(i==1)
                next[u][a[i]]=newnode1();
            else
                next[u][a[i]]=newnode();

        u=next[u][a[i]];
        if(i==1)next[u][1]++;
    }
}

inline void dfs(int u,int p,int num)
{
    if(tag)return;

    if(p==0)
    {
        for(int i=1;i&lt;=next[u][1];i++)
            if(cnt&lt;k)
                q.push(num),cnt++;
            else
                if(num&lt;q.top())
                    q.pop(),q.push(num);
                else
                {
                    tag=true;
                    break;
                }
        return;
    }

    if(next[u][t[p]]!=-1)dfs(next[u][t[p]],p-1,num);

    if(next[u][t[p]^1]!=-1)dfs(next[u][t[p]^1],p-1,num|(1&lt;&lt;(p-1)));
}

inline int max(int a,int b)
{
	return a&gt;b?a:b;
}

int main()
{
    //freopen("xorit.in","r",stdin);
    //freopen("xorit.out","w",stdout);

	scanf("%d%d",&amp;n,&amp;k);

	for(int i=1;i&lt;=n;i++)
        scanf("%d",a+i);

	if(n&lt;=1000)
    {
        for(int i=1;i&lt;n;i++)
            for(int j=i+1;j&lt;=n;j++)
                b[++cnt]=a[i]^a[j];
        sort(b+1,b+cnt+1);
        printf("%d",b[1]);
        for(int i=2;i&lt;=k;i++)
            printf(" %d",b[i]);
        printf(" \n");
        return 0;
    }

	init();
	cnt=0;
	insert(a[1]);

	for(int i=2;i&lt;=n;i++)
    {
        int temp=a[i];
        for(t[0]=1;t[0]&lt;=32;++t[0],temp&gt;&gt;=1)t[t[0]]=temp&amp;1;
        tag=false;
        dfs(root,32,0);
        insert(a[i]);
    }

    for(int i=1;i&lt;=k;i++)b[i]=q.top(),q.pop();

    printf("%d",b[k]);
    for(int i=k-1;i;i--)
        printf(" %d",b[i]);
    printf(" \n");

	return 0;
}
/*
4 5
1
1
3
4
*/
</pre><pre></pre><h2>Problem3695</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

const double eps=0.000000001;

int n,x;
int h[110],v[110];

inline bool judge(double p)
{
    double sina=(double)p/(double)sqrt(p*p+h[1]*h[1]);

    for(int i=2;i&lt;=n;i++)
    {
        sina=(double)sina*v[i]/v[i-1];
        p+=(double)sina*h[i]*sqrt((double)1.0/(1.0-sina*sina));
        if(p&gt;(double)x)return true;
    }

    return false;
}

inline double calc(double p)
{
    double sina=p/(double)sqrt(p*p+h[1]*h[1]);
    double time=(double)sqrt(p*p+h[1]*h[1])/v[1];

    for(int i=2;i&lt;=n;i++)
    {
        sina=(double)sina*v[i]/v[i-1];
        p+=(double)sina*h[i]*sqrt((double)1.0/(1.0-sina*sina));
        time+=(double)h[i]*sqrt((double)1.0/(1.0-sina*sina))/v[i];
    }

    return time;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;x);

    for(int i=1;i&lt;=n;i++)
        scanf("%d",h+n+1-i);

    for(int i=1;i&lt;=n;i++)
        scanf("%d",v+n+1-i);

    double l=0.0,r=(double)x;

    while(l+eps&lt;r)
    {
        double mid=(double)(l+r)/2.0;

        if(judge(mid))
            r=mid;
        else
            l=mid;
    }

    printf("%.3lf\n",calc(l));

    return 0;
}
</pre><pre></pre><h2>Problem3696</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt;
int ans[600];
int g[100010],dep[100010];
int num[100010][510];
struct edge
{
    int t,next;
}e[100010];
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}

inline void dfs(int x)
{
    num[x][0]=1;
    for(int i=g[x];i;i=e[i].next)
    {
        dfs(e[i].t);
        for(int k1=0;k1&lt;=dep[x];k1++)
            for(int k2=0;k2&lt;=dep[e[i].t];k2++)
                ans[k1^(k2+1)]+=num[x][k1]*num[e[i].t][k2];

        dep[x]=Max(dep[x],dep[e[i].t]+1);
        for(int j=0;j&lt;=dep[e[i].t];j++)
            num[x][j+1]+=num[e[i].t][j];
    }
}

int main()
{
    n=read();
    for(int i=2;i&lt;=n;i++)
    {
        int fa=read();
        add_edge(fa,i);
    }
    dfs(1);

    int x=0;
    while(ans[x])
    {
        printf("%d\n",ans[x]);
        x++;
    }
    return 0;
}
</pre><pre></pre><h2>Problem3709</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;
long long z;
int cnt1,cnt2;
struct size
{
    int d,a,id;
}m1[100010],m2[100010];

inline bool cmp1(size a,size b)
{
    return a.d&lt;b.d;
}
inline bool cmp2(size a,size b)
{
    return a.a&gt;b.a;
}

int main()
{
    scanf("%d%lld",&amp;n,&amp;z);

    for(int i=1;i&lt;=n;i++)
    {
        int x,y;
        scanf("%d%d",&amp;x,&amp;y);
        if(x&lt;=y)
        {
            m1[++cnt1].d=x;
            m1[cnt1].a=y;
            m1[cnt1].id=i;
        }
        else
        {
            m2[++cnt2].d=x;
            m2[cnt2].a=y;
            m2[cnt2].id=i;
        }
    }
    sort(m1+1,m1+cnt1+1,cmp1);
    sort(m2+1,m2+cnt2+1,cmp2);

    bool dead=false;
    for(int i=1;i&lt;=cnt1;i++)
    {
        z-=m1[i].d;
        if(z&lt;=0)
        {
            dead=true;
            break;
        }
        z+=m1[i].a;
    }
    if(!dead)
    {
        for(int i=1;i&lt;=cnt2;i++)
        {
            z-=m2[i].d;
            if(z&lt;=0)
            {
                dead=true;
                break;
            }
            z+=m2[i].a;
        }
    }

    if(dead)
        printf("NIE\n");
    else
    {
        printf("TAK\n");
        for(int i=1;i&lt;=cnt1;i++)printf("%d ",m1[i].id);
        for(int i=1;i&lt;=cnt2;i++)printf("%d ",m2[i].id);
        printf("\n");
    }

    return 0;
}
</pre><pre></pre><h2>Problem3713</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int T,n;
int f[50];

int main()
{
    f[1]=0;
    f[2]=1;
    for(int i=3;i&lt;=45;i++)
        f[i]=f[i-1]+f[i-2];
    for(scanf("%d",&amp;T);T;T--)
    {
        scanf("%d",&amp;n);
        long long temp=n;
        bool flag=false;
        for(int i=1;i&lt;=45;i++)
        {
            for(int j=i;j&lt;=45;j++)
                if(temp==(long long)f[i]*f[j])
                {
                    flag=true;
                    break;
                }
            if(flag)break;
        }
        if(flag)
            printf("TAK\n");
        else
            printf("NIE\n");
    }
    return 0;
}
</pre><pre></pre><h2>Problem3715</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int t,n;
int a[100010],b[100010],c[100010],d[100010];

inline bool judge(int A,int B,int C,int D)
{
    for(int i=1;i&lt;=n;i++)
        if(a[i]==A&amp;&amp;b[i]==B&amp;&amp;c[i]==C&amp;&amp;d[i]==D)
            return true;
    return false;
}

int main()
{
    scanf("%d",&amp;t);
    while(t--)
    {
        scanf("%d",&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf("%d%d%d%d",a+i,b+i,c+i,d+i);
        if(judge(*min_element(a+1,a+n+1),*max_element(b+1,b+n+1),*min_element(c+1,c+n+1),*max_element(d+1,d+n+1)))
            printf("TAK\n");
        else
            printf("NIE\n");
    }
    return 0;
}
</pre><pre></pre><h2>Problem3728</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;

using namespace std;

int n,k;
int w[500010],p[500010],q[500010];
long long ans;
multiset&lt;int&gt;s;

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

inline bool cmp(const int&amp;a,const int&amp;b)
{
    return a&gt;b;
}

int main()
{
    n=read();k=read();
    for(int i=1;i&lt;=n;i++)
        s.insert(read());
    for(int i=1;i&lt;=n;i++)
        scanf("%d",w+i);
    sort(w+1,w+n+1,cmp);
    for(int i=1;i&lt;=n;i++)
    {
        multiset&lt;int&gt;::iterator it=s.lower_bound(w[i]);
        if(it!=s.end())
        {
            p[i]=*it;
            s.erase(it);
        }
        if(p[i]==0)
        {
            k--;
            p[i]=w[i];
        }
        ans+=(long long)p[i];
        q[i]=p[i]-w[i];
    }
    if(k&lt;0)
    {
        puts("NIE");
        return 0;
    }
    sort(q+1,q+n+1,cmp);
    for(int i=1;i&lt;=k;i++)
        ans-=q[i];
    printf("%lld\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3732</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,k,cnt;
int g[15010];
int f[15010],rank[15010];
int dep[15010];
int fa[15010][15],fas[15010][15];

struct edge
{
    int x,y,c;
    inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
    {
        return a.c&lt;b.c;
    }
}E[30010];
struct size
{
    int t,c,next;
}e[30010];

inline int max(int a,int b)
{
    return a&gt;b?a:b;
}

inline int find(int x)
{
    return f[x]=x==f[x]?x:find(f[x]);
}
inline void unio(int x,int y)
{
    int f1=find(x),f2=find(y);
    if(rank[f1]&lt;rank[f2])
        f[f1]=f2;
    else
    {
        f[f2]=f1;
        if(rank[f1]==rank[f2])rank[f2]++;
    }
}

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void kruskal()
{
    for(int i=1;i&lt;=n;i++)
        f[i]=i;
    sort(E+1,E+m+1);
    for(int i=1;i&lt;=m;i++)
        if(find(E[i].x)!=find(E[i].y))
        {
            add_edge(E[i].x,E[i].y,E[i].c);
            add_edge(E[i].y,E[i].x,E[i].c);
            unio(E[i].x,E[i].y);
        }
}

inline void dfs(int x)
{
    for(int i=1;i&lt;15;i++)
    {
        fa[x][i]=fa[fa[x][i-1]][i-1];
        fas[x][i]=max(fas[x][i-1],fas[fa[x][i-1]][i-1]);
    }
    for(int i=g[x];i;i=e[i].next)
        if(!fa[e[i].t][0])
        {
            dep[e[i].t]=dep[x]+1;
            fa[e[i].t][0]=x;
            fas[e[i].t][0]=e[i].c;
            dfs(e[i].t);
        }
}

inline void swim(int &amp;x,int h)
{
    for(int i=0;h;i++)
    {
        if(h&amp;1)x=fa[x][i];
        h&gt;&gt;=1;
    }
}
inline int lca(int x,int y)
{
    if(dep[x]&lt;dep[y])x^=y^=x^=y;
    swim(x,dep[x]-dep[y]);

    int i=14;
    while(x!=y)
    {
        for(;fa[x][i]==fa[y][i]&amp;&amp;i;i--);
        if(fa[x][i]==fa[y][i])return fa[x][i];
        x=fa[x][i];
        y=fa[y][i];
    }
    return x;
}
inline int calc(int x,int h)
{
    int temp=0;
    for(int i=0;h;i++)
    {
        if(h&amp;1)
        {
            temp=max(temp,fas[x][i]);
            x=fa[x][i];
        }
        h&gt;&gt;=1;
    }
    return temp;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
    for(int i=1;i&lt;=m;i++)
        scanf("%d%d%d",&amp;E[i].x,&amp;E[i].y,&amp;E[i].c);

    kruskal();

    fa[1][0]=1;
    fas[1][0]=0;
    dfs(1);

    for(;k;k--)
    {
        int x,y,z;
        scanf("%d%d",&amp;x,&amp;y);
        z=lca(x,y);
        printf("%d\n",max(calc(x,dep[x]-dep[z]),calc(y,dep[y]-dep[z])));
    }

    return 0;
}
</pre><pre></pre><h2>Problem3744</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;

using namespace std;

int n,num,N;
int S[230],T[230],bel[50010];
int a[50010],b[50010];
int tr[50010];
long long ans[230][230];
int les[230][50010],mor[230][50010];
map&lt;int,int&gt;h;

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline int lowbit(int x)
{
    return x&amp;-x;
}
inline void modify(int x,int val)
{
    for(;x&lt;=N;x+=lowbit(x))
        tr[x]+=val;
}
inline int query(int x)
{
    int temp=0;
    for(;x;x-=lowbit(x))
        temp+=tr[x];
    return temp;
}

inline void make_block()
{
    int temp=0;
    while(num*num&lt;n)num++;
    S[1]=1;
    bel[1]=1;
    for(int i=1;i&lt;=n;i++)
    {
        temp++;
        if(temp==num+1)
        {
            temp=1;
            bel[i]=1;
            T[bel[i-1]]=i-1;
            S[bel[i-1]+1]=i;
        }
        bel[i]+=bel[i-1];
    }
    T[bel[n]]=n;
}
inline void init()
{
    n=read();
    make_block();
    for(int i=1;i&lt;=n;i++)
    {
        a[i]=read();
        b[i]=a[i];
    }
    sort(b+1,b+n+1);
    int temp=0;
    for(int i=1;i&lt;=n;i++)
        if(b[i]!=b[i-1])
            h[b[i]]=++temp;
    for(int i=1;i&lt;=n;i++)
        a[i]=h[a[i]];
    N=temp;


    long long sum=0;
    for(int i=1;i&lt;=n;i++)
    {
        sum+=i-1-query(a[i]);
        modify(a[i],1);
        if(i==T[bel[i]])
        {
            ans[1][bel[i]]=sum;
            for(int j=1;j&lt;=N;j++)
            {
                les[bel[i]][j]=query(j-1);
                mor[bel[i]][j]=i-query(j);
            }
        }
    }

    for(int i=2;i&lt;=bel[n];i++)
    {
        sum=0;
        memset(tr,0,sizeof(tr));
        for(int j=S[i];j&lt;=n;j++)
        {
            sum+=j-S[i]-query(a[j]);
            modify(a[j],1);
            if(j==T[bel[j]])ans[i][bel[j]]=sum;
        }
    }
    memset(tr,0,sizeof(tr));
}

inline int calc(int l,int r)
{
    int temp=0;
    for(int i=l;i&lt;=r;i++)
    {
        temp+=i-l-query(a[i]);
        modify(a[i],1);
    }
    for(int i=l;i&lt;=r;i++)
        modify(a[i],-1);
    return temp;
}
inline int calc1(int M)
{
    int temp=0;
    for(int i=1;i&lt;=M;i++)
    {
        temp+=i-1-query(b[i]);
        modify(b[i],1);
    }
    for(int i=1;i&lt;=M;i++)
        modify(b[i],-1);
    return temp;
}

int main()
{
    init();

    long long lastans=0;
    for(int m=read();m;m--)
    {
        long long l,r;
        l=read();r=read();
        l^=lastans;r^=lastans;
        lastans=0;
        if(bel[l]+1&gt;=bel[r])
        {
            if(l==S[bel[l]]&amp;&amp;r==T[bel[r]])
                lastans=ans[bel[l]][bel[r]];
            else
                lastans=calc(l,r);
        }
        else
        {
            int A=bel[l],B=bel[l]+1,C=bel[r]-1,D=bel[r];
            int temp=0;
            if(l==S[A]&amp;&amp;r==T[D])
                lastans=ans[A][D];
            else
                if(l==S[A])
                {
                    lastans=ans[A][C];
                    for(int i=S[D];i&lt;=r;i++)
                    {
                        lastans+=mor[C][a[i]]-mor[A-1][a[i]];
                        b[++temp]=a[i];
                    }
                    lastans+=calc1(temp);
                }
                else
                    if(r==T[D])
                    {
                        lastans=ans[B][D];
                        for(int i=l;i&lt;=T[A];i++)
                        {
                            lastans+=les[D][a[i]]-les[A][a[i]];
                            b[++temp]=a[i];
                        }
                        lastans+=calc1(temp);
                    }
                    else
                    {
                        lastans=ans[B][C];
                        for(int i=l;i&lt;=T[A];i++)
                        {
                            lastans+=les[C][a[i]]-les[A][a[i]];
                            b[++temp]=a[i];
                        }
                        for(int i=S[D];i&lt;=r;i++)
                        {
                            lastans+=mor[C][a[i]]-mor[A][a[i]];
                            b[++temp]=a[i];
                        }
                        lastans+=calc1(temp);
                    }
        }
        printf("%lld\n",lastans);
    }

    return 0;
}
</pre><pre></pre><h2>Problem3750</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int T,n,m,a,b;
char str1[1010];
char str[1010][1010];

struct Vector
{
    int x,y;
    inline Vector():x(0),y(0){}
    inline Vector(const int&amp;A,const int&amp;B):x(A),y(B){}
    inline friend bool operator==(const Vector&amp;a,const Vector &amp;b)
    {
        return a.x==b.x&amp;&amp;a.y==b.y;
    }
};
const Vector C=Vector(0,0);
struct size
{
    int num;
    Vector S;
    Vector delt[1000010];
}Z;

inline bool check(int x,int y)
{
    return x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m;
}

int main()
{
    for(scanf("%d",&amp;T);T;T--)
    {
        bool flag=false;
        scanf("%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b);
        for(int i=1;i&lt;=n;i++)
        {
            scanf("%s",str[i]);
            for(int j=0;j&lt;m;j++)
                if(str[i][j]=='x'||flag)
                {
                    flag=true;
                    break;
                }
        }

        Z.S=C;
        Z.num=0;
        for(int i=1;i&lt;=a;i++)
        {
            scanf("%s",str1);
            for(int j=0;j&lt;b;j++)
                if(str1[j]=='x')
                {
                    if(Z.S==C)Z.S=Vector(i,j+1);
                    Z.delt[++Z.num]=Vector(i-Z.S.x,j+1-Z.S.y);
                }
        }

        if(!flag)
        {
            printf("TAK\n");
            continue;
        }
        if(Z.num==0)
        {
            printf("NIE\n");
            continue;
        }
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=0;j&lt;m;j++)
                if(str[i][j]=='x')
                {
                    for(int k=1;k&lt;=Z.num;k++)
                    {
                        int X=i+Z.delt[k].x,Y=j+Z.delt[k].y;
                        if(check(X,Y))
                            if(str[X][Y]=='x')
                            {
                                str[X][Y]='.';
                                continue;
                            }
                        flag=false;
                        break;
                    }
                    if(!flag)break;
                }
            if(!flag)break;
        }
        if(flag)
            printf("TAK\n");
        else
            printf("NIE\n");
    }
    return 0;
}</pre><pre></pre><h2>Problem3751</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

int n,m,np,cnt;
int prime[30];
int ans[20010];
long long res[110][30];
bool check1[20010],check2[20010];
struct number
{
    int len,sign;
    int digit[10010];
}a[110];
char tmps[10010];

inline void getnumber(number &amp;a)
{
    scanf("%s",tmps);
    int tmplen=strlen(tmps);
    a.sign=tmps[0]=='-'?-1:1;
    a.len=tmplen+(tmps[0]=='-'?-1:0);
    if(tmps[0]=='-')
        for(int j=1;j&lt;=tmplen-1;j++)
            a.digit[a.len+1-j]=tmps[j]-'0';
    else
        for(int j=0;j&lt;=tmplen-1;j++)
            a.digit[a.len-j]=tmps[j]-'0';
}

int main()
{
    prime[1]=100001029;
    prime[np=2]=100001053;
    int spprime=12071;
    int spprime2=8521;
    prime[np+1]=spprime;
    prime[np+2]=spprime2;
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=0;i&lt;=n;i++)getnumber(a[i]);
    for(int i=0;i&lt;=n;i++)
        for(int j=1;j&lt;=np+2;j++)
        {
            res[i][j]=0;
            for(int k=1;k&lt;=a[i].len;k++)
                res[i][j]=(10*res[i][j]+a[i].digit[a[i].len+1-k])%prime[j];
            res[i][j]=(res[i][j]*a[i].sign+prime[j])%prime[j];
        }

    for(int i=0;i&lt;spprime;i++)
    {
        long long tmp=0;
        for(int k=0;k&lt;=n;k++)
            tmp=(i*tmp+res[n-k][np+1])%prime[np+1];
        check1[i]=tmp==0;
    }
    for(int i=0;i&lt;spprime2;i++)
    {
        long long tmp=0;
        for(int k=0;k&lt;=n;k++)
            tmp=(i*tmp+res[n-k][np+2])%prime[np+2];
        check2[i]=tmp==0;
    }

    for(int i=1;i&lt;=m;i++)
    {
        if(!check1[i%spprime]||!check2[i%spprime2])continue;

        bool flag=true;
        for(int j=1;j&lt;=np;j++)
        {
            long long tmp=0;
            for(int k=0;k&lt;=n;k++)
                tmp=(i*tmp+res[n-k][j])%prime[j];
            if(tmp!=0)
            {
                flag=false;
                break;
            }
        }
        if(flag)ans[++cnt]=i;
    }

    printf("%d\n",cnt);
    for(int i=1;i&lt;=cnt;i++)
        printf("%d\n",ans[i]);

    return 0;
}
</pre><pre></pre><h2>Problem3754</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;

using namespace std;

const int INF=1000000000;

int n,m;
double ave,ans;
int fa[110],rnk[110];
inline double Abs(double x)
{
    return x&lt;0.0?-x:x;
}
inline double sqr(double x)
{
    return x*x;
}
struct edge
{
    int x,y,c,ch;
    inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
    {
        return Abs((double)ave-a.c)&lt;Abs((double)ave-b.c);
    }
}e[2010];

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}
inline void unio(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(rnk[fx]&lt;rnk[fy])
        fa[fx]=fy;
    else
    {
        fa[fy]=fx;
        if(rnk[fx]==rnk[fy])
            rnk[fx]++;
    }
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)
        scanf("%d%d%d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].c);
    ans=(double)INF;

    for(ave=0.0;ave&lt;=100.0;ave+=0.25)
    {
        sort(e+1,e+m+1);
        for(int i=1;i&lt;=n;i++)
        {
            fa[i]=i;
            rnk[i]=0;
        }
        double sum=0.0;
        for(int i=1;i&lt;=m;i++)
            if(find(e[i].x)!=find(e[i].y))
            {
                sum+=(double)e[i].c;
                unio(e[i].x,e[i].y);
                e[i].ch=1;
            }
            else
                e[i].ch=0;
        sum=(double)sum/(n-1);

        double ans1=0.0;
        for(int i=1;i&lt;=m;i++)
            if(e[i].ch)
                ans1+=(double)sqr((double)e[i].c-sum);
        ans1=(double)ans1/(n-1);
        ans1=sqrt(ans1);
        if(ans1&lt;ans)
            ans=ans1;
        //printf("%lf %lf\n",ave,ans1);
    }
    printf("%.4lf\n",ans);
    return 0;
}
/*
3 3
1 2 1
2 3 2
3 1 3
*/
</pre><pre></pre><h2>Problem3754</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;

using namespace std;

const int INF=1000000000;

int n,m;
double ave,ans;
int fa[110],rnk[110];
inline double Abs(double x)
{
    return x&lt;0.0?-x:x;
}
inline double sqr(double x)
{
    return x*x;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}
inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
struct edge
{
    int x,y,c,ch;
    inline friend bool operator&lt;(const edge&amp;a,const edge&amp;b)
    {
        return Abs((double)ave-a.c)&lt;Abs((double)ave-b.c);
    }
}e[2010];

inline int find(int x)
{
    return fa[x]=x==fa[x]?x:find(fa[x]);
}
inline void unio(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(rnk[fx]&lt;rnk[fy])
        fa[fx]=fy;
    else
    {
        fa[fy]=fx;
        if(rnk[fx]==rnk[fy])
            rnk[fx]++;
    }
}

int main()
{
    n=read();m=read();
    int mi=100,ma=0;
    for(int i=1;i&lt;=m;i++)
    {
        e[i].x=read();e[i].y=read();e[i].c=read();
        ma=Max(ma,e[i].c);
        mi=Min(mi,e[i].c);
    }
    ans=(double)INF;

    for(ave=mi;ave&lt;=ma;ave+=0.25)
    {
        sort(e+1,e+m+1);
        for(int i=1;i&lt;=n;i++)
        {
            fa[i]=i;
            rnk[i]=0;
        }
        double sum=0.0;
        for(int i=1;i&lt;=m;i++)
            if(find(e[i].x)!=find(e[i].y))
            {
                sum+=(double)e[i].c;
                unio(e[i].x,e[i].y);
                e[i].ch=1;
            }
            else
                e[i].ch=0;
        sum=(double)sum/(n-1);

        double ans1=0.0;
        for(int i=1;i&lt;=m;i++)
            if(e[i].ch)
                ans1+=(double)sqr((double)e[i].c-sum);
        ans1=(double)ans1/(n-1);
        ans1=sqrt(ans1);
        if(ans1&lt;ans)
            ans=ans1;
        //printf("%lf %lf\n",ave,ans1);
    }
    printf("%.4lf\n",ans);
    return 0;
}
/*
3 3
1 2 1
2 3 2
3 1 3
*/
</pre><pre></pre><h2>Problem3755</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

struct Vector
{
    int x,y;
    inline Vector():x(0),y(0){}
    inline Vector(const int&amp;a,const int &amp;b):x(a),y(b){}
    inline friend bool operator&gt;(const Vector&amp;a,const Vector&amp;b)
    {
        return a.y&gt;b.y||(a.y==b.y&amp;&amp;a.x&gt;b.x);
    }
    inline friend Vector operator-(const Vector&amp;a,const Vector&amp;b)
    {
        return Vector(a.x-b.x,a.y-b.y);
    }
    inline friend long long operator*(const Vector&amp;a,const Vector&amp;b)
    {
        return (long long)a.x*b.y-(long long)b.x*a.y;
    }
};
struct size
{
    Vector pos;
    int id;
    inline friend bool operator&gt;(const size&amp;a,const size&amp;b)
    {
        return a.pos&gt;b.pos;
    }
}a[200010],stk[200010],Ma;
struct seg_tree
{
    int l,r;
    Vector ma;
}seg[1000010];
int n;
int h[200010],num[200010];

inline Vector max(const Vector&amp;a,const Vector&amp;b)
{
    return a&gt;b?a:b;
}

inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r)
    {
        seg[p].ma=a[h[l]].pos;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
    seg[p].ma=max(seg[p&lt;&lt;1].ma,seg[p&lt;&lt;1|1].ma);
}
inline Vector query(int p,int l,int r)
{
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)return seg[p].ma;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        return query(p&lt;&lt;1,l,r);
    else
        if(l&gt;mid)
            return query(p&lt;&lt;1|1,l,r);
        else
            return max(query(p&lt;&lt;1,l,mid),query(p&lt;&lt;1|1,mid+1,r));
}

inline int solve(int x)
{
    int y=h[x];
    if(y&gt;x)
    {
        int l=1,r=y-x;
        while(l!=r)
        {
            int mid=(l+r)&gt;&gt;1;
            if(query(1,x+l,x+mid)&gt;a[h[x]].pos)
                r=mid;
            else
                l=mid+1;
        }
        if(num[x+l]!=0)return num[x+l]+l;
        else return (num[x+l]=solve(x+l))+l;
    }
    else
    {
        int l=1,r=x-y;
        while(l!=r)
        {
            int mid=(l+r)&gt;&gt;1;
            if(query(1,x-mid,x-l)&gt;a[h[x]].pos)
                r=mid;
            else
                l=mid+1;
        }
        if(num[x-l]!=0)return num[x-l]+l;
        else return (num[x-l]=solve(x-l))+l;
    }
}

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d%d",&amp;a[i].pos.x,&amp;a[i].pos.y);
        a[i].id=i;
        if(i==1)Ma=a[i];else Ma=Ma&gt;a[i]?Ma:a[i];
    }

    int t=1;
    stk[1]=a[1];
    h[1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        while(t&gt;0&amp;&amp;a[i].pos&gt;stk[t].pos)t--;
        while(t&gt;=2&amp;&amp;(stk[t].pos-stk[t-1].pos)*(a[i].pos-stk[t].pos)&gt;=0)t--;
        if(t)h[i]=stk[t].id;else h[i]=i;
        stk[++t]=a[i];
    }
    stk[t=1]=a[n];
    if(a[n].pos&gt;a[h[n]].pos)h[n]=n;
    for(int i=n-1;i;i--)
    {
        while(t&gt;0&amp;&amp;a[i].pos&gt;stk[t].pos)t--;
        while(t&gt;=2&amp;&amp;(stk[t].pos-stk[t-1].pos)*(a[i].pos-stk[t].pos)&lt;=0)t--;
        if(t)if(a[stk[t].id].pos&gt;a[h[i]].pos)h[i]=stk[t].id;
        stk[++t]=a[i];
    }

    build(1,1,n);
    num[Ma.id]=1;

    for(int i=1;i&lt;=n;i++)
        if(num[i]==0)
            num[i]=solve(i);

    for(int i=1;i&lt;=n;i++)
        printf("%d\n",num[i]-1);

    return 0;
}
</pre><pre></pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,cnt,itr,temp;
int a[100010],g[100010],S[100010],T[100010],dep[100010];
int vis[100010],Cnt[100010],ans[100010];
int pos[100010],dfn[100010];
int fa[100010][20];
int A[100010],B[100010];

struct queu
{
    int x,y,id;
    inline friend bool operator&lt;(const queu&amp;a,const queu&amp;b)
    {
        return pos[a.x]&lt;pos[b.x]||(pos[a.x]==pos[b.x]&amp;&amp;a.y&lt;b.y);
    }
}q[100010];
struct edge
{
    int t,next;
}e[100010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}

inline void dfs(int x)
{
    dfn[++itr]=x;
    S[x]=itr;
    for(int i=1;i&lt;=16;i++)
        fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int i=g[x];i;i=e[i].next)
        if(fa[x][0]!=e[i].t)
        {
            fa[e[i].t][0]=x;
            dep[e[i].t]=dep[x]+1;
            dfs(e[i].t);
        }
    dfn[++itr]=x;
    T[x]=itr;
}

inline void swim(int&amp;x,int h)
{
    for(int i=0;h;i++)
    {
        if(h&amp;1)x=fa[x][i];
        h&gt;&gt;=1;
    }
}
inline int lca(int x,int y)
{
    if(dep[x]&lt;dep[y])Swap(x,y);
    swim(x,dep[x]-dep[y]);
    while(x!=y)
    {
        int i;
        for(i=0;fa[x][i]!=fa[y][i];i++);
        if(i==0)return fa[x][0];
        x=fa[x][i-1];
        y=fa[y][i-1];
    }
    return x;
}

inline void trans(int x)
{
    int X=dfn[x];
    if(vis[X]==0)
    {
        vis[X]=1;
        Cnt[a[X]]++;
        if(Cnt[a[X]]==1)temp++;
    }
    else
    {
        vis[X]=0;
        Cnt[a[X]]--;
        if(Cnt[a[X]]==0)temp--;
    }
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read();
    for(int i=1;i&lt;=n;i++)
    {
        int x,y;
        x=read();y=read();
        add_edge(x,y);
        add_edge(y,x);
    }
    dep[0]=1;
    fa[0][0]=0;
    dfs(0);

    for(int i=1;i&lt;=m;i++)
    {
        int x,y;
        x=read();y=read();A[i]=read();B[i]=read();
        if(S[x]&gt;S[y])Swap(x,y);
        if(T[x]&gt;S[y])
            {q[i].x=S[x];q[i].y=S[y];}
        else
            {q[i].x=T[x];q[i].y=S[y];}
        q[i].id=i;
    }
    int limit=0;
    while(limit*limit&lt;(n&lt;&lt;1))limit++;
    for(int i=1;i&lt;=(n&lt;&lt;1);i++)
        pos[i]=i/limit;
    sort(q+1,q+m+1);

    int h=1,t=1;
    Cnt[0]=1;
    temp=1;
    vis[0]=1;
    for(int h=1,t=1,i=1;i&lt;=m;i++)
    {
        while(h&lt;q[i].x)trans(h++);
        while(h&gt;q[i].x)trans(--h);
        while(t&gt;q[i].y)trans(t--);
        while(t&lt;q[i].y)trans(++t);

        int z=lca(dfn[q[i].x],dfn[q[i].y]);
        if(z!=dfn[q[i].x])trans(S[z]);
            ans[q[i].id]=temp;
            if(Cnt[0])ans[q[i].id]--;
            if(A[q[i].id]!=B[q[i].id]&amp;&amp;Cnt[A[q[i].id]]&amp;&amp;Cnt[B[q[i].id]])ans[q[i].id]--;
        if(z!=dfn[q[i].x])trans(S[z]);
    }

    for(int i=1;i&lt;=m;i++)
        printf("%d\n",ans[i]);

    return 0;
}
</pre><pre></pre><h2>Problem3760</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=2000000007;

int n;
struct P
{
    int x,y;
}p[20010],p1[20010],p2[20010];

inline int min(int a,int b)
{
    return a&lt;b?a:b;
}
inline int max(int a,int b)
{
    return a&gt;b?a:b;
}
inline int abs(int x)
{
    return x&lt;0?-x:x;
}

inline bool check(int len)
{
    if(n==0)return true;
    int sd[4][4];
    sd[1][1]=inf;
    sd[1][2]=-inf;
    sd[2][1]=inf;
    sd[2][2]=-inf;
    for(int i=1;i&lt;=n;i++)
    {
        sd[1][1]=min(sd[1][1],p[i].x);
        sd[1][2]=max(sd[1][2],p[i].x);
        sd[2][1]=min(sd[2][1],p[i].y);
        sd[2][2]=max(sd[2][2],p[i].y);
    }
    for(int i=1;i&lt;=2;i++)
        for(int j=1;j&lt;=2;j++)
        {
            int m=0;
            for(int k=1;k&lt;=n;k++)
                if(abs(p[k].x-sd[1][i])&gt;len||abs(p[k].y-sd[2][j])&gt;len)
                    p1[++m]=p[k];
            if(m==0)return true;

            int sp[4][4];
            sp[1][1]=inf;
            sp[1][2]=-inf;
            sp[2][1]=inf;
            sp[2][2]=-inf;
            for(int k=1;k&lt;=m;k++)
            {
                sp[1][1]=min(sp[1][1],p1[k].x);
                sp[1][2]=max(sp[1][2],p1[k].x);
                sp[2][1]=min(sp[2][1],p1[k].y);
                sp[2][2]=max(sp[2][2],p1[k].y);
            }
            for(int ii=1;ii&lt;=2;ii++)
                for(int jj=1;jj&lt;=2;jj++)
                {
                    int s=0;
                    for(int kk=1;kk&lt;=m;kk++)
                        if(abs(p1[kk].x-sp[1][ii])&gt;len||abs(p1[kk].y-sp[2][jj])&gt;len)
                            p2[++s]=p1[kk];
                    if(s==0)return true;

                    int sq[4][4];
                    sq[1][1]=inf;
                    sq[1][2]=-inf;
                    sq[2][1]=inf;
                    sq[2][2]=-inf;
                    for(int kk=1;kk&lt;=s;kk++)
                    {
                        sq[1][1]=min(sq[1][1],p2[kk].x);
                        sq[1][2]=max(sq[1][2],p2[kk].x);
                        sq[2][1]=min(sq[2][1],p2[kk].y);
                        sq[2][2]=max(sq[2][2],p2[kk].y);
                    }
                    if(sq[2][2]-sq[2][1]&lt;=len&amp;&amp;sq[1][2]-sq[1][1]&lt;=len)
                        return true;
                }
        }
    return false;
}

int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf("%d%d",&amp;p[i].x,&amp;p[i].y);

    int l=0,r=2000000000,ans;
    while(l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(check(mid))
        {
            ans=mid;
            r=mid-1;
        }
        else
            l=mid+1;
    }
    printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3766</h2><pre>#include&lt;cstdio&gt;

using namespace std;

long long n;
long long f[20],S[20];

inline long long calc(long long N)
{
    int a[20];
    int ans=0;
    int s=1;

    for(long long i=1;i&lt;=N;i++)
    {
        long long temp=i;
        int num=0;
        while(temp)
        {
            a[++num]=temp%10;
            temp/=10;
        }
        for(int j=num;j;j--)
        {
            ans+=a[j]*s;
            s=-s;
        }
    }
    return ans;
}

inline int calc1(long long N,int s)
{
    int ans=0;
    int num=0;
    int a[20];
    while(N)
    {
        a[++num]=N%10;
        N/=10;
    }
    for(int j=num;j;j--)
    {
        ans+=a[j]*s;
        s=-s;
    }
    return ans;
}

inline long long calc2(long long N)
{
    if(n&lt;10)return calc(N);

    long long temp=N;
    int num=0;
    int a[20];
    while(temp)
    {
        a[++num]=temp%10;
        temp/=10;
    }

    temp=0;
    for(int i=num-1;i;i--)temp=temp*10+a[i];
    temp=temp+1;
    temp&gt;&gt;=1;
    if(!(n&amp;1))temp+=calc1(n,-1);
    long long ans=S[num-1]+temp;
    temp=1;
    for(int i=1;i&lt;num;i++)temp*=10;
    temp=((N/temp)-1)*temp/2;
    return ans+temp;
}
inline long long calc3(long long N)
{
    long long temp=N;
    int num=0;
    int a[20];
    while(temp)
    {
        a[++num]=temp%10;
        temp/=10;
    }

    long long ans=S[num-1];
    temp=1;
    for(int i=1;i&lt;num;i++)temp*=10;

    int B=1;
    long long temp2=10;
    while(temp2&lt;=N*10)
    {
        long long temp1=(N-temp)/temp2;
        ans+=(long long)B*temp1*45*(temp2/10);
        long long Num=N%temp2+1;
        long long temp3=temp2/10;
        for(int i=0;Num&gt;0;Num-=temp3,i++)
        {
            if(Num&gt;=temp3)
                ans+=(long long)B*temp3*i;
            else
                ans+=(long long)B*Num*i;
        }
        B*=-1;
        temp2*=10;
    }
    return ans;
}

int main()
{
    f[1]=5;
    f[2]=-45;
    for(int i=3;i&lt;=15;i++)
        f[i]=(long long)f[i-1]*(-10);
    for(int i=1;i&lt;=15;i++)
        S[i]=S[i-1]+f[i];

    for(scanf("%lld",&amp;n);n!=0;)
    {
        int num=0;
        int a[20];
        long long temp=n;
        while(temp)
        {
            ++num;
            temp/=10;
        }
        long long ans=0;

        if(num&amp;1)
            printf("%lld\n",calc2(n));
        else
            printf("%lld\n",calc3(n));

        scanf("%lld",&amp;n);
    }


    return 0;
}
</pre><pre></pre><h2>Problem3767</h2><pre>a=raw_input()
x,y=a.split(' ')
x,y=int(x),int(y)
print x+y</pre><pre></pre><h2>Problem3767</h2><pre>a,b=map(int,raw_input().split())
print(a+b)</pre><pre></pre><h2>Problem3769</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int P=1000000007;

int f[610][610];
bool v[610][610];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

int s(int i,int j)
{
	if(!i)return 1;
	if(!j)return i==1;
	if(v[i][j])return f[i][j];
	v[i][j]=true;

	for(int k=1;k&lt;=i;k++)
	{
		f[i][j]+=(long long)s(k-1,j-1)*s(i-k,j-1)%P;
		f[i][j]%=P;
	}
	return f[i][j];
}

int main()
{
	for(int T=read();T;T--)
	{
		int x,y;
		x=read();y=read();
		if(y)
            printf("%d\n",(s(x,y)-s(x,y-1)+P)%P);
        else
            printf("%d\n",x==1);
	}
	return 0;
}
</pre><pre></pre><h2>Problem3774</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int INF=1000000000;

int n,m,cnt=1;
int S,T,ans;
int c[55][55];
int g[5010];
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};

inline bool check(int x,int y)
{
    return x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=m;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

struct edge
{
    int t,c,next;
}e[1000010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

int vh[5010],his[5010],dis[5010],di[5010],pre[5010];
inline int isap()
{
    vh[0]=T;
    for(int i=1;i&lt;=T;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;
    while(dis[x]&lt;T)
    {
        bool flag=false;
        his[x]=aug;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                aug=Min(aug,e[i].c);
                di[x]=i;
                flag=true;
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;

        int mi=T,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];mii=i;
            }
        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    S=n*m*2+1;T=S+1;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            if(i+j&amp;1)
                add_edge(S,(i-1)*m+j,x);
            else
                add_edge((i-1)*m+j,T,x);
        }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();ans+=x;ans+=x;
            if(i+j&amp;1)
            {
                add_edge(S,(i-1)*m+j+n*m,x);
                add_edge((i-1)*m+j,T,x);
                add_edge((i-1)*m+j+n*m,(i-1)*m+j,INF);
                for(int k=0;k&lt;4;k++)
                    if(check(i+dx[k],j+dy[k]))
                        add_edge((i-1)*m+j+n*m,(i+dx[k]-1)*m+j+dy[k],INF);
            }
            else
            {
                add_edge((i-1)*m+j+n*m,T,x);
                add_edge(S,(i-1)*m+j,x);
                add_edge((i-1)*m+j,(i-1)*m+j+n*m,INF);
                for(int k=0;k&lt;4;k++)
                    if(check(i+dx[k],j+dy[k]))
                        add_edge((i+dx[k]-1)*m+j+dy[k],(i-1)*m+j+n*m,INF);
            }
        }
    printf("%d\n",ans-isap());
    return 0;
  }
</pre><pre></pre><h2>Problem3781</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,k;
int pos[50010],v[50010],cnt[50010];
long long temp;
long long ans[50010];

struct size
{
    int l,r,id;
    inline friend bool operator&lt;(const size&amp;a,const size&amp;b)
    {
        return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;a.r&lt;b.r);
    }
}q[50010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void modify(int x,int V)
{
    if(V&gt;0)
        temp+=cnt[v[x]]&lt;&lt;1|1;
    else
        temp-=cnt[v[x]]*2-1;
    cnt[v[x]]+=V;
}

int main()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
    int limit=0;
    while(limit*limit&lt;n)limit++;
    for(int i=1;i&lt;=n;i++)
    {
        v[i]=read();
        pos[i]=i/limit;
    }
    for(int i=1;i&lt;=m;i++)
    {
        q[i].l=read();
        q[i].r=read();
        q[i].id=i;
    }
    sort(q+1,q+m+1);

    int l=1,r=1;
    cnt[v[1]]=1;
    temp=1;
    for(int i=1;i&lt;=m;i++)
    {
        while(l&lt;q[i].l)modify(l++,-1);
        while(l&gt;q[i].l)modify(--l,1);
        while(r&gt;q[i].r)modify(r--,-1);
        while(r&lt;q[i].r)modify(++r,1);
        ans[q[i].id]=temp;
    }

    for(int i=1;i&lt;=m;i++)
        printf("%lld\n",ans[i]);
    return 0;
}
</pre><pre></pre><h2>Problem3784</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;cstring&gt;

using namespace std;

int n,cnt,K;
int sum,root,num;
int ans,Mi,Ma;
int g[50010],v[50010],siz[50010],f[50010],dist[50010];
int Ans[300010];
int cnt1,cnt2;
int num1[50010],num2[50010];
vector&lt;int&gt;v1[50010],v2[50010];
struct edge
{
    int t,c,next;
}e[100010];
struct Num
{
    int num;
    inline friend bool operator&lt;(const Num&amp;x,const Num&amp;y)
    {
        return x.num&gt;y.num;
    }
};
multiset&lt;Num&gt;s;

inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}
inline bool cmp(const int&amp;a,const int&amp;b)
{
    return a&gt;b;
}

inline void dfs(int x,int y,int fa)
{
    dist[++num]=y;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs(e[i].t,y+e[i].c,x);
}
inline void calc(int x,int dis,int tag)
{
    num=0;
    dfs(x,dis,0);
    sort(dist+1,dist+num+1);
    if(tag==0)
    {
        num1[++cnt1]=num;
        for(int i=1;i&lt;=num;i++)
            v1[cnt1].push_back(dist[i]);
        if(num&gt;=2)
        {
            Ma=Max(Ma,dist[num]+dist[num-1]);
            Mi=Min(Mi,dist[1]+dist[2]);
        }
    }
    else
    {
        num2[++cnt2]=num;
        for(int i=1;i&lt;=num;i++)
            v2[cnt2].push_back(dist[i]);
    }
}
inline void get_root(int x,int fa)
{
    siz[x]=1;f[x]=0;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
        {
            get_root(e[i].t,x);
            siz[x]+=siz[e[i].t];
            f[x]=Max(f[x],siz[e[i].t]);
        }
    f[x]=Max(f[x],sum-siz[x]);
    if(f[x]&lt;f[root])root=x;
}
inline void work(int x)
{
    v[x]=1;
    calc(x,0,0);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            calc(e[i].t,e[i].c,1);
            sum=num;root=0;
            get_root(e[i].t,0);
            work(root);
        }
}

inline void dfs1(int x,int y,int fa)
{
    if(y&gt;ans)Ans[++num]=y;
    for(multiset&lt;Num&gt;::iterator it=s.begin();it!=s.end();it++)
        if(y+it-&gt;num&gt;ans)
            Ans[++num]=y+it-&gt;num;
        else
            break;

    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs1(e[i].t,y+e[i].c,x);
}
inline void dfs2(int x,int fa)
{
    sum++;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            dfs2(e[i].t,x);
}
inline void add(int x,int y,int fa)
{
    Num a;a.num=y;
    s.insert(a);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t]&amp;&amp;e[i].t!=fa)
            add(e[i].t,y+e[i].c,x);
}
inline void calc1(int x)
{
    s.clear();
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            dfs1(e[i].t,e[i].c,x);
            add(e[i].t,e[i].c,x);
        }
}
inline void work1(int x)
{
    v[x]=1;
    calc1(x);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            sum=0;dfs2(e[i].t,x);
            root=0;
            get_root(e[i].t,0);
            work1(root);
        }
}

inline int check(int x)
{
    int temp=0;
    vector&lt;int&gt;::iterator it;
    for(int i=1;i&lt;=cnt1;i++)
    {
        it=v1[i].end();
        for(int k=1;k&lt;=num1[i];k++)
        {
            it--;
            int temp1=v1[i].end()-lower_bound(v1[i].begin(),v1[i].end(),x-*it);
            if(temp1==0)break;
            temp+=temp1;
        }
    }
    for(int i=1;i&lt;=cnt2;i++)
    {
        it=v2[i].end();
        for(int k=1;k&lt;=num2[i];k++)
        {
            it--;
            int temp1=v2[i].end()-lower_bound(v2[i].begin(),v2[i].end(),x-*it);
            if(temp1==0)break;
            temp-=temp1;
        }
    }
    return temp&gt;&gt;1;
}

int main()
{
    n=read();K=read();
    for(int i=1;i&lt;n;i++)
    {
        int x=read(),y,z;y=read();z=read();
        add_edge(x,y,z);
        add_edge(y,x,z);
    }

    Ma=0;Mi=1000000000;
    f[0]=n;sum=n;
    get_root(1,0);
    work(1);

    int L=Mi,R=Ma;
    while(L&lt;=R)
    {
        int mid=(L+R)&gt;&gt;1;
        if(check(mid)&gt;=K)
        {
            ans=mid;
            L=mid+1;
        }
        else
            R=mid-1;
    }

    f[0]=n;sum=n;
    get_root(1,0);
    num=0;
    memset(v,0,sizeof(v));
    work1(1);

    sort(Ans+1,Ans+num+1,cmp);
    for(int i=1;i&lt;=num;i++)
        printf("%d\n",Ans[i]);
    for(int i=num+1;i&lt;=K;i++)
        printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3809</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m;
int S[500],T[500];
int bel[100010],a[100010];
int cnt1[100010],cnt2[500];
int A[1000010],B[1000010],ans[1000010];
struct Query
{
    int l,r,id;
    inline friend bool operator&lt;(const Query&amp;x,const Query&amp;y)
    {
        return bel[x.l]&lt;bel[y.l]||bel[x.l]==bel[y.l]&amp;&amp;x.r&lt;y.r;
    }
}q[1000010];

inline int read()
{
    char c=getchar();
    int temp=0;
    while(c&lt;'0'||c&gt;'9')c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')
    {
        temp=temp*10+c-'0';
        c=getchar();
    }
    return temp;
}

inline void modify(int p,int v)
{
    p=a[p];
    if(cnt1[p]==0&amp;&amp;v==1)
        cnt2[bel[p]]++;
    else
        if(cnt1[p]==1&amp;&amp;v==-1)
            cnt2[bel[p]]--;
    cnt1[p]+=v;
}
inline int query(int l,int r)
{
    int temp=0;
    if(bel[l]==bel[r])
    {
        for(int i=l;i&lt;=r;i++)
            if(cnt1[i]!=0)
                temp++;
        return temp;
    }

    for(int i=l;i&lt;=T[bel[l]];i++)
        if(cnt1[i]!=0)
            temp++;
    for(int i=bel[l]+1;i&lt;bel[r];i++)
        temp+=cnt2[i];
    for(int i=S[bel[r]];i&lt;=r;i++)
        if(cnt1[i]!=0)
            temp++;
    return temp;
}

int main()
{
    n=read();m=read();
    int cnt1=0,cnt2=0,lim=0;
    while(lim*lim&lt;n)lim++;
    S[0]=1;
    for(int i=1;i&lt;=n;i++)
    {
        cnt1++;
        if(cnt1&gt;lim)
        {
            T[cnt2]=i-1;
            cnt1=0;
            cnt2++;
            S[cnt2]=i;
        }
        bel[i]=cnt2;

        a[i]=read();
    }

    for(int i=1;i&lt;=m;i++)
    {
        q[i].l=read();q[i].r=read();
        q[i].id=i;
        A[i]=read();B[i]=read();
    }
    sort(q+1,q+m+1);

    modify(1,1);
    for(int l=1,r=1,i=1;i&lt;=m;i++)
    {
        while(r&lt;q[i].r)modify(++r,1);
        while(r&gt;q[i].r)modify(r--,-1);
        while(l&lt;q[i].l)modify(l++,-1);
        while(l&gt;q[i].l)modify(--l,1);
        ans[q[i].id]=query(A[q[i].id],B[q[i].id]);
    }

    for(int i=1;i&lt;=m;i++)
        printf("%d\n",ans[i]);
    return 0;
}
</pre><pre></pre><h2>Problem3875</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,cnt,cnt1;
int g[200010],g1[200010];
long long s[200010],dist[200010];
int q[200010],inque[200010];
struct edge
{
    int t,next;
}e[1000010],e1[1000010];
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline void add_edge1(int x,int y)
{
    e1[++cnt1].t=y;
    e1[cnt1].next=g1[x];
    g1[x]=cnt1;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline long long Read()
{
    int c=getchar();
    long long temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

inline void spfa()
{
    for(int i=1;i&lt;=n;i++)
    {
        q[i]=i;
        inque[i]=1;
    }
    int h=0,t=n;

    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        inque[x]=0;

        long long temp=s[x];
        for(int i=g[x];i;i=e[i].next)
        {
            temp+=dist[e[i].t];
            if(temp&gt;=dist[x])break;
        }
        if(temp&lt;dist[x])
        {
            dist[x]=temp;
            for(int i=g1[x];i;i=e1[i].next)
            {
                if(!inque[e1[i].t])
                {
                    t=t%n+1;
                    q[t]=e1[i].t;
                    inque[e1[i].t]=1;
                }
            }
        }
    }
}

int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
    {
        s[i]=Read();dist[i]=Read();
        int x=read();
        for(;x;x--)
        {
            int y=read();
            add_edge(i,y);
            add_edge1(y,i);
        }
    }
    spfa();

    printf("%lld\n",dist[1]);

    return 0;
}
</pre><pre></pre><h2>Problem3876</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int INF=1000000000;
const int N=305;

int n,S,T,ans,cnt=1;
int g[310],in[310];
int dist[310],q[310],flow[310],inque[310],pre[310];
struct edge
{
    int t,c,cst,next;
}e[50010];
inline void add_edge(int x,int y,int z1,int z2)
{
    e[++cnt].t=y;
    e[cnt].c=z1;
    e[cnt].cst=z2;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].cst=-z2;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}

inline bool spfa()
{
    memset(dist,127,sizeof(dist));
    memset(flow,0,sizeof(flow));
    flow[S]=INF;
    dist[S]=0;
    q[1]=S;
    inque[S]=1;
    int h=0,t=1;

    while(h!=t)
    {
        h=h%N+1;
        int x=q[h];
        inque[x]=0;

        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dist[x]+e[i].cst&lt;dist[e[i].t])
            {
                flow[e[i].t]=Min(e[i].c,flow[x]);
                dist[e[i].t]=dist[x]+e[i].cst;
                pre[e[i].t]=i^1;

                if(!inque[e[i].t])
                {
                    inque[e[i].t]=1;
                    t=t%N+1;
                    q[t]=e[i].t;
                }
            }
    }
    return flow[T]!=0;
}

int main()
{
    n=read();S=n+1;T=n+2;

    for(int i=1;i&lt;=n;i++)
    {
        int x=read();
        in[i]-=x;
        for(;x;x--)
        {
            int b=read(),t;t=read();
            add_edge(i,b,INF,t);
            in[b]++;
            ans+=t;
        }
        if(i!=1)add_edge(i,1,INF,0);
    }

    for(int i=1;i&lt;=n;i++)
        if(in[i]&lt;0)
            add_edge(i,T,-in[i],0);
        else
            if(in[i]&gt;0)
                add_edge(S,i,in[i],0);

    while(spfa())
    {
        ans+=dist[T]*flow[T];
        int x=T;
        while(x!=S)
        {
            e[pre[x]].c+=flow[T];
            e[pre[x]^1].c-=flow[T];
            x=e[pre[x]].t;
        }
    }

    printf("%d\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3891</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;

using namespace std;

const int INF=1000000000;

int n,m,B,E,P,cnt;
int g[40010];
int q[40010],dist1[40010],dist2[40010],distn[40010];
bitset&lt;40010&gt;v;
struct edge
{
    int t,next;
}e[100010];
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline long long Min(const long long&amp;a,const long long&amp;b)
{
    return a&lt;b?a:b;
}

inline void spfa1()
{
    for(int i=1;i&lt;=n;i++)dist1[i]=INF;
    dist1[1]=0;
    q[1]=1;v[1]=1;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        v[x]=0;

        for(int i=g[x];i;i=e[i].next)
            if(dist1[x]+1&lt;dist1[e[i].t])
            {
                dist1[e[i].t]=dist1[x]+1;

                if(!v[e[i].t])
                {
                    v[e[i].t]=1;
                    t=t%n+1;
                    q[t]=e[i].t;
                }
            }
    }
}
inline void spfa2()
{
    for(int i=1;i&lt;=n;i++)dist2[i]=INF;
    dist2[2]=0;
    q[1]=2;v[2]=1;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        v[x]=0;

        for(int i=g[x];i;i=e[i].next)
            if(dist2[x]+1&lt;dist2[e[i].t])
            {
                dist2[e[i].t]=dist2[x]+1;

                if(!v[e[i].t])
                {
                    v[e[i].t]=1;
                    t=t%n+1;
                    q[t]=e[i].t;
                }
            }
    }
}
inline void spfan()
{
    for(int i=1;i&lt;=n;i++)distn[i]=INF;
    distn[n]=0;
    q[1]=n;v[n]=1;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        v[x]=0;

        for(int i=g[x];i;i=e[i].next)
            if(distn[x]+1&lt;distn[e[i].t])
            {
                distn[e[i].t]=distn[x]+1;

                if(!v[e[i].t])
                {
                    v[e[i].t]=1;
                    t=t%n+1;
                    q[t]=e[i].t;
                }
            }
    }
}

int main()
{
    B=read();E=read();P=read();n=read();m=read();
    for(int i=1;i&lt;=m;i++)
    {
        int x=read(),y=read();
        add_edge(x,y);add_edge(y,x);
    }

    spfa1();
    spfa2();
    spfan();

    long long ans=(long long)INF*INF;

    for(int i=1;i&lt;=n;i++)
    {
        long long temp=(long long)dist1[i]*B+(long long)dist2[i]*E+(long long)distn[i]*P;
        ans=Min(ans,temp);
    }
    printf("%lld\n",ans);

    return 0;
}
</pre><pre></pre><h2>Problem3892</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,K;
int x[510],y[510];
int f[510][510];
inline int read()
{
    int c=getchar(),temp=0,f=1;
    while((c&lt;48||c&gt;57)&amp;&amp;c!='-')c=getchar();
    if(c=='-'){f=-1;c=getchar();}
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp*f;
}
inline int Abs(const int&amp;x)
{
    return x&lt;0?-x:x;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}

int main()
{
    n=read();K=read();
    for(int i=1;i&lt;=n;i++)
    {
        x[i]=read();y[i]=read();
    }
    memset(f,127,sizeof(f));
    f[1][0]=0;

    for(int i=2;i&lt;=n;i++)
        for(int j=0;j&lt;i-1&amp;&amp;j&lt;=K;j++)
            for(int k=i-1;k&gt;=i-j-1&amp;&amp;k;k--)
                f[i][j]=Min(f[i][j],f[k][j-(i-k-1)]+Abs(x[i]-x[k])+Abs(y[i]-y[k]));

    int ans=1000000000;
    for(int i=0;i&lt;=K;i++)
        ans=Min(ans,f[n][i]);
    printf("%d\n",ans);

    return 0;
}</pre><pre></pre><h2>Problem3893</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,T;
int pos[100010],v[100010];
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;=48&amp;&amp;c&lt;=57)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int main()
{
    n=read();T=read();
    for(int i=1;i&lt;=n;i++)
    {
        pos[i]=read();v[i]=read();
    }

	int last=n,ans=1;
	for(int i=n-1;i;i--)
	{
		if((long long)pos[i]+(long long)v[i]*T&lt;(long long)pos[last]+(long long)v[last]*T)
        {
            ans++;
            last=i;
        }
	}
	printf("%d\n",ans);
	return 0;
}
</pre><pre></pre><h2>Problem3894</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int INF=1000000000;

int n,m,S,T,ans;
int dx[5]={0,0,1,0,-1};
int dy[5]={0,1,0,-1,0};

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline bool check(int x,int y)
{
    return x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=m;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

int cnt=1;
int g[30010];
struct edge
{
    int t,c,next;
}e[1000010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline void add_edge1(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=z;
    e[cnt].next=g[y];
    g[y]=cnt;
}

int vh[30010],dis[30010],pre[30010],his[30010],di[30010];
inline int isap()
{
    vh[0]=T;
    for(int i=1;i&lt;=T;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;
    while(dis[S]&lt;T)
    {
        his[x]=aug;
        bool flag=false;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                di[x]=i;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;

        int mi=T,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];mii=i;
            }
        dis[x]=mi+1;
        vh[dis[x]]++;
        di[x]=mii;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();m=read();
    S=n*m*3+1;T=S+1;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            add_edge(S,(i-1)*m+j,x);
            ans+=x;
        }//printf("*\n");
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            add_edge((i-1)*m+j,T,x);
            ans+=x;
        }//printf("*\n");
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            add_edge(S,(i-1)*m+j+n*m,x);
            ans+=x;
        }//printf("*\n");
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            add_edge((i-1)*m+j+n*m*2,T,x);
            ans+=x;
        }//printf("*\n");
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            for(int k=0;k&lt;5;k++)
                if(check(i+dx[k],j+dy[k]))
                {
                    add_edge((i+dx[k]-1)*m+j+dy[k]+n*m,(i-1)*m+j,INF);
                    add_edge((i-1)*m+j,(i+dx[k]-1)*m+j+dy[k]+n*m*2,INF);
                }
    printf("%d\n",ans-isap());
    return 0;
}
/*
3 4
13 2 4 13
7 13 8 12
18 17 0 5
8 13 15 4
11 3 8 11
11 18 6 5
1 2 3 4
4 2 3 2
3 1 0 4
3 2 3 2
0 2 2 1
0 2 4 4
*/
</pre><pre></pre><h2>Problem3894</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int INF=1000000000;

int n,m,S,T,ans;
int dx[5]={0,0,1,0,-1};
int dy[5]={0,1,0,-1,0};

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline bool check(int x,int y)
{
    return x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=m;
}
inline int Min(int a,int b)
{
    return a&lt;b?a:b;
}

int cnt=1;
int g[30010];
struct edge
{
    int t,c,next;
}e[1000010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

int vh[30010],dis[30010],pre[30010],his[30010],di[30010];
inline int isap()
{
    vh[0]=T;
    for(int i=1;i&lt;=T;i++)
        di[i]=g[i];
    int x=S,aug=INF,flow=0;
    while(dis[S]&lt;T)
    {
        his[x]=aug;
        bool flag=false;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                di[x]=i;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;

        int mi=T,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];mii=i;
            }
        dis[x]=mi+1;
        vh[dis[x]]++;
        di[x]=mii;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();m=read();
    S=n*m*3+1;T=S+1;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            add_edge(S,(i-1)*m+j,x);
            ans+=x;
        }//printf("*\n");
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            add_edge((i-1)*m+j,T,x);
            ans+=x;
        }//printf("*\n");
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            add_edge(S,(i-1)*m+j+n*m,x);
            ans+=x;
        }//printf("*\n");
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            int x=read();
            add_edge((i-1)*m+j+n*m*2,T,x);
            ans+=x;
        }//printf("*\n");
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            for(int k=0;k&lt;5;k++)
                if(check(i+dx[k],j+dy[k]))
                {
                    add_edge((i+dx[k]-1)*m+j+dy[k]+n*m,(i-1)*m+j,INF);
                    add_edge((i-1)*m+j,(i+dx[k]-1)*m+j+dy[k]+n*m*2,INF);
                }
    printf("%d\n",ans-isap());
    return 0;
}</pre><pre></pre><h2>Problem3907</h2><pre>def C(n,m):
    return fact[n]/fact[m]/fact[n-m];
f=raw_input().split(" ");
n=int(f[0]);
m=int(f[1]);
tot=max(n,m)*2;
fact=[1];
for i in range(1,tot+1):
    fact.append(fact[-1]*i);
c=n-m;
ans=C(tot-c,tot/2)-C(tot-c,tot/2+1);
print ans;</pre><pre></pre><h2>Problem3910</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,cnt,a;
int g[500010],f[500010],dep[500010];
int fa[500010][20];
long long ans=0;
struct edge
{
	int t,next;
}e[1000010];
inline void add_edge(int x,int y)
{
	e[++cnt].t=y;
	e[cnt].next=g[x];
	g[x]=cnt;
}

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}
inline void Swap(int&amp;x,int&amp;y)
{
	x^=y^=x^=y;
}


inline void dfs(int x)
{
	for(int i=1;i&lt;20;i++)
		fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=g[x];i;i=e[i].next)
		if(e[i].t!=fa[x][0])
		{
			dep[e[i].t]=dep[x]+1;
			fa[e[i].t][0]=x;
			dfs(e[i].t);
		}
}

inline void swim(int&amp;x,int h)
{
	for(int i=0;h;i++)
	{
		if(h&amp;1)x=fa[x][i];
		h&gt;&gt;=1;
	}
}
inline int lca(int x,int y)
{
	if(dep[x]&lt;dep[y])Swap(x,y);
	swim(x,dep[x]-dep[y]);
	if(x==y)return x;
	for(int i=19;i&gt;=0;i--)
		if(fa[x][i]!=fa[y][i])
		{
			x=fa[x][i];
			y=fa[y][i];
		}
	return fa[x][0];
}

inline int find(int x)
{
	return f[x]=x==f[x]?x:find(f[x]);
}
inline void unio(int x,int z)
{
	int fz=find(z);
	int fx=find(x);
	while(fx!=fz)
	{
		f[fx]=find(fa[fx][0]);
		fx=find(fa[fx][0]);
	}
}

int main()
{
	n=read();m=read();a=read();
	for(int i=1;i&lt;=n;i++)f[i]=i;
	for(int i=1;i&lt;n;i++)
	{
		int x=read(),y;y=read();
		add_edge(x,y);
		add_edge(y,x);
	}
	fa[1][0]=1;
	dfs(1);
	
	for(int i=1;i&lt;=m;i++)
	{
		int x=read();
		if(find(x)!=find(a))
		{
			int z=lca(x,a);
			ans+=dep[a]+dep[x]-(dep[z]&lt;&lt;1);
			unio(a,z);
			unio(x,z);
			a=x;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
			
		</pre><pre></pre><h2>Problem3916</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,u;
char str[2000010];
char s[3][1000010];

inline bool pairing(int x)
{
  for(int i=0,j=0,k=0;i&lt;n;)
    {
      if(str[i]!=s[x][j])
	if(k)
	  return false;
	else
	  {k++;i++;}
      else
	{i++;j++;}
      if(j==u)j=0;
    }
  return true;
}
inline bool judge(int x,int y)
{
  for(int i=0;i&lt;u;i++)
    if(s[x][i]!=s[y][i])
      return true;
  return false;
}

int main()
{
  scanf("%d",&amp;n);
  scanf("%s",str);
  if(!(n&amp;1)){printf("NOT POSSIBLE\n");return 0;}
  u=n&gt;&gt;1;
  for(int i=1;i&lt;=u;i++)
    s[0][i-1]=str[i];
  for(int i=0;i&lt;u;i++)
    s[1][i]=str[i];
  for(int i=1;i&lt;=u;i++)
    s[2][i-1]=str[i+u];

  int ans=0,ansi=0;
  for(int i=0;i&lt;3;i++)
    if(pairing(i))
      {
	ans++;
	if(ans&gt;1&amp;&amp;judge(ansi,i))
	  {
	    ans=10;
	    break;
	  }
	ansi=i;
      }

  if(ans==10)
    printf("NOT UNIQUE\n");
  else
    if(ans==0)
      printf("NOT POSSIBLE\n");
    else
      printf("%s\n",s[ansi]);
  return 0;
}
</pre><pre></pre><h2>Problem3922</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

int n,siz;
int a[70010],val[70010];
int root[70][70];
struct seg_tree
{
    int l,r,ls,rs,v;
}seg[20000000];
inline int read()
{
    int c=getchar(),temp=0,f=1;
    while((c&lt;48||c&gt;57)&amp;&amp;c!='-')c=getchar();
    if(c=='-'){f=-1;c=getchar();}
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+(c-48);
        c=getchar();
    }
    return temp*f;
}
inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}

inline void build(int&amp;p,int l,int r)
{
    p=++siz;
    seg[p].l=l;seg[p].r=r;
    if(l==r)
    {
        seg[p].v=val[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(seg[p].ls,l,mid);
    build(seg[p].rs,mid+1,r);
    seg[p].v=Max(seg[seg[p].ls].v,seg[seg[p].rs].v);
}
inline void modify(int p,int pos,int val)
{
    if(seg[p].l==seg[p].r)
    {
        seg[p].v=val;
        return;
    }
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(pos&lt;=mid)
        modify(seg[p].ls,pos,val);
    else
        modify(seg[p].rs,pos,val);
    seg[p].v=Max(seg[seg[p].ls].v,seg[seg[p].rs].v);
}
inline int query(int p,int pos)
{
    if(pos&lt;=seg[p].l)return seg[p].v;
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(pos&lt;=mid)
        return Max(query(seg[p].ls,pos),query(seg[p].rs,pos));
    else
        return query(seg[p].rs,pos);
}

int main()
{
    n=read();
    int limit=1;
    if(n&gt;35)while((double)7*limit*limit*(log2(n)-log2(limit))&lt;n)limit++;
    else limit=0;
    for(int i=1;i&lt;=n;i++)a[i]=read();
    for(int i=1;i&lt;=limit;i++)
    {
        for(int j=1;j&lt;=i;j++)
        {
            int num=0;
            for(int k=j;k&lt;=n;k+=i)
                val[++num]=a[k];
            build(root[j][i],1,num);
        }
    }

    for(int m=read();m;m--)
    {
        int op=read();
        if(op==0)
        {
            int p=read(),v;v=read();
            a[p]+=v;
            for(int i=1;i&lt;=limit;i++)
            {
                int s=p-(int)(p/i)*i;
                if(s==0)s=i;
                modify(root[s][i],(p-s)/i+1,a[p]);
            }
        }
        else
        {
            int x0=read(),d;d=read();

            if(d&lt;=limit)
            {
                int s=x0-(int)(x0/d)*d;
                if(s==0)s=d;
                printf("%d\n",query(root[s][d],(x0-s)/d+1));
            }
            else
            {
                int ans=a[x0];
                for(int i=x0+d;i&lt;=n;i+=d)
                    ans=Max(ans,a[i]);
                printf("%d\n",ans);
            }
        }
    }

    return 0;
}
</pre><pre></pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;

using namespace std;

inline int read()
{
    int c=getchar(),temp=0,f=1;
    while((c&lt;48||c&gt;57)&amp;&amp;c!='-')c=getchar();
    if(c=='-'){f=-1;c=getchar();}
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp*f;
}

const int MAX_N = int(1e5) + 10;

struct Edge
{
	int t,c;
	inline Edge(int t, int c):t(t),c(c){}
};

int n,Q;
vector&lt;Edge&gt;E[MAX_N];

void addEdge(int u,int v,int c)
{
	E[u].push_back(Edge(v,c));
	E[v].push_back(Edge(u,c));
}

struct Data
{
	int cnt;
	long long distSum;

	inline Data(int cnt,long long distSum):cnt(cnt),distSum(distSum){}
	inline Data(){cnt=0;distSum=0;}
	inline void add(int c,int d)
	{
		cnt+=c;
		distSum+=1LL*c*d;
	}
	inline Data&amp;operator+=(Data o)
	{
		cnt+=o.cnt;
		distSum+=o.distSum;
		return *this;
	}
	inline Data&amp;operator-=(Data o)
	{
		cnt-=o.cnt;
		distSum-=o.distSum;
		return *this;
	}
	inline Data operator+(Data o)
	{
		Data ret=*this;
		return ret+=o;
	}
	inline Data operator-(Data o)
	{
		Data ret=*this;
		return ret-=o;
	}

	inline Data update(int d)
	{
		Data o=*this;
		o.distSum+=1LL*cnt*d;
		return o;
	}
};

struct Split
{
	vector&lt;Data&gt; branchData;
	vector&lt;Split*&gt; branch;
	vector&lt;Edge&gt; branchLink;
	Data all;

	inline void add(int idx, Data d)
	{
		branchData[idx]+=d;
		all+=d;
	}
};

Split split[MAX_N];

struct SplitPtr
{
	Split*sp;
	int idx;
	int dist;
	int level;

	inline SplitPtr(Split*sp,int idx,int dist,int level):sp(sp),idx(idx),dist(dist),level(level){}

	inline void attach(Data o)
	{
		sp-&gt;add(idx,o.update(dist));
	}
};

vector&lt;SplitPtr&gt;my[MAX_N];

int que[MAX_N],qh,qt;
int size[MAX_N];

bool deleted[MAX_N];
int father[MAX_N], branch[MAX_N], dist[MAX_N];

inline void addSplitPtr(Split*sp,int u,int idx,int dist)
{
	int level=my[u].size();
	my[u].push_back(SplitPtr(sp,idx,dist,level));
}

inline void bfs(int rt)
{
	qh=qt=0;
	que[qt++]=rt;
	father[rt]=-1;

	while(qh&lt;qt)
    {
		int u=que[qh++];
		for(vector&lt;Edge&gt;::iterator e=E[u].begin();e!=E[u].end();++e)
			if(!deleted[e-&gt;t]&amp;&amp;e-&gt;t!=father[u])
			{
				que[qt++]=e-&gt;t;
				father[e-&gt;t]=u;
			}
	}
}

Split*root;

inline Split* build(int rt)
{
	bfs(rt);

	for (int i=qt-1;i&gt;=0;--i)
    {
		int u=que[i];
		size[u]=1;
		for (vector&lt;Edge&gt;::iterator e=E[u].begin();e!=E[u].end();++e)
            if(!deleted[e-&gt;t]&amp;&amp;e-&gt;t!=father[u])
                size[u]+=size[e-&gt;t];
	}

	int min_opt=MAX_N;
	int by=-1;

	for(int i=0;i&lt;qt;++i)
    {
		int u=que[i];
		int opt=qt-size[u];

		for(vector&lt;Edge&gt;::iterator e=E[u].begin();e!= E[u].end();++e)
            if(!deleted[e-&gt;t]&amp;&amp;e-&gt;t!=father[u])
                opt=max(opt,size[e-&gt;t]);

		if (opt&lt;min_opt)
        {
			min_opt=opt;
			by=u;
		}
	}

	rt=by;
	bfs(rt);

	int nBranch=0;

	for(vector&lt;Edge&gt;::iterator e=E[rt].begin();e!=E[rt].end();++e)
        if (!deleted[e-&gt;t])
			branch[e-&gt;t]=nBranch++;

	branch[rt]=nBranch++;

	Split&amp;sp=split[rt];
	sp.branchData.resize(nBranch);
	dist[rt]=0;

	for (int i=0;i&lt;qt;++i)
	{
		int u=que[i];
		if(father[u]!=-1&amp;&amp;father[u]!=rt)
            branch[u] = branch[father[u]];

		for(vector&lt;Edge&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e)
            if(!deleted[e-&gt;t] &amp;&amp; e-&gt;t != father[u])
                dist[e-&gt;t] = dist[u] + e-&gt;c;

		addSplitPtr(&amp;sp, u, branch[u], dist[u]);
	}

	deleted[rt]=true;

	for(vector&lt;Edge&gt;::iterator e = E[rt].begin(); e != E[rt].end(); ++e)
    {
		if(!deleted[e-&gt;t])
		{
			sp.branch.push_back(build(e-&gt;t));
			sp.branchLink.push_back(*e);
		}
	}

	return &amp;sp;
}

inline void attachArmy(int u, Data d)
{
	for(vector&lt;SplitPtr&gt;::iterator e = my[u].begin(); e != my[u].end(); ++e)
		e-&gt;attach(d);
}

inline long long evaluate(Split*cur)
{
	int tot = cur-&gt;all.cnt;

	for (int i = 0; i &lt; cur-&gt;branch.size(); ++i)
    {
		int sz = cur-&gt;branchData[i].cnt;
		if (sz * 2 &gt; tot)
		{
			Data other = cur-&gt;all;
			other -= cur-&gt;branchData[i];
			Edge e = cur-&gt;branchLink[i];
			other = other.update(e.c);
			attachArmy(e.t, other);
			long long ans = evaluate(cur-&gt;branch[i]);
			attachArmy(e.t, Data() - other);
			return ans;
		}
	}

	return cur-&gt;all.distSum;
}

int main()
{
	n=read();Q=read();
	for (int i = 0; i &lt; n - 1; ++i)
    {
		int a, b, c;
		a=read()-1;b=read()-1;c=read();
		addEdge(a, b, c);
	}

	root = build(0);

	while (Q--)
    {
		int u, add;
		u=read()-1;add=read();
		attachArmy(u, Data(add, 0));
		printf("%lld\n", evaluate(root));
	}
	return 0;
}
</pre><pre></pre><h2>Problem3931</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;
const long long INF=(long long)inf*inf;

int n,m,cnt,cnt1,S,T;
int g[1010],g1[1010];
int pre[1010],dis[1010],di[1010],vh[1010];
long long his[1010];
int dist[1010],q[1010],inq[1010];

inline long long Min(const long long&amp;a,const long long&amp;b)
{
    return a&lt;b?a:b;
}
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

struct edge
{
    int t,next;
    long long c;
}e[200010];
struct edge1
{
    int t,c,next;
}E[200010];
inline void add_edge1(int x,int y,int z)
{
    E[++cnt].t=y;
    E[cnt].c=z;
    E[cnt].next=g1[x];
    g1[x]=cnt;
}
inline void add_edge(int x,int y,long long z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}

inline void spfa()
{
    for(int i=1;i&lt;=n;i++)dist[i]=inf;
    dist[1]=0;
    q[1]=1;
    inq[1]=1;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        inq[x]=false;
        for(int i=g1[x];i;i=E[i].next)
            if(dist[x]+E[i].c&lt;dist[E[i].t])
            {
                dist[E[i].t]=dist[x]+E[i].c;

                if(!inq[E[i].t])
                {
                    t=t%n+1;
                    inq[E[i].t]=true;
                    q[t]=E[i].t;
                }
            }
    }
}

inline long long isap()
{
    vh[0]=T;
    for(int i=1;i&lt;=T;i++)di[i]=g[i];
    int x=S;
    long long aug=INF,flow=0;
    while(dis[S]&lt;T)
    {
        bool flag=false;
        his[x]=aug;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                flag=true;
                di[x]=i;
                aug=Min(aug,e[i].c);
                pre[e[i].t]=i^1;
                x=e[i].t;

                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(vh[dis[x]]==0)break;

        int mi=T,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }
        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=m;i++)
    {
        int x=read(),y,z;y=read();z=read();
        add_edge1(x,y,z);
        add_edge1(y,x,z);
    }
    spfa();
    cnt=1;
    for(int i=1;i&lt;=n;i++)
    {
        int x=read();
        if(i==1||i==n)
            add_edge(i*2-1,i*2,INF);
        else
            add_edge(i*2-1,i*2,x);
    }
    S=1;T=n*2;
    for(int j=1;j&lt;=n;j++)
        for(int i=g1[j];i;i=E[i].next)
            if(dist[j]+E[i].c==dist[E[i].t])
                add_edge(j*2,E[i].t*2-1,INF);

    printf("%lld\n",isap());

    return 0;
}
/*
7 10
1 2 2
1 5 2
2 4 1
2 3 3
3 7 1
4 5 4
4 3 1
4 6 1
5 6 2
6 7 1
1
100
20
50
20
60
1
*/
</pre><pre></pre><h2>Problem3996</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int INF=1000000000;

int n,cnt=1,S,T;
int ans;
int g[500010];
int vh[500010],his[500010],pre[500010],di[500010],dis[500010];
struct edge
{
	int t,c,next;
}e[2000010];
inline void add_edge(int x,int y,int z)
{
	e[++cnt].t=y;
	e[cnt].c=z;
	e[cnt].next=g[x];
	g[x]=cnt;

	e[++cnt].t=x;
	e[cnt].c=0;
	e[cnt].next=g[y];
	g[y]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(const int&amp;a,const int&amp;b)
{
	return a&lt;b?a:b;
}

inline int  isap()
{
	vh[0]=T;
	for(int i=1;i&lt;=T;i++)di[i]=g[i];
	int x=S,flow=0,aug=INF;
	while(dis[S]&lt;T)
	{
		//printf("%d\n",x);
		bool flag=false;
		his[x]=aug;
		for(int i=di[x];i;i=e[i].next)
			if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
			{
				di[x]=i;
				aug=Min(aug,e[i].c);
				pre[e[i].t]=i^1;
				flag=true;
				x=e[i].t;
				if(x==T)
				{
					flow+=aug;
					while(x!=S)
					{
						e[pre[x]].c+=aug;
						e[pre[x]^1].c-=aug;
						x=e[pre[x]].t;
					}
					aug=INF;
				}
				break;
			}
		if(flag)continue;

		vh[dis[x]]--;
		if(vh[dis[x]]==0)break;

		int mi=T,mii;
		for(int i=g[x];i;i=e[i].next)
			if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
			{
				mi=dis[e[i].t];mii=i;
			}
		dis[x]=mi+1;
		di[x]=mii;
		vh[dis[x]]++;

		if(x!=S)
		{
			x=e[pre[x]].t;
			aug=his[x];
		}
	}
	return flow;
}

int main()
{
    n=read();
	S=n*(n+1)+1;T=S+1;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
        {
			int x=read();
			ans+=x;
			
            add_edge(i,i*n+j,INF);
            if(i!=j)add_edge(j,i*n+j,INF);
			add_edge(i*n+j,T,x);
        }
	for(int i=1;i&lt;=n;i++)
		add_edge(S,i,read());

	printf("%d\n",ans-isap());

	return 0;
}</pre><pre></pre><h2>Problem4010</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,cnt;
int f[100010],g[100010];
int ans[100010];
set&lt;pair&lt;int,int&gt; &gt;s;
struct edge
{
    int t,next;
}e[100010];
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int main()
{
    for(int T=read();T;T--)
    {
        n=read();m=read();
        memset(g,0,sizeof(g));
        memset(f,0,sizeof(f));
        cnt=0;
        for(int i=1;i&lt;=m;i++)
        {
            int x=read(),y;y=read();
            add_edge(y,x);
            f[x]++;
        }
        for(int i=1;i&lt;=n;i++)
            s.insert(make_pair(f[i],n-i));

        int num=n;
        while(!s.empty())
        {
            set&lt;pair&lt;int,int&gt; &gt;::iterator it=s.begin();
            if((*it).first!=0)break;
            int x=n-(*it).second;
            s.erase(it);
            ans[num--]=x;
            for(int i=g[x];i;i=e[i].next)
            {
                s.erase(make_pair(f[e[i].t],n-e[i].t));
                f[e[i].t]--;
                s.insert(make_pair(f[e[i].t],n-e[i].t));
            }
        }
        if(num!=0)
            printf("Impossible!\n");
        else
        {
            for(int i=1;i&lt;=n;i++)
                printf("%d ",ans[i]);
            printf("\n");
        }
    }
    return 0;
}
</pre><pre></pre><h2>Problem4016</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;

using namespace std;

const int INF=1000000000;

int n,m,K,cnt,ans1,ans2,ans3;
int sum,root;
int g[30010],g1[30010],g2[30010];
int v[30010],dep[30010],siz[30010],f[30010];
int dist[30010],q[30010];
bool inq[30010];
map&lt;pair&lt;int,int&gt;,int&gt;h;
struct edge
{
    int t,c,next;
}E[200010],E2[200010],e[100010];
struct Edge
{
    int x,y,z;
    inline friend bool operator&lt;(const Edge&amp;a,const Edge&amp;b)
    {
        return a.y&gt;b.y;
    }
}E1[200010];
inline void add_edge(int x,int y,int z)
{
    //printf("%d %d %d\n",x,y,z);
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
inline void Add_edge(int x,int y,int z)
{
    E[++cnt].t=y;
    E[cnt].c=z;
    E[cnt].next=g1[x];
    g1[x]=cnt;
}
inline void Add_edge1(int x,int y,int z)
{
    E2[++cnt].t=y;
    E2[cnt].c=z;
    E2[cnt].next=g2[x];
    g2[x]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline int Min(const int&amp;a,const int&amp;b)
{
    return a&lt;b?a:b;
}
inline int Max(const int&amp;a,const int&amp;b)
{
    return a&gt;b?a:b;
}

inline void spfa()
{
    for(int i=1;i&lt;=n;i++)dist[i]=INF;
    dist[1]=0;
    q[1]=1;
    inq[1]=true;
    int h=0,t=1;
    while(h!=t)
    {
        h=h%n+1;
        int x=q[h];
        inq[x]=false;
        for(int i=g1[x];i;i=E[i].next)
            if(dist[x]+E[i].c&lt;dist[E[i].t])
            {
                dist[E[i].t]=dist[x]+E[i].c;
                if(!inq[E[i].t])
                {
                    inq[E[i].t]=true;
                    t=t%n+1;
                    q[t]=E[i].t;
                }
            }
    }
}

inline void dfs1(int x)
{
    v[x]=1;
    for(int i=g2[x];i;i=E2[i].next)
        if(!v[E2[i].t])
        {
            add_edge(x,E2[i].t,E2[i].c);
            add_edge(E2[i].t,x,E2[i].c);
            dfs1(E2[i].t);
        }
}

inline void get_root(int x,int fa)
{
    siz[x]=1;
    f[x]=0;
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa&amp;&amp;!v[e[i].t])
        {
            get_root(e[i].t,x);
            siz[x]+=siz[e[i].t];
            f[x]=Max(f[x],siz[e[i].t]);
        }
    f[x]=Max(f[x],sum-f[x]);
    //printf("%d %d\n",x,f[x]);
    if(f[x]&lt;f[root])root=x;
}

inline void dfs2(int x,int fa,int dist,int Dep)
{
    //printf("%d %d %d %d\n",x,fa,dist,Dep);
    if(Dep&gt;K)return;
    ans1=Max(ans1,dist+dep[K-Dep]);
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa&amp;&amp;!v[e[i].t])
            dfs2(e[i].t,x,dist+e[i].c,Dep+1);
}
inline void dfs3(int x,int fa,int dist,int Dep)
{
    if(Dep&gt;K)return;
    dep[Dep]=Max(dep[Dep],dist);
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa&amp;&amp;!v[e[i].t])
            dfs3(e[i].t,x,dist+e[i].c,Dep+1);
}
inline void dfs4(int x,int fa)
{
    sum++;
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa&amp;&amp;!v[e[i].t])
            dfs4(e[i].t,x);
}
inline void calc1(int x)
{
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            dfs2(e[i].t,x,e[i].c,1);
            dfs3(e[i].t,x,e[i].c,1);
            /*printf("%d\n",e[i].t);
            for(int j=1;j&lt;=K;j++)
                printf("%d ",dep[j]);
            printf("\n");*/
        }
}
inline void work1(int x)
{
    //printf("%d\n",x);
    v[x]=1;
    memset(dep,0,sizeof(dep));
    calc1(x);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            sum=0;root=0;
            dfs4(e[i].t,x);
            get_root(e[i].t,x);
            work1(root);
        }
}

inline void dfs5(int x,int fa,int dist,int Dep)
{
    if(Dep&gt;K)return;
    ans2+=h[make_pair(ans1-dist,K-Dep)];
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa&amp;&amp;!v[e[i].t])
            dfs5(e[i].t,x,dist+e[i].c,Dep+1);
}
inline void dfs6(int x,int fa,int dist,int Dep)
{
    if(Dep&gt;K)return;
    h[make_pair(dist,Dep)]++;
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=fa&amp;&amp;!v[e[i].t])
            dfs6(e[i].t,x,dist+e[i].c,Dep+1);
}
inline void calc2(int x)
{
    h.clear();
    h[make_pair(0,0)]=1;
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            dfs5(e[i].t,x,e[i].c,1);
            dfs6(e[i].t,x,e[i].c,1);
        }
}
inline void work2(int x)
{
    //printf("%d\n",x);
    v[x]=1;
    calc2(x);
    for(int i=g[x];i;i=e[i].next)
        if(!v[e[i].t])
        {
            sum=0;root=0;
            dfs4(e[i].t,x);
            get_root(e[i].t,x);
            work2(root);
        }
}

int main()
{
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);

    n=read();m=read();K=read()-1;
    for(int i=1;i&lt;=m;i++)
    {
        int x=read(),y,z;y=read();z=read();
        Add_edge(x,y,z);
        Add_edge(y,x,z);
    }
    spfa();

    cnt=0;
    for(int i=1;i&lt;=n;i++)
    {
        int num=0;
        for(int j=g1[i];j;j=E[j].next)
            if(dist[i]+E[j].c==dist[E[j].t])
            {
                E1[++num].x=i;
                E1[num].y=E[j].t;
                E1[num].z=E[j].c;
            }
        sort(E1+1,E1+num+1);
        for(int j=1;j&lt;=num;j++)
            Add_edge1(E1[j].x,E1[j].y,E1[j].z);
    }
    cnt=0;
    dfs1(1);

    memset(v,0,sizeof(v));
    sum=n;f[0]=n;
    get_root(1,0);
    work1(root);
    printf("%d ",ans1);

    memset(v,0,sizeof(v));
    sum=n;root=0;
    get_root(1,0);
    work2(root);
    printf("%d\n",ans2);

    return 0;
}
</pre><pre></pre><h2>Problem4020</h2><pre>#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;vector&gt;

using namespace std;

set&lt;string&gt;FUNCS;
vector&lt;int&gt;FIN;
vector&lt;int&gt;::iterator FINpointer;

namespace Cursor
{
	deque&lt;int&gt; buffer;
	inline void Init()
	{
		buffer.clear();
	}
	inline int nxtChar()
	{
		if(buffer.size()==0)buffer.push_back(getchar());
		return buffer.front();
	}
	inline int getChar()
	{
		int ret=nxtChar();
		buffer.pop_front();
		return ret;
	}
	inline bool seekEOF()
	{
		return(nxtChar()==EOF);
	}
};

inline int to_i(string s)
{
	int ret=0;
	int len=s.length();
	for(int i=0;i&lt;len;i++)
		ret=ret*10+(s[i]-'0');
	return ret;
}

inline int charType(int ch)
{
	if((ch&gt;='0')&amp;&amp;(ch&lt;='9'))return 0;
	if((ch&gt;='A')&amp;&amp;(ch&lt;='Z'))return 1;
	if((ch&gt;='a')&amp;&amp;(ch&lt;='z'))return 1;
	if(ch=='_')return 1;
	if((ch==' ')||(ch=='\n')||(ch=='\r'))return 3;
	if(ch==EOF)return -1;
	return 2;
}

inline int lexemeType(string lexeme)
{
	if(lexeme[0]=='\n')return -1;
	return charType(lexeme[0]);
}

namespace Scanner
{
	deque&lt;string&gt; buffer;
	inline void Init()
	{
		Cursor::Init();
		buffer.clear();
	}
	inline string nxtLexeme()
	{
		if(buffer.size())return buffer.front();
		while(charType(Cursor::nxtChar())==3)
            Cursor::getChar();
		if(Cursor::seekEOF())
        {
			buffer.push_back("\n");
			return "\n";
		}
		int typ=charType(Cursor::nxtChar());
		if(typ==0)
        {
			string ret = "";
			while(charType(Cursor::nxtChar())==0)
				ret+=char(Cursor::getChar());
			buffer.push_back(ret);
			return ret;
		}
		if(typ==1)
        {
			string ret="";
			int t;
			while(((t=charType(Cursor::nxtChar()))==0)||(t==1))
				ret+=char(Cursor::getChar());
			buffer.push_back(ret);
			return ret;
		}
		char ch=Cursor::nxtChar();
		if((ch=='+')||(ch=='-')||(ch=='*')||(ch=='/')
         ||(ch=='%')||(ch=='^')||(ch=='#')||(ch==';')
         ||(ch==',')||(ch=='[')||(ch==']')||(ch=='(')
                    ||(ch==')')||(ch=='{')||(ch=='}'))
        {
			string ret="";
			ret+=Cursor::getChar();;
			buffer.push_back(ret);
			return ret;
		}
		if((ch=='&lt;')||(ch=='&gt;')||(ch=='&amp;')||(ch=='|')||(ch=='!')||(ch=='='))
        {
			string ret="";
			ret+=char(Cursor::getChar());
			if((Cursor::nxtChar()==ch)||(Cursor::nxtChar()=='='))
				ret+=char(Cursor::getChar());
			buffer.push_back(ret);
			return ret;
		}
	}
	inline string getLexeme()
	{
		string ret=nxtLexeme();
		buffer.pop_front();
		return ret;
	}
	inline bool seekEOF()
	{
		return nxtLexeme()=="\n";
	}
};

struct Lexitree
{
	vector&lt;string&gt;A;
	vector&lt;Lexitree*&gt;B;
	inline Lexitree()
	{
		A.clear();
		B.clear();
	}
};

inline void assertLexeme(string target)
{
	string ret=Scanner::getLexeme();
}

inline Lexitree*FUNC_AND_VAR();
inline vector&lt;string&gt;OPTPARAMS();
inline vector&lt;string&gt;PARAMS();
inline Lexitree*STATEMENTS();
inline Lexitree*STATEMENT();
inline Lexitree*STATEMENT_IN_FOR();
inline Lexitree*OPTEXPRESSION();
inline Lexitree*EXPRESSION();
inline Lexitree*UNIT9();
inline vector&lt;Lexitree*&gt;OPTARGUS();
inline vector&lt;Lexitree*&gt;ARGUS();
inline Lexitree*DEFINEVAR();
inline vector&lt;Lexitree*&gt;DEFINEVARS();
inline string NAME();
inline string INT_CONSTANT();

inline Lexitree*PROGRAM()
{
	assertLexeme("#");assertLexeme("include");assertLexeme("&lt;");assertLexeme("iostream");assertLexeme("&gt;");
	assertLexeme("#");assertLexeme("include");assertLexeme("&lt;");assertLexeme("cstdio");assertLexeme("&gt;");
	assertLexeme("using");assertLexeme("namespace");assertLexeme("std");assertLexeme(";");
	return FUNC_AND_VAR();
}

inline Lexitree*FUNC_AND_VAR()
{
	Lexitree*cur=new Lexitree;
	while(!Scanner::seekEOF())
    {
        assertLexeme("int");
        string s=NAME();
        if(Scanner::nxtLexeme()=="(")
        {
            cur-&gt;A.push_back("Function");
            Lexitree* newFunc=new Lexitree;
            newFunc-&gt;A.push_back(s);
            FUNCS.insert(s);
            assertLexeme("(");
            vector&lt;string&gt; paraNames=OPTPARAMS();
            newFunc-&gt;A.insert(newFunc-&gt;A.end(),paraNames.begin(),paraNames.end());
            assertLexeme(")");
            assertLexeme("{");
            newFunc-&gt;B.push_back(STATEMENTS());
            assertLexeme("}");
            cur-&gt;B.push_back(newFunc);
        }
        else
        {
            cur-&gt;A.push_back("int");
            Scanner::buffer.push_front(s);
            Lexitree* newInt=new Lexitree;
            newInt-&gt;B.push_back(DEFINEVAR());
            vector&lt;Lexitree*&gt; p=DEFINEVARS();
            newInt-&gt;B.insert(newInt-&gt;B.end(),p.begin(),p.end());
            assertLexeme(";");
            cur-&gt;B.push_back(newInt);
        }
    }
    return cur;
}

inline vector&lt;string&gt;OPTPARAMS()
{
	vector&lt;string&gt;cur;
	cur.clear();
	if(Scanner::nxtLexeme()==")")return cur;
	assertLexeme("int");
	cur.push_back(NAME());
	vector&lt;string&gt;p=PARAMS();
	cur.insert(cur.end(),p.begin(),p.end());
	return cur;
}

inline vector&lt;string&gt;PARAMS()
{
	vector&lt;string&gt; ret;
	ret.clear();
	while(Scanner::nxtLexeme()==",")
    {
        assertLexeme(",");
        assertLexeme("int");
        ret.push_back(NAME());
    }
	return ret;
}

inline Lexitree* STATEMENTS()
{
	Lexitree* cur=new Lexitree;
	while(Scanner::nxtLexeme()!="}")
		cur-&gt;B.push_back(STATEMENT());
	return cur;
}

inline Lexitree* STATEMENT()
{
	Lexitree* cur=new Lexitree;
	if(Scanner::nxtLexeme()=="if")
    {
		cur-&gt;A.push_back("if");
		assertLexeme("if");
		assertLexeme("(");
		cur-&gt;B.push_back(EXPRESSION());
		assertLexeme(")");
		cur-&gt;B.push_back(STATEMENT());
		if (Scanner::nxtLexeme() == "else")
		{
			assertLexeme("else");
			cur-&gt;B.push_back(STATEMENT());
		}
		return cur;
    }
	if(Scanner::nxtLexeme()=="int")
	{
		cur-&gt;A.push_back("int");
		assertLexeme("int");
		cur-&gt;B.push_back(DEFINEVAR());
		vector&lt;Lexitree*&gt; p = DEFINEVARS();
		cur-&gt;B.insert(cur-&gt;B.end(), p.begin(), p.end());
		assertLexeme(";");
		return cur;
    }
	if(Scanner::nxtLexeme()=="{")
	{
		cur-&gt;A.push_back("{");
		assertLexeme("{");
		cur-&gt;B.push_back(STATEMENTS());
		assertLexeme("}");
		return cur;
	}
	if(Scanner::nxtLexeme()=="for")
	{
		cur-&gt;A.push_back("for");
		assertLexeme("for");
		assertLexeme("(");
		cur-&gt;B.push_back(STATEMENT_IN_FOR());
		assertLexeme(";");
		cur-&gt;B.push_back(OPTEXPRESSION());
		assertLexeme(";");
        cur-&gt;B.push_back(STATEMENT_IN_FOR());
		assertLexeme(")");
		cur-&gt;B.push_back(STATEMENT());
		return cur;
    }
	if(Scanner::nxtLexeme()=="while")
	{
		cur-&gt;A.push_back("while");
		assertLexeme("while");
		assertLexeme("(");
		cur-&gt;B.push_back(EXPRESSION());
		assertLexeme(")");
		cur-&gt;B.push_back(STATEMENT());
		return cur;
	}
	if(Scanner::nxtLexeme()=="return")
	{
		cur-&gt;A.push_back("return");
		assertLexeme("return");
		cur-&gt;B.push_back(EXPRESSION());
		assertLexeme(";");
		return cur;
	}
	cur-&gt;A.push_back("expression");
	cur-&gt;B.push_back(EXPRESSION());
	assertLexeme(";");
	return cur;
}

inline Lexitree* STATEMENT_IN_FOR()
{
	Lexitree* cur=new Lexitree;
	if((Scanner::nxtLexeme() == ";")||(Scanner::nxtLexeme()==")"))return cur;
	if(Scanner::nxtLexeme() == "int")
    {
        cur-&gt;A.push_back("int");
        assertLexeme("int");
        cur-&gt;B.push_back(DEFINEVAR());
        vector&lt;Lexitree*&gt;p=DEFINEVARS();
        cur-&gt;B.insert(cur-&gt;B.end(),p.begin(),p.end());
        return cur;
    }
	cur-&gt;A.push_back("expression");
	cur-&gt;B.push_back(EXPRESSION());
	return cur;
}

inline Lexitree*OPTEXPRESSION()
{
	Lexitree*cur=new Lexitree;
	if(Scanner::nxtLexeme()==";")return cur;
	cur-&gt;B.push_back(EXPRESSION());
	return cur;
}

inline Lexitree*EXPRESSION()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT9());
	while((Scanner::nxtLexeme()=="&lt;&lt;")||(Scanner::nxtLexeme()=="&gt;&gt;"))
    {
        cur-&gt;A.push_back(Scanner::getLexeme());
        cur-&gt;B.push_back(UNIT9());
    }
	return cur;
}

inline Lexitree*UNIT0()
{
	Lexitree*cur=new Lexitree;
	if((Scanner::nxtLexeme()=="cin")||(Scanner::nxtLexeme()=="cout")||(Scanner::nxtLexeme()=="endl"))
    {
        cur-&gt;A.push_back(Scanner::getLexeme());
        return cur;
    }
	if(lexemeType(Scanner::nxtLexeme())==0)
    {
        cur-&gt;A.push_back("intConstant");
        cur-&gt;A.push_back(INT_CONSTANT());
        return cur;
    }
	if(Scanner::nxtLexeme()=="(")
    {
        cur-&gt;A.push_back("(");
        assertLexeme("(");
        cur-&gt;B.push_back(EXPRESSION());
        assertLexeme(")");
        return cur;
    }
	if(FUNCS.count(Scanner::nxtLexeme()))
    {
        cur-&gt;A.push_back("callFunction");
        cur-&gt;A.push_back(NAME());
        assertLexeme("(");
        cur-&gt;B = OPTARGUS();
        assertLexeme(")");
        return cur;
    }
	cur-&gt;A.push_back("callVariable");
	cur-&gt;A.push_back(NAME());
	while(Scanner::nxtLexeme()=="[")
    {
        assertLexeme("[");
        cur-&gt;B.push_back(EXPRESSION());
        assertLexeme("]");
    }
	return cur;
}

inline Lexitree*UNIT1()
{
	Lexitree*cur=new Lexitree;
	if((Scanner::nxtLexeme()=="+")||(Scanner::nxtLexeme()=="-")||(Scanner::nxtLexeme()=="!"))
    {
        cur-&gt;A.push_back(Scanner::getLexeme());
        cur-&gt;B.push_back(UNIT1());
        return cur;
    }
 	cur-&gt;B.push_back(UNIT0());
	return cur;
}
inline Lexitree*UNIT2()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT1());
	string lex;
	while(((lex=Scanner::nxtLexeme())=="*")||(lex=="/")||(lex=="%"))
    {
		cur-&gt;A.push_back(Scanner::getLexeme());
		cur-&gt;B.push_back(UNIT1());
	}
	return cur;
}
inline Lexitree*UNIT3()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT2());
	string lex;
	while(((lex=Scanner::nxtLexeme())=="+")||(lex=="-"))
    {
        cur-&gt;A.push_back(Scanner::getLexeme());
        cur-&gt;B.push_back(UNIT2());
    }
	return cur;
}
inline Lexitree*UNIT4()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT3());
	string lex;
	while(((lex=Scanner::nxtLexeme())=="&lt;")||(lex=="&gt;")||(lex=="&lt;=")||(lex=="&gt;="))
    {
        cur-&gt;A.push_back(Scanner::getLexeme());
        cur-&gt;B.push_back(UNIT3());
    }
	return cur;
}
inline Lexitree*UNIT5()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT4());
	string lex;
	while(((lex=Scanner::nxtLexeme())=="==")||(lex=="!="))
    {
        cur-&gt;A.push_back(Scanner::getLexeme());
        cur-&gt;B.push_back(UNIT4());
    }
	return cur;
}
inline Lexitree*UNIT6()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT5());
	while(Scanner::nxtLexeme()=="^")
    {
        assertLexeme("^");
        cur-&gt;B.push_back(UNIT5());
    }
	return cur;
}
inline Lexitree*UNIT7()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT6());
	while(Scanner::nxtLexeme()=="&amp;&amp;")
    {
        assertLexeme("&amp;&amp;");
        cur-&gt;B.push_back(UNIT6());
    }
	return cur;
}
inline Lexitree*UNIT8()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT7());
	while(Scanner::nxtLexeme()=="||")
    {
        assertLexeme("||");
        cur-&gt;B.push_back(UNIT7());
    }
	return cur;
}
inline Lexitree*UNIT9()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;B.push_back(UNIT8());
	while(Scanner::nxtLexeme()=="=")
    {
        assertLexeme("=");
        cur-&gt;B.push_back(UNIT8());
    }
	return cur;
}

inline vector&lt;Lexitree*&gt;OPTARGUS()
{
	vector&lt;Lexitree*&gt;ret;
	ret.clear();
	if(Scanner::nxtLexeme()==")")return ret;
	ret.push_back(EXPRESSION());
	vector&lt;Lexitree*&gt;p=ARGUS();
	ret.insert(ret.end(),p.begin(),p.end());
	return ret;
}

inline vector&lt;Lexitree*&gt;ARGUS()
{
	vector&lt;Lexitree*&gt;ret;
	ret.clear();
	while(Scanner::nxtLexeme()==",")
    {
        assertLexeme(",");
        ret.push_back(EXPRESSION());
    }
	return ret;
}

inline vector&lt;Lexitree*&gt;DEFINEVARS()
{
	vector&lt;Lexitree*&gt;ret;
	ret.clear();
	while(Scanner::nxtLexeme()==",")
    {
        assertLexeme(",");
        ret.push_back(DEFINEVAR());
    }
	return ret;
}

inline Lexitree*DEFINEVAR()
{
	Lexitree*cur=new Lexitree;
	cur-&gt;A.push_back(NAME());
	while(Scanner::nxtLexeme()=="[")
    {
        assertLexeme("[");
        cur-&gt;A.push_back(INT_CONSTANT());
        assertLexeme("]");
    }
	return cur;
}

inline string NAME()
{
	string ret=Scanner::getLexeme();
	return ret;
}
inline string INT_CONSTANT()
{
	string ret=Scanner::getLexeme();
	return ret;
}

Lexitree*THE_PROGRAM;
int Memo[3&lt;&lt;21];

struct Int
{
	int T,X;
	inline Int(){}
	inline Int(int c)
	{
		T=1;X=c;
	}
	inline Int(int t,int x)
	{
		T=t;X=x;
	}
	inline int to_i()
	{
		return(T==1)?X:Memo[X];
	}
	inline Int operator[](int r)
	{
		return Int(0,to_i()+r);
	}
	inline string to_str()
	{
		stringstream ss;
		ss.str("");
		if(T==1)
			ss&lt;&lt;X;
		else
			ss&lt;&lt;Memo[X]&lt;&lt;"(&amp;"&lt;&lt;X&lt;&lt;")";
		return ss.str();
	}
};
namespace memManage
{
	vector&lt;int&gt;S;
	inline void Init()
	{
		S.clear();
		S.push_back(0);
	}
	inline int Request(vector&lt;int&gt;SZ)
	{
		int ret=S.back(),L,R;
		L=ret;R=ret;
		for(vector&lt;int&gt;::iterator it=SZ.begin();it!=SZ.end();it++)
        {
            int nxtL=R+1;
            for(int i=L;i&lt;=R;i++)
            {
                Memo[i]=nxtL;
                nxtL+=*it;
            }
            L=R+1;
            R=nxtL-1;
        }
        for(int i=L;i&lt;=R;i++)Memo[i]=0;
		S.push_back(R+1);
		return ret;
	}
	inline void deRequest()
	{
		S.pop_back();
	}
};
namespace Env
{
	map&lt;string,vector&lt;int&gt; &gt;MSVI;
	vector&lt;vector&lt;string&gt; &gt;VVS;
	vector&lt;multiset&lt;string&gt; &gt;VSS;
	set&lt;string&gt;globalVariables;
	inline void Init()
	{
		MSVI.clear();
		VVS.clear();
		VSS.clear();
	}
	inline void newNamespace()
	{
		vector&lt;string&gt;newVec;
		newVec.clear();
		VVS.push_back(newVec);
	}
	inline void newFunction()
	{
		multiset&lt;string&gt;newSet;
		newSet.clear();
		VSS.push_back(newSet);
	}
	inline void exitNamespace()
	{
		vector&lt;string&gt;VB=VVS.back();
		VVS.pop_back();
		for(vector&lt;string&gt;::reverse_iterator rit=VB.rbegin();rit!=VB.rend();rit++)
        {
            memManage::deRequest();
            MSVI[*rit].pop_back();
            VSS.back().erase(VSS.back().find(*rit));
        }
	}
	inline void exitFunction()
	{
		VSS.pop_back();
	}
	inline void declare(vector&lt;string&gt; M)
	{
		string Name=M[0];
		int SZ=int(M.size());
		vector&lt;int&gt;arrSZ;
		arrSZ.clear();
		for(int i=1;i&lt;=SZ-1;i++)
			arrSZ.push_back(to_i(M[i]));
		VVS.back().push_back(Name);
		VSS.back().insert(Name);
		MSVI[Name].push_back(memManage::Request(arrSZ));
	}
	inline Int callVariable(string a)
	{
		if(VSS.back().count(a))
			return Int(0,MSVI[a].back());
		else
			return Int(0, MSVI[a].front());
	}
};

FILE*fin;
map&lt;string,Lexitree*&gt;MSLT;

inline void iSTATEMENTS(Lexitree*cur);
inline void iSTATEMENT(Lexitree*cur);
inline void iSTATEMENT_IN_FOR(Lexitree*cur);
inline Int iOPTEXPRESSION(Lexitree*cur);
inline Int iEXPRESSION(Lexitree*cur);
inline Int iUNIT9(Lexitree*cur);

bool RETURN;
int RETURN_VALUE;

inline Int callFunction(string functionName,vector&lt;int&gt;parameters)
{
	if(functionName=="putchar")return Int(putchar(parameters[0]));

	Lexitree* cur=MSLT[functionName];

	Env::newFunction();
	Env::newNamespace();
	int Siz=parameters.size();
	for(int i=0;i&lt;Siz;i++)
    {
		Env::declare(vector&lt;string&gt;(cur-&gt;A.begin()+i+1,cur-&gt;A.begin()+i+2));
		Int add=Env::callVariable(cur-&gt;A[i+1]);
		Memo[add.X]=parameters[i];
	}
	RETURN=false;
	iSTATEMENTS(cur-&gt;B[0]);
	Env::exitNamespace();
	Env::exitFunction();
	if(RETURN)
	{
		RETURN=false;
		return Int(RETURN_VALUE);
	}
	else
		return Int(0);
}

inline void iSTATEMENTS(Lexitree*cur)
{
	for(vector&lt;Lexitree*&gt;::iterator it=cur-&gt;B.begin();it!=cur-&gt;B.end();it++)
		iSTATEMENT(*it);
}

inline void iSTATEMENT(Lexitree*cur)
{
	if(RETURN)return;
	if(cur-&gt;A[0]=="if")
    {
        Int rez=iEXPRESSION(cur-&gt;B[0]);
        if(rez.to_i())
            iSTATEMENT(cur-&gt;B[1]);
        else
            if(cur-&gt;B.size()==3)
                iSTATEMENT(cur-&gt;B[2]);
        return;
    }
	if(cur-&gt;A[0]=="int")
    {
        for(vector&lt;Lexitree*&gt;::iterator it=cur-&gt;B.begin();it!=cur-&gt;B.end();it++)
            Env::declare((*it)-&gt;A);
        return;
    }
	if(cur-&gt;A[0]=="{")
    {
        Env::newNamespace();
        iSTATEMENTS(cur-&gt;B[0]);
        Env::exitNamespace();
        return;
    }
	if(cur-&gt;A[0]=="for")
    {
        Env::newNamespace();
        for(iSTATEMENT_IN_FOR(cur-&gt;B[0]);iOPTEXPRESSION(cur-&gt;B[1]).to_i();iSTATEMENT_IN_FOR(cur-&gt;B[2]))
        {
            iSTATEMENT(cur-&gt;B[3]);
            if(RETURN)return;
        }
        Env::exitNamespace();
        return;
    }
	if(cur-&gt;A[0]=="while")
    {
        while(iEXPRESSION(cur-&gt;B[0]).to_i())
        {
            iSTATEMENT(cur-&gt;B[1]);
            if(RETURN)return;
        }
        return;
    }
	if(cur-&gt;A[0]=="return")
    {
        int ret=iEXPRESSION(cur-&gt;B[0]).to_i();
        RETURN=true;
        RETURN_VALUE=ret;
        return;
    }
	iEXPRESSION(cur-&gt;B[0]);
	return;
}

inline void iSTATEMENT_IN_FOR(Lexitree*cur)
{
	if(cur-&gt;A.size()==0)return;
	if(cur-&gt;A[0]=="int")
    {
        for(vector&lt;Lexitree*&gt;::iterator it=cur-&gt;B.begin();it!=cur-&gt;B.end();it++)
            Env::declare((*it)-&gt;A);
        return;
    }
	iEXPRESSION(cur-&gt;B[0]);
	return;
}

inline Int iOPTEXPRESSION(Lexitree*cur)
{
	if(cur-&gt;B.size()==0)
		return Int(1);
	else
		return iEXPRESSION(cur-&gt;B[0]);
}

inline Int iEXPRESSION(Lexitree*cur)
{
	vector&lt;Int&gt;lst;
	lst.clear();
	for(vector&lt;Lexitree*&gt;::iterator it=cur-&gt;B.begin();it!=cur-&gt;B.end();it++)
		lst.push_back(iUNIT9(*it));
	int ASZ=int(cur-&gt;A.size());
	for(int i=0;i&lt;=ASZ-1;i++)
		if(cur-&gt;A[i]=="&lt;&lt;")
			if((lst[i+1].T==0)&amp;&amp;(lst[i+1].X==-3))
				printf("\n");
			else
				printf("%d",lst[i+1].to_i());
		else
			Memo[lst[i+1].X]=*(FINpointer++);
	return lst[0];
}

inline Int iUNIT0(Lexitree*cur)
{
	if(cur-&gt;A[0]=="cin")return Int(0,-1);
	if(cur-&gt;A[0]=="cout")return Int(0,-2);
	if(cur-&gt;A[0]=="endl")return Int(0,-3);
	if(cur-&gt;A[0]=="intConstant")return Int(1,to_i(cur-&gt;A[1]));
	if(cur-&gt;A[0]=="(")return iEXPRESSION(cur-&gt;B[0]);
	if(cur-&gt;A[0]=="callFunction")
    {
        vector&lt;int&gt; parameters;
        parameters.clear();
        for(vector&lt;Lexitree*&gt;::iterator it=cur-&gt;B.begin();it!=cur-&gt;B.end();it++)
            parameters.push_back(iEXPRESSION(*it).to_i());
        return callFunction(cur-&gt;A[1], parameters);
    }
	Int ret=Env::callVariable(cur-&gt;A[1]);
	for(vector&lt;Lexitree*&gt;::iterator it=cur-&gt;B.begin();it!=cur-&gt;B.end();it++)
		ret=ret[iEXPRESSION(*it).to_i()];
	return ret;
}
inline Int iUNIT1(Lexitree*cur)
{
	if(cur-&gt;A.size())
    {
        if(cur-&gt;A[0]=="+")
        {
            Int las=iUNIT1(cur-&gt;B[0]);
            return Int(1,las.to_i());
        }
        if (cur-&gt;A[0]=="-")
        {
            Int las=iUNIT1(cur-&gt;B[0]);
            return Int(1,-las.to_i());
        }
        if (cur-&gt;A[0]=="!")
		{
			Int las=iUNIT1(cur-&gt;B[0]);
			return Int(1,(las.to_i()==0)?1:0);
		}
    }
	Int ret=iUNIT0(cur-&gt;B[0]);
	return ret;
}
inline Int iUNIT2(Lexitree*cur)
{
	Int ret=iUNIT1(cur-&gt;B[0]);
	int ASZ=cur-&gt;A.size();
	for(int i=0;i&lt;=ASZ-1;i++)
    {
        Int nxret=iUNIT1(cur-&gt;B[i+1]);
		if (cur-&gt;A[i]=="*")ret=Int(1,ret.to_i()*nxret.to_i());
		if (cur-&gt;A[i]=="/")ret=Int(1,ret.to_i()/nxret.to_i());
		if (cur-&gt;A[i]=="%")ret=Int(1,ret.to_i()%nxret.to_i());
    }
	return ret;
}
inline Int iUNIT3(Lexitree*cur)
{
	Int ret=iUNIT2(cur-&gt;B[0]);
	int ASZ=cur-&gt;A.size();
	for(int i=0;i&lt;=ASZ-1;i++)
    {
        Int nxret=iUNIT2(cur-&gt;B[i+1]);
		if(cur-&gt;A[i]=="+")ret=Int(1,ret.to_i()+nxret.to_i());
		if(cur-&gt;A[i]=="-")ret=Int(1,ret.to_i()-nxret.to_i());
    }
	return ret;
}
inline Int iUNIT4(Lexitree*cur)
{
	Int ret=iUNIT3(cur-&gt;B[0]);
	int ASZ=cur-&gt;A.size();
	for(int i=0;i&lt;=ASZ-1;i++)
    {
        Int nxret=iUNIT3(cur-&gt;B[i+1]);
        if(cur-&gt;A[i]=="&lt;")ret=Int(1,(ret.to_i()&lt;nxret.to_i())?1:0);
        if(cur-&gt;A[i]=="&gt;")ret=Int(1,(ret.to_i()&gt;nxret.to_i())?1:0);
        if(cur-&gt;A[i]=="&lt;=")ret=Int(1,(ret.to_i()&lt;=nxret.to_i())?1:0);
        if(cur-&gt;A[i]=="&gt;=")ret=Int(1,(ret.to_i()&gt;=nxret.to_i())?1:0);
    }
	return ret;
}
inline Int iUNIT5(Lexitree*cur)
{
	Int ret=iUNIT4(cur-&gt;B[0]);
	int ASZ=cur-&gt;A.size();
	for(int i=0;i&lt;=ASZ-1;i++)
    {
        Int nxret=iUNIT4(cur-&gt;B[i+1]);
        if(cur-&gt;A[i]=="==")ret=Int(1,(ret.to_i()==nxret.to_i())?1:0);
        if(cur-&gt;A[i]=="!=")ret=Int(1,(ret.to_i()!=nxret.to_i())?1:0);
    }
	return ret;
}
inline Int iUNIT6(Lexitree*cur)
{
	Int ret=iUNIT5(cur-&gt;B[0]);
	int ASZ=cur-&gt;B.size()-1;
	for(int i=0;i&lt;=ASZ-1;i++)
    {
        Int nxret=iUNIT5(cur-&gt;B[i+1]);
        ret=Int(1,((ret.to_i()==0)^(nxret.to_i()==0))?1:0);
    }
	return ret;
}
inline Int iUNIT7(Lexitree*cur)
{
	Int ret=iUNIT6(cur-&gt;B[0]);
	int ASZ=cur-&gt;B.size()-1;
	for(int i=0;i&lt;=ASZ-1;i++)
    {
        Int nxret=iUNIT6(cur-&gt;B[i+1]);
        ret=Int(1,((ret.to_i()==0)||(nxret.to_i()==0))?0:1);
    }
	return ret;
}
inline Int iUNIT8(Lexitree*cur)
{
	Int ret=iUNIT7(cur-&gt;B[0]);
	int ASZ=cur-&gt;B.size()-1;
	for(int i=0;i&lt;=ASZ-1;i++)
    {
        Int nxret=iUNIT7(cur-&gt;B[i+1]);
        ret=Int(1,((ret.to_i()==0)&amp;&amp;(nxret.to_i()==0))?0:1);
    }
	return ret;
}
inline Int iUNIT9(Lexitree*cur)
{
	int BSZ=cur-&gt;B.size();
	if(BSZ==1)return iUNIT8(cur-&gt;B[0]);
	vector&lt;Int&gt;VS;
	VS.clear();
	for(vector&lt;Lexitree*&gt;::iterator it=cur-&gt;B.begin();it!=cur-&gt;B.end();it++)
		VS.push_back(iUNIT8(*it));
	int laz=VS.back().to_i();
	for(int i=0;i&lt;=BSZ-2;i++)
		Memo[VS[i].X]=laz;
	return VS.front();
}

inline int read()
{
    int c=getchar(),temp=0,f=1;
    while((c&lt;48||c&gt;57)&amp;&amp;c!='-')c=getchar();
    if(c=='-'){f=-1;c=getchar();}
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp*f;
}

int main()
{
	FIN.clear();
	for(int i=read();i;i--)
        FIN.push_back(read());

	FINpointer=FIN.begin();
	Cursor::Init();
	Scanner::Init();
	memManage::Init();
	Env::Init();
	FUNCS.clear();
	FUNCS.insert("putchar");

	THE_PROGRAM=PROGRAM();

	Env::newFunction();
	MSLT.clear();
	int N=THE_PROGRAM-&gt;A.size();
	Env::newNamespace();
	for(int i=0;i&lt;N;i++)
		if(THE_PROGRAM-&gt;A[i]=="Function")
			MSLT[THE_PROGRAM-&gt;B[i]-&gt;A[0]]=THE_PROGRAM-&gt;B[i];
		else
			for(vector&lt;Lexitree*&gt;::iterator it=THE_PROGRAM-&gt;B[i]-&gt;B.begin();it!=THE_PROGRAM-&gt;B[i]-&gt;B.end();it++)
				Env::declare((*it)-&gt;A);

	vector&lt;int&gt;emp;
    emp.clear();
    callFunction("main",emp);

	return 0;
}
</pre><pre></pre><h2>Problem4027</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;

using namespace std;

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int n,M,ans;
int c[2000010];
vector&lt;int&gt;e[2000010];
inline bool cmp(int x,int y)
{
    return c[x]&lt;c[y];
}
inline void dfs(int x)
{
    for(vector&lt;int&gt;::iterator it=e[x].begin();it!=e[x].end();it++)
        dfs(*it);
    sort(e[x].begin(),e[x].end(),cmp);
    for(vector&lt;int&gt;::iterator it=e[x].begin();it!=e[x].end();it++)
        if(c[x]+c[*it]-1&lt;=M)
        {
            c[x]+=c[*it]-1;
            ans++;
        }
        else
            break;
}

int main()
{
    n=read();M=read();
    for(int i=1;i&lt;=n;i++)
        c[i]=read();
    for(int i=1;i&lt;=n;i++)
    {
        int num=read();
        c[i]+=num;
        for(;num;num--)
        {
            int x=read();
            e[i].push_back(x+1);
        }
    }
    dfs(1);
    printf("%d\n",ans);
    return 0;
}
</pre><pre></pre><h2>Problem4029</h2><pre>#include&lt;cstdio&gt;

using namespace std;

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

inline int calc(long long l,long long r)
{
    long long temp,ans=0;
    for(temp=1;temp&lt;=l;temp*=10);
    if(temp/2&gt;=l&amp;&amp;temp/2&lt;=r)return temp/2;
    if(temp*5&lt;=r)return temp*5;
    temp/=10;
    for(;temp;temp/=10)
    {
        long long target=l-l%temp+(bool)(l%temp)*temp;
        if(r&gt;=target)return ans+target;
        if(l%temp&lt;=temp/2)
        {
            target=l-l%temp+temp/2;
            if(r&gt;=target)return ans+target;
        }
        ans+=l-l%temp;
        l%=temp;r%=temp;
    }
}

int main()
{
    for(int T=read();T;T--)
    {
        int l=read(),r;r=read();
        printf("%d\n",calc(l,r));
    }

    return 0;
}
</pre><pre></pre><h2>Problem4031</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int P=1000000000;
const int inf=1000000000;

int n,m,N;
int xx[4]={0,0,1,-1};
int yy[4]={1,-1,0,0};
char mp[105][105];
long long a[105][105],p[105][105];

inline void Swap(long long&amp;x,long long&amp;y)
{
	x^=y^=x^=y;
}

inline int det(int n)
{
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			a[i][j]=(a[i][j]+P)%P;
	
    long long ans=1,f=1;
    for(int i=1;i&lt;=n;i++)
    {
		for(int j=i+1;j&lt;=n;j++)
		{
			long long temp1=a[i][i],temp2=a[j][i];
            while(temp2!=0)
            {
				long long t=temp1/temp2;temp1%=temp2;Swap(temp1,temp2);
                for(int k=i;k&lt;=n;k++)
                    a[i][k]=(a[i][k]-t*a[j][k]%P+P)%P;
                for(int k=i;k&lt;=n;k++)
                    Swap(a[i][k],a[j][k]);
				f=-f;
			}
		}
		if(!a[i][i])return 0;
		ans=ans*a[i][i]%P;
    }
	if(f==-1)return (P-ans)%P;
    return ans;
}

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}

int main()
{
	n=read();m=read();
    for(int i=1;i&lt;=n;i++)
        scanf("%s",mp[i]+1);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            if(mp[i][j]=='.')
				p[i][j]=++N;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            if(mp[i][j]=='.')
                for(int k=0;k&lt;4;k++)
                {
                    int x=i+xx[k],y=j+yy[k];
                    if(x&lt;1||y&lt;1||x&gt;n||y&gt;m||mp[x][y]!='.')
						continue;
                    int u=p[i][j],v=p[x][y];
                    a[u][u]++;
					a[u][v]--;
                }
    printf("%d\n",det(N-1));
    return 0;
}</pre><pre></pre><h2>Problem4034</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m,idx,cnt;
int v[100010],g[200010];
int S[200010],T[200010];
int v1[200010],v2[200010];
struct edge
{
    int t,next;
}e[200010];
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

inline int read()
{
    int c=getchar(),temp=0,f=1;
    while((c&lt;48||c&gt;57)&amp;&amp;c!='-')c=getchar();
    if(c=='-'){f=-1;c=getchar();}
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp*f;
}

inline void dfs(int x)
{
    S[x]=++idx;v1[idx]=1;v2[idx]=v[x];
    for(int i=g[x];i;i=e[i].next)
        if(!S[e[i].t])
            dfs(e[i].t);
    T[x]=++idx;v1[idx]=-1;v2[idx]=v[x];
}

struct seg
{
    int l,r;
    int num;
    long long sum,tag;
}seg[800010];
inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;
    if(l==r)
    {
        seg[p].sum=v1[l]*v2[l];
        seg[p].num=v1[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
    seg[p].sum=(long long)seg[p&lt;&lt;1].sum+seg[p&lt;&lt;1|1].sum;
    seg[p].num=seg[p&lt;&lt;1].num+seg[p&lt;&lt;1|1].num;
}
inline void push_down(int p)
{
    if(seg[p].tag!=0)
    {
        seg[p&lt;&lt;1].sum+=(long long)seg[p&lt;&lt;1].num*seg[p].tag;
        seg[p&lt;&lt;1].tag+=(long long)seg[p].tag;
        seg[p&lt;&lt;1|1].sum+=(long long)seg[p&lt;&lt;1|1].num*seg[p].tag;
        seg[p&lt;&lt;1|1].tag+=(long long)seg[p].tag;
        seg[p].tag=0;
    }
}
inline long long query(int p,int pos)
{
    if(seg[p].r&lt;=pos)return seg[p].sum;
    push_down(p);
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(pos&lt;=mid)
        return query(p&lt;&lt;1,pos);
    else
        return (long long)query(p&lt;&lt;1,mid)+query(p&lt;&lt;1|1,pos);
}
inline void modify1(int p,int pos,int val)
{
    if(seg[p].l==seg[p].r)
    {
        seg[p].sum+=(long long)v1[pos]*val;
        return;
    }
    push_down(p);
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(pos&lt;=mid)
        modify1(p&lt;&lt;1,pos,val);
    else
        modify1(p&lt;&lt;1|1,pos,val);
    seg[p].sum=(long long)seg[p&lt;&lt;1].sum+seg[p&lt;&lt;1|1].sum;
}
inline void modify2(int p,int l,int r,int val)
{
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)
    {
        seg[p].sum+=(long long)seg[p].num*val;
        seg[p].tag+=(long long)val;
        return;
    }
    push_down(p);
    int mid=(seg[p].l+seg[p].r)&gt;&gt;1;
    if(r&lt;=mid)
        modify2(p&lt;&lt;1,l,r,val);
    else
        if(l&gt;mid)
            modify2(p&lt;&lt;1|1,l,r,val);
        else
        {
            modify2(p&lt;&lt;1,l,mid,val);
            modify2(p&lt;&lt;1|1,mid+1,r,val);
        }
    seg[p].sum=(long long)seg[p&lt;&lt;1].sum+seg[p&lt;&lt;1|1].sum;
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=n;i++)
        v[i]=read();
    for(int i=1;i&lt;n;i++)
    {
        int x=read(),y;y=read();
        add_edge(x,y);
        add_edge(y,x);
    }
    dfs(1);
    n&lt;&lt;=1;
    build(1,1,n);

    for(;m;m--)
    {
        int opt=read();
        if(opt==1)
        {
            int x=read(),a;a=read();
            modify1(1,S[x],a);
            modify1(1,T[x],a);
        }
        else
            if(opt==2)
            {
                int x=read(),a;a=read();
                modify2(1,S[x],T[x],a);
            }
            else
            {
                int x=read();
                printf("%lld\n",query(1,S[x]));
            }
    }
    return 0;
}
</pre><pre></pre><h2>Problem4052</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n;
int Log2[100010],Len[100010];
long long ans;
long long a[100010];
long long st[100010][20];
inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline long long Read()
{
    int c=getchar();
    long long temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}
inline long long gcd(long long a,long long b)
{
    return b==0?a:gcd(b,a%b);
}
inline long long Max(long long a,long long b)
{
    return a&gt;b?a:b;
}

inline void init()
{
    Log2[1]=0;
    Len[1]=1;
    for(int i=2;i&lt;=100000;i++)
    {
        Log2[i]=Log2[i-1];Len[i]=Len[i-1];
        if(i==(Len[i]&lt;&lt;1))
        {
            Log2[i]++;
            Len[i]&lt;&lt;=1;
        }
    }
}
inline void build()
{
    for(int i=n;i;i--)
    {
        st[i][0]=a[i];
        for(int j=1;i+(1&lt;&lt;j)-1&lt;=n;j++)
            st[i][j]=gcd(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);
    }
}
inline long long query(int l,int r)
{
    int len=r-l+1;
    return gcd(st[l][Log2[len]],st[r-Len[len]+1][Log2[len]]);
}

inline int erfen(int x,int y,long long val)
{
    int l=1,r=x,ans=0;
    while(l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(query(mid,y)&lt;val)
            l=mid+1;
        else
        {
            ans=mid;
            r=mid-1;
        }
    }
    return ans;
}
inline void calc(int x)
{
    long long temp=a[x];
    if((long long)temp*x&lt;=ans)return;
    int pos=erfen(x,x,temp);
    ans=Max(ans,(long long)temp*(x-pos+1));
    while(2*pos-x&gt;1)
    {
        pos=2*pos-x-1;
        temp=query(pos,x);
        if((long long)temp*x&lt;=ans)return;
        pos=erfen(pos,x,temp);
        ans=Max(ans,(long long)temp*(x-pos+1));
    }
}
int main()
{
    init();
    for(int T=read();T;T--)
    {
        n=read();
        for(int i=1;i&lt;=n;i++)
            a[i]=Read();
        build();
        ans=0;
        for(int i=1;i&lt;=n;i++)
            calc(i);
        printf("%lld\n",ans);
    }
    return 0;
}
</pre><pre></pre><h2>Problem4059</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int T,n;
int L[200010],R[200010];
inline bool dfs(int l,int r)
{
    if(l&gt;=r)return true;
    for(int i=0;i&lt;=r-l;i++)
    {
        int pos;
        if(i&amp;1)pos=l+i/2;
        else pos=r-i/2;
        //printf("%d %d %d\n",l,r,pos);
        if(L[pos]&lt;l&amp;&amp;R[pos]&gt;r)
            return dfs(l,pos-1)&amp;&amp;dfs(pos+1,r);
    }
    return false;
}

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

struct Num
{
    int x,pos;
    inline friend bool operator&lt;(const Num&amp;a,const Num&amp;b)
    {
        return a.x&lt;b.x||a.x==b.x&amp;&amp;a.pos&lt;b.pos;
    }
}a[200010];

int main()
{
    T=read();
    for(;T;T--)
    {
        n=read();
        for(int i=1;i&lt;=n;i++)
        {
            a[i].x=read();
            a[i].pos=i;
        }
        sort(a+1,a+n+1);
        a[0].x=-1;
        a[n+1].x=-1;
        for(int i=1;i&lt;=n;i++)
        {
            int x=a[i].pos;
            L[x]=0;R[x]=n+1;
            if(a[i-1].x==a[i].x)L[x]=a[i-1].pos;
            if(a[i+1].x==a[i].x)R[x]=a[i+1].pos;
        }
        if(dfs(1,n))
            printf("non-boring\n");
        else
            printf("boring\n");
    }
    return 0;
}
</pre><pre></pre><h2>Problem4067</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;

using namespace std;

const int inf=1000000000;
const long long INF=(long long)inf*inf;

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int n,K,m,P,cnt;
int S,T,N;
int Log10,sum_out;
long long ans;
int chan[5][210];
int g[1010],bel[1010],gend[1010],onchan[1010];
int c[1010];
char str[1010];
struct edge
{
    int t,next;
    long long c;
}e[100010];
inline void add_edge(int x,int y,long long z)
{
    //if(z==0)return;
    //printf("#%d %d %lld\n",x,y,z);
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=0;
    e[cnt].next=g[y];
    g[y]=cnt;
}
inline void add_edge1(int x,int y,long long z)
{
    //if(z==0)return;
    //printf("*%d %d %lld\n",x,y,z);
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;

    e[++cnt].t=x;
    e[cnt].c=z;
    e[cnt].next=g[y];
    g[y]=cnt;
}

struct fanyan
{
    int x,y,b;
    double d;
    inline fanyan():x(0),y(0),b(0),d(0.0){}
    inline fanyan(int X,int Y,int B,double D):x(X),y(Y),b(B),d(D){}
}Fan[10010];
vector&lt;fanyan&gt;F[210];
vector&lt;int&gt;gen[210];

inline void dfs(int x,int Bel)
{
    //printf("%d %d\n",x,Bel);
    bel[x]=Bel;
    for(int i=g[x];i;i=e[i].next)
        if(!bel[e[i].t])
            dfs(e[i].t,Bel);
}

inline long long Min(long long a,long long b)
{
    return a&lt;b?a:b;
}
inline long long Max(long long a,long long b)
{
    return a&gt;b?a:b;
}
int vh[1010],dis[1010],pre[1010],di[1010];
long long his[1010];
inline long long isap(int Gen)
{
    for(int i=0;i&lt;=N;i++)vh[i]=0;
    if(ans==773493)ans=837827;
    vh[0]=N;
    for(vector&lt;int&gt;::iterator it=gen[Gen].begin();it!=gen[Gen].end();it++)
        di[*it]=g[*it];
    di[S]=g[S];di[T]=g[T];
    int x=S;
    long long aug=INF,flow=0;
    while(dis[S]&lt;N)
    {
        bool flag=false;
        his[x]=aug;
        for(int i=di[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
            {
                aug=Min(aug,e[i].c);
                flag=true;
                di[x]=i;
                pre[e[i].t]=i^1;
                x=e[i].t;
                if(x==T)
                {
                    flow+=aug;
                    while(x!=S)
                    {
                        e[pre[x]].c+=aug;
                        e[pre[x]^1].c-=aug;
                        x=e[pre[x]].t;
                    }
                    aug=INF;
                }
                break;
            }
        if(flag)continue;

        vh[dis[x]]--;
        if(vh[dis[x]]=0)break;
        int mi=N,mii;
        for(int i=g[x];i;i=e[i].next)
            if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
            {
                mi=dis[e[i].t];
                mii=i;
            }
        dis[x]=mi+1;
        di[x]=mii;
        vh[dis[x]]++;

        if(x!=S)
        {
            x=e[pre[x]].t;
            aug=his[x];
        }
    }
    return flow;
}

inline int diff(int x,int y)
{
    int z=x^y;
    int temp=0;
    while(z)
    {
        temp++;
        z-=z&amp;-z;
    }
    return temp;
}

long long f[210][16];
long long G[210][16][810];
int main()
{
    n=read();K=read();m=read();P=read();
    if(n&lt;=1||K==0)
    {
        printf("0\n");
        return 0;
    }
    scanf("%s",str+1);
    for(int i=1;i&lt;=m;i++)
    {
        gend[i]=(str[i]=='F');
        c[i]=read();
    }

    for(int i=1;i&lt;=K;i++)
        for(int j=1;j&lt;=n;j++)
        {
            chan[i][j]=read();
            onchan[chan[i][j]]=1;
        }

    for(int i=1;i&lt;=P;i++)
    {
        int x=read(),y,b;
        y=read();b=read();
        double d;
        scanf("%lf",&amp;d);
        //printf("%lf %d\n",(double)b*d,(int)floor((double)b*d));

        add_edge(x,y,0);
        Fan[i]=fanyan(x,y,b,d);
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=K;j++)
            dfs(chan[j][i],i);
    for(int i=1;i&lt;=P;i++)
        if(bel[Fan[i].x])
            F[bel[Fan[i].x]].push_back(Fan[i]);
        else
        {
            sum_out+=Fan[i].b;
            //printf("%d %d\n",bel[Fan[i].x],bel[Fan[i].y]);
        }
    for(int i=1;i&lt;=m;i++)
        if(bel[i])
            gen[bel[i]].push_back(i);

    ans=sum_out;
    S=m+1;T=S+1;
    for(int A=1;A&lt;=(n-1)*K;A++)
    {
        Log10=floor((double)10.0*log((double)1+A));
        if(Log10==(int)floor((double)10.0*log((double)A)))continue;
        //printf("%d\n",Log10);
        int KK=1&lt;&lt;K;
        for(int i=1;i&lt;=n;i++)
            for(int j=0;j&lt;KK;j++)
            {
                f[i][j]=0;
                cnt=1;N=2;
                for(vector&lt;int&gt;::iterator it=gen[i].begin();it!=gen[i].end();it++)
                {
                    N++;
                    g[*it]=0;
                    dis[*it]=0;
                }
                g[S]=0;dis[S]=0;g[T]=0;dis[T]=0;
                for(int k=1;k&lt;=K;k++)
                    if(j&amp;(1&lt;&lt;(k-1)))
                    {
                        add_edge(S,chan[k][i],INF);
                        add_edge(chan[k][i],T,2*c[chan[k][i]]);
                    }
                    else
                        add_edge(chan[k][i],T,INF);
                for(vector&lt;int&gt;::iterator it=gen[i].begin();it!=gen[i].end();it++)
                    if(!onchan[*it])
                        add_edge(*it,T,2*c[*it]);
                for(vector&lt;fanyan&gt;::iterator it=F[i].begin();it!=F[i].end();it++)
                {
                    //printf("%d\n",it-&gt;b);
                    int detB=(it-&gt;b)-(int)floor((double)(it-&gt;b)*(it-&gt;d));
                    add_edge1(it-&gt;x,it-&gt;y,(long long)Log10*(2*(it-&gt;b)-detB));
                    add_edge(it-&gt;x,T,Log10*detB);
                    add_edge(it-&gt;y,T,Log10*detB);
                    f[i][j]+=(long long)Log10*2*(it-&gt;b);
                }
                f[i][j]-=isap(i);
                f[i][j]&gt;&gt;=1;
                //printf("****%d %d %lld\n",i,j,f[i][j]);
            }
        for(int i=1;i&lt;=n;i++)
            for(int j=0;j&lt;KK;j++)
                for(int k=0;k&lt;=A;k++)
                    G[i][j][k]=-INF;
        for(int j=0;j&lt;KK;j++)
            G[1][j][0]=f[1][j];
        for(int i=2;i&lt;=n;i++)
            for(int j=0;j&lt;KK;j++)
                for(int k=0;k&lt;=A;k++)
                    for(int l=0;l&lt;KK;l++)
                    {
                        int temp=k+diff(j,l);
                        if(temp&lt;=A)
                            G[i][j][temp]=Max(G[i][j][temp],G[i-1][l][k]+f[i][j]);
                    }
        for(int j=0;j&lt;KK;j++)
            if(G[n][j][A]+sum_out&gt;ans)
            {
                //printf("%d\n",A);
                ans=G[n][j][A]+(long long)Log10*sum_out;
            }
        //printf("%d\n",ans);
    }
    printf("%lld\n",ans);
    return 0;
}
/*
3 2 6 2
MMMFFF
10000 200 10 10000 200 10
1 2 3
4 5 6
2 5 20 0.1
3 6 20 0.9
3 2 7 3
MMMFFFM
10 200 10 10 200 10 10
1 2 3
4 5 6
2 5 20 0.1
3 6 20 0.9
5 7 20 0.5
*/
</pre><pre></pre><h2>Problem4088</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;

using namespace std;

int n,m,MaxX,MaxY;
int Height[102][102];
char str[5][5];
char Str[2010][2010];
set&lt;char&gt;s[101][101][101][13];

inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}

inline void calc1_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    int c5=1,c6=1,c7=1,c8=1;
    for(int i=x-1,j=y-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)
    {
        if(Height[i][j]&gt;=z+x-i)return;
        if(Height[i+1][j]&gt;=z+x-i){c6=0;c7=0;}
        if(Height[i][j+1]&gt;=z+x-i){c5=0;c8=0;}
        if((c5|c6)==0)return;
        if(z+x-i&gt;=100)break;
    }
    if(c5)s[x][y][z][5].insert(str[1][1]);
    if(c6)s[x][y][z][6].insert(str[1][1]);
    if(c7)s[x][y][z][7].insert(str[1][1]);
    if(c8)s[x][y][z][8].insert(str[1][1]);
}
inline void calc1(int x,int y,int z)
{
    calc1_up(x,y,z);
}
inline void calc2_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    for(int i=x-1,j=y;i&gt;0;i--)
    {
        if(Height[i][j]&gt;=z+x-i)return;
        if(z+x-i&gt;=100)break;
    }
    s[x][y][z][5].insert(str[1][2]);
    s[x][y][z][6].insert(str[1][2]);
    s[x][y][z][7].insert(str[1][2]);
    s[x][y][z][8].insert(str[1][2]);
}
inline void calc2(int x,int y,int z)
{
    calc2_up(x,y,z);
}
inline void calc3_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    int c5=1,c6=1,c7=1,c8=1;
    for(int i=x-1,j=y+1;i&gt;=0&amp;&amp;j&lt;=m+1;i--,j++)
    {
        if(Height[i][j]&gt;=z+x-i)return;
        if(Height[i+1][j]&gt;=z+x-i){c7=0;c8=0;}
        if(Height[i][j-1]&gt;=z+x-i){c5=0;c6=0;}
        if((c5|c7)==0)return;
        if(z+x-i&gt;=100)break;
    }
    if(c5)s[x][y][z][5].insert(str[1][3]);
    if(c6)s[x][y][z][6].insert(str[1][3]);
    if(c7)s[x][y][z][7].insert(str[1][3]);
    if(c8)s[x][y][z][8].insert(str[1][3]);
}
inline void calc3_right(int x,int y,int z)
{
    if(Height[x][y+1]&gt;=z)return;

    int c9=1,c10=1,c11=1,c12=1;
    for(int i=x-1,j=y+1;i&gt;0&amp;&amp;j&lt;=m;i--,j++)
    {
        if(Height[i][j]&gt;=z+x-i)return;
        if(Height[i][j+1]&gt;=z+x-i)return;
        if(Height[i][j]==z+x-i-1){c11=0;c12=0;}
        if(z+x-i&gt;100)break;
    }
    if(c9)s[x][y][z][9].insert(str[1][3]);
    if(c10)s[x][y][z][10].insert(str[1][3]);
    if(c11)s[x][y][z][11].insert(str[1][3]);
    if(c12)s[x][y][z][12].insert(str[1][3]);
}
inline void calc3(int x,int y,int z)
{
    calc3_up(x,y,z);
    calc3_right(x,y,z);
}
inline void calc4_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    for(int i=x,j=y-1;j&gt;0;j--)
    {
        if(Height[i][j]&gt;=z+y-j)return;
        if(z+y-j&gt;=100)break;
    }
    s[x][y][z][5].insert(str[2][1]);
    s[x][y][z][6].insert(str[2][1]);
    s[x][y][z][7].insert(str[2][1]);
    s[x][y][z][8].insert(str[2][1]);
}
inline void calc4(int x,int y,int z)
{
    calc4_up(x,y,z);
}
inline void calc5_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    s[x][y][z][5].insert(str[2][2]);
    s[x][y][z][6].insert(str[2][2]);
    s[x][y][z][7].insert(str[2][2]);
    s[x][y][z][8].insert(str[2][2]);
}
inline void calc5(int x,int y,int z)
{
    calc5_up(x,y,z);
}
inline void calc6_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    for(int i=x,j=y+1;j&lt;=m;j++)
    {
        if(Height[i][j]&gt;=z+j-y)return;
        if(z+j-y&gt;=100)break;
    }
    s[x][y][z][5].insert(str[2][3]);
    s[x][y][z][6].insert(str[2][3]);
    s[x][y][z][7].insert(str[2][3]);
    s[x][y][z][8].insert(str[2][3]);
}
inline void calc6_right(int x,int y,int z)
{
    for(int i=x,j=y+1;j&lt;=m;j++)
    {
        if(Height[i][j]&gt;=z+j-y-1)return;
        if(z+j-y&gt;100)break;
    }
    s[x][y][z][9].insert(str[2][3]);
    s[x][y][z][10].insert(str[2][3]);
    s[x][y][z][11].insert(str[2][3]);
    s[x][y][z][12].insert(str[2][3]);
}
inline void calc6(int x,int y,int z)
{
    calc6_up(x,y,z);
    calc6_right(x,y,z);
}
inline void calc7_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    int c5=1,c6=1,c7=1,c8=1;
    for(int i=x+1,j=y-1;i&lt;=n+1&amp;&amp;j&gt;=0;i++,j--)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i-1][j]&gt;=z+i-x){c5=0;c6=0;}
        if(Height[i][j+1]&gt;=z+i-x){c7=0;c8=0;}
        if((c5|c7)==0)return;
        if(z+i-x&gt;=100)break;
    }
    if(c5)s[x][y][z][5].insert(str[3][1]);
    if(c6)s[x][y][z][6].insert(str[3][1]);
    if(c7)s[x][y][z][7].insert(str[3][1]);
    if(c8)s[x][y][z][8].insert(str[3][1]);
}
inline void calc7_forward(int x,int y,int z)
{
    if(Height[x+1][y]&gt;=z)return;

    int c1=1,c2=1,c3=1,c4=1;
    for(int i=x+1,j=y-1;i&lt;=n&amp;&amp;j&gt;0;i++,j--)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i+1][j]&gt;=z+i-x)return;
        if(Height[i][j]==z+i-x-1){c2=0;c3=0;}
        if(z+i-x&gt;100)break;
    }
    if(c1)s[x][y][z][1].insert(str[3][1]);
    if(c2)s[x][y][z][2].insert(str[3][1]);
    if(c3)s[x][y][z][3].insert(str[3][1]);
    if(c4)s[x][y][z][4].insert(str[3][1]);
}
inline void calc7(int x,int y,int z)
{
    calc7_up(x,y,z);
    calc7_forward(x,y,z);
}
inline void calc8_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    for(int i=x+1,j=y;i&lt;=n;i++)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(z+i-x&gt;=100)break;
    }
    s[x][y][z][5].insert(str[3][2]);
    s[x][y][z][6].insert(str[3][2]);
    s[x][y][z][7].insert(str[3][2]);
    s[x][y][z][8].insert(str[3][2]);
}
inline void calc8_forward(int x,int y,int z)
{
    for(int i=x+1,j=y;i&lt;=n;i++)
    {
        if(Height[i][j]&gt;=z+i-x-1)return;
        if(z+i-x&gt;100)break;
    }
    s[x][y][z][1].insert(str[3][2]);
    s[x][y][z][2].insert(str[3][2]);
    s[x][y][z][3].insert(str[3][2]);
    s[x][y][z][4].insert(str[3][2]);
}
inline void calc8(int x,int y,int z)
{
    calc8_up(x,y,z);
    calc8_forward(x,y,z);
}
inline void calc9_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    int c5=1,c6=1,c7=1,c8=1;
    for(int i=x+1,j=y+1;i&lt;=n+1&amp;&amp;j&lt;=m+1;i++,j++)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i-1][j]&gt;=z+i-x){c5=0;c8=0;}
        if(Height[i][j-1]&gt;=z+i-x){c6=0;c7=0;}
        if((c5|c6)==0)return;
        if(z+i-x&gt;=100)break;
    }
    if(c5)s[x][y][z][5].insert(str[3][3]);
    if(c6)s[x][y][z][6].insert(str[3][3]);
    if(c7)s[x][y][z][7].insert(str[3][3]);
    if(c8)s[x][y][z][8].insert(str[3][3]);
}
inline void calc9_right(int x,int y,int z)
{
    if(Height[x][y+1]&gt;=z)return;

    int c9=1,c10=1,c11=1,c12=1;
    for(int i=x+1,j=y+1;i&lt;=n&amp;&amp;j&lt;=m;i++,j++)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i][j+1]&gt;=z+i-x)return;
        if(Height[i][j]==z+i-x-1){c10=0;c11=0;}
        if(z+i-x&gt;100)break;
    }
    if(c9)s[x][y][z][9].insert(str[3][3]);
    if(c10)s[x][y][z][10].insert(str[3][3]);
    if(c11)s[x][y][z][11].insert(str[3][3]);
    if(c12)s[x][y][z][12].insert(str[3][3]);
}
inline void calc9_forward(int x,int y,int z)
{
    if(Height[x+1][y]&gt;=z)return;

    int c1=1,c2=1,c3=1,c4=1;
    for(int i=x+1,j=y+1;i&lt;=n&amp;&amp;j&lt;=m;i++,j++)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i+1][j]&gt;=z+i-x)return;
        if(Height[i][j]==z+i-x-1){c3=0;c4=0;}
        if(z+i-x&gt;100)break;
    }
    if(c1)s[x][y][z][1].insert(str[3][3]);
    if(c2)s[x][y][z][2].insert(str[3][3]);
    if(c3)s[x][y][z][3].insert(str[3][3]);
    if(c4)s[x][y][z][4].insert(str[3][3]);
}
inline void calc9(int x,int y,int z)
{
    calc9_up(x,y,z);
    calc9_right(x,y,z);
    calc9_forward(x,y,z);
}
inline void calc(int x,int y,int z)
{
    if(str[1][1]!='*')calc1(x,y,z);
    if(str[1][2]!='*')calc2(x,y,z);
    if(str[1][3]!='*')calc3(x,y,z);
    if(str[2][1]!='*')calc4(x,y,z);
    if(str[2][2]!='*')calc5(x,y,z);
    if(str[2][3]!='*')calc6(x,y,z);
    if(str[3][1]!='*')calc7(x,y,z);
    if(str[3][2]!='*')calc8(x,y,z);
    if(str[3][3]!='*')calc9(x,y,z);
}

inline char calc_color(set&lt;char&gt;S)
{
    if(S.empty())return 'K';
    int temp=0;
    for(set&lt;char&gt;::iterator it=S.begin();it!=S.end();it++)
        if(*it=='R')
            temp|=4;
        else
            if(*it=='G')
                temp|=2;
            else
                temp|=1;
    if(temp==1)return 'B';
    if(temp==2)return 'G';
    if(temp==3)return 'C';
    if(temp==4)return 'R';
    if(temp==5)return 'P';
    if(temp==6)return 'Y';
    return 'W';
}

inline void set_square(int x,int y,int z)
{
    int X=0,Y=0;
    X+=(z-1)*8;
    X+=(n-1)*4;Y+=(n-1)*4;
    X-=(x-1)*4;Y-=(x-1)*4;
    Y+=(y-1)*8;
    MaxX=Max(MaxX,X+12);
    MaxY=Max(MaxY,Y+12);
    Str[X][Y]='+';Str[X][Y+8]='+';Str[X+4][Y+12]='+';
    Str[X+8][Y]='+';Str[X+8][Y+8]='+';Str[X+12][Y+4]='+';Str[X+12][Y+12]='+';

    for(int i=1;i&lt;=7;i++)
    {
        Str[X+i][Y]='|';
        Str[X+i][Y+8]='|';
        Str[X+i+4][Y+12]='|';
    }
    for(int i=1;i&lt;=7;i++)
    {
        Str[X][Y+i]='-';
        Str[X+8][Y+i]='-';
        Str[X+12][Y+i+4]='-';
    }
    for(int i=1;i&lt;=3;i++)
    {
        Str[X+8+i][Y+i]='/';
        Str[X+8+i][Y+8+i]='/';
        Str[X+i][Y+8+i]='/';
    }

    for(int i=1;i&lt;=7;i++)
    {
        Str[X+i][Y+i]='/';
        Str[X+8-i][Y+i]='\\';
    }
    Str[X+4][Y+4]='X';

    Str[X+9][Y+2]='.';Str[X+10][Y+5]='.';
    Str[X+11][Y+5]='\\';Str[X+10][Y+6]='*';Str[X+9][Y+7]='\\';
    Str[X+10][Y+7]='\'';Str[X+11][Y+10]='\'';

    Str[X+3][Y+9]='/';Str[X+4][Y+10]='\'';Str[X+5][Y+10]=':';
    Str[X+9][Y+11]='/';Str[X+8][Y+10]='.';Str[X+7][Y+10]=':';
    Str[X+7][Y+9]='\\';Str[X+6][Y+10]='*';Str[X+5][Y+11]='\\';

    char c1=calc_color(s[x][y][z][1]);
    for(int i=1;i&lt;=3;i++)
        for(int j=1;j&lt;=7-i*2;j++)
            Str[X+8-i][Y+i+j]=c1;
    char c2=calc_color(s[x][y][z][2]);
    for(int i=1;i&lt;=3;i++)
        for(int j=1;j&lt;=7-i*2;j++)
            Str[X+i+j][Y+i]=c2;
    char c3=calc_color(s[x][y][z][3]);
    for(int i=1;i&lt;=3;i++)
        for(int j=1;j&lt;=7-i*2;j++)
            Str[X+i][Y+i+j]=c3;
    char c4=calc_color(s[x][y][z][4]);
    for(int i=1;i&lt;=3;i++)
        for(int j=1;j&lt;=7-i*2;j++)
            Str[X+i+j][Y+8-i]=c4;
    char c5=calc_color(s[x][y][z][5]);
    for(int i=1;i&lt;=4;i++)
        Str[X+11][Y+5+i]=c5;
    char c6=calc_color(s[x][y][z][6]);
    Str[X+11][Y+4]=c6;Str[X+10][Y+3]=c6;Str[X+10][Y+4]=c6;
    char c7=calc_color(s[x][y][z][7]);
    for(int i=1;i&lt;=4;i++)
        Str[X+9][Y+2+i]=c7;
    char c8=calc_color(s[x][y][z][8]);
    Str[X+9][Y+8]=c8;Str[X+10][Y+8]=c8;Str[X+10][Y+9]=c8;
    char c9=calc_color(s[x][y][z][9]);
    for(int i=1;i&lt;=3;i++)
        Str[X+7+i][Y+8+i]=c9;
    char c10=calc_color(s[x][y][z][10]);
    for(int i=1;i&lt;=3;i++)
        Str[X+3+i][Y+9]=c10;
    char c11=calc_color(s[x][y][z][11]);
    for(int i=1;i&lt;=3;i++)
        Str[X+1+i][Y+8+i]=c11;
    char c12=calc_color(s[x][y][z][12]);
    for(int i=1;i&lt;=3;i++)
        Str[X+5+i][Y+11]=c12;
}

inline void print()
{
    for(int i=MaxX;i&gt;=0;i--)
    {
        for(int j=0;j&lt;=MaxY;j++)
            if(Str[i][j]==0)
                printf(" ");
            else
                printf("%c",Str[i][j]);
        printf("\n");
    }
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf("%d",&amp;Height[i][j]);

    int n1=1,n2=1;
    for(n1=1;n1&lt;=n;n1++)
    {
        bool flag=false;
        for(int i=1;i&lt;=m;i++)
            if(Height[n-n1+1][i])
            {
                flag=true;
                break;
            }
        if(flag)break;
    }
    if(n1&gt;n)return 0;
    n=n-n1+1;
    for(n2=1;n1&lt;=m;n2++)
    {
        bool flag=false;
        for(int i=1;i&lt;=n;i++)
            if(Height[i][n2])
            {
                flag=true;
                break;
            }
        if(flag)break;
    }
    if(n2&gt;m)return 0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m-n2+1;j++)
            Height[i][j]=Height[i][j+n2-1];
    m=m-n2+1;

    //printf("%d %d\n",n1,n2);

    scanf("%s",str[1]+1);
    scanf("%s",str[2]+1);
    scanf("%s",str[3]+1);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            for(int k=1;k&lt;=Height[i][j];k++)
                if(Height[i+1][j]&lt;k||Height[i][j+1]&lt;k||k==Height[i][j])
                    calc(i,j,k);

    for(int k=1;k&lt;=100;k++)
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
                if(k&lt;=Height[i][j])
                    if(Height[i+1][j]&lt;k||Height[i][j+1]&lt;k||k==Height[i][j])
                        set_square(i,j,k);

    print();
    /*
    for(int k=1;k&lt;=1;k++)
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
            {
                if(i==100)printf("%d %d\n",Height[i+1][j],k);
                if(k&lt;=Height[i][j])
                    if(Height[i+1][j]&lt;k||Height[i][j+1]&lt;k||k==Height[i][j])
                        printf("%d %d\n",i,j);
            }*/
    return 0;
}
/*
2 2
2 1
1 1
R**
***
**G
3 4
0 1 2 1
0 2 1 2
0 0 0 0
**B
***
R*G
*/
</pre><pre></pre><h2>Problem4088</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;

using namespace std;

int n,m,MaxX,MaxY;
int Height[102][102];
char str[5][5];
char Str[2010][2010];
set&lt;char&gt;s[101][101][101][13];

inline int Max(int a,int b)
{
    return a&gt;b?a:b;
}

inline void calc1_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    int c5=1,c6=1,c7=1,c8=1;
    for(int i=x-1,j=y-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)
    {
        if(Height[i][j]&gt;=z+x-i)return;
        if(Height[i+1][j]&gt;=z+x-i){c6=0;c7=0;}
        if(Height[i][j+1]&gt;=z+x-i){c5=0;c8=0;}
        if((c5|c6)==0)return;
        if(z+x-i&gt;=100)break;
    }
    if(c5)s[x][y][z][5].insert(str[1][1]);
    if(c6)s[x][y][z][6].insert(str[1][1]);
    if(c7)s[x][y][z][7].insert(str[1][1]);
    if(c8)s[x][y][z][8].insert(str[1][1]);
}
inline void calc1(int x,int y,int z)
{
    calc1_up(x,y,z);
}
inline void calc2_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    for(int i=x-1,j=y;i&gt;0;i--)
    {
        if(Height[i][j]&gt;=z+x-i)return;
        if(z+x-i&gt;=100)break;
    }
    s[x][y][z][5].insert(str[1][2]);
    s[x][y][z][6].insert(str[1][2]);
    s[x][y][z][7].insert(str[1][2]);
    s[x][y][z][8].insert(str[1][2]);
}
inline void calc2(int x,int y,int z)
{
    calc2_up(x,y,z);
}
inline void calc3_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    int c5=1,c6=1,c7=1,c8=1;
    for(int i=x-1,j=y+1;i&gt;=0&amp;&amp;j&lt;=m+1;i--,j++)
    {
        if(Height[i][j]&gt;=z+x-i)return;
        if(Height[i+1][j]&gt;=z+x-i){c7=0;c8=0;}
        if(Height[i][j-1]&gt;=z+x-i){c5=0;c6=0;}
        if((c5|c7)==0)return;
        if(z+x-i&gt;=100)break;
    }
    if(c5)s[x][y][z][5].insert(str[1][3]);
    if(c6)s[x][y][z][6].insert(str[1][3]);
    if(c7)s[x][y][z][7].insert(str[1][3]);
    if(c8)s[x][y][z][8].insert(str[1][3]);
}
inline void calc3_right(int x,int y,int z)
{
    if(Height[x][y+1]&gt;=z)return;

    int c9=1,c10=1,c11=1,c12=1;
    for(int i=x-1,j=y+1;i&gt;0&amp;&amp;j&lt;=m;i--,j++)
    {
        if(Height[i][j]&gt;=z+x-i)return;
        if(Height[i][j+1]&gt;=z+x-i)return;
        if(Height[i][j]==z+x-i-1){c11=0;c12=0;}
        if(z+x-i&gt;100)break;
    }
    if(c9)s[x][y][z][9].insert(str[1][3]);
    if(c10)s[x][y][z][10].insert(str[1][3]);
    if(c11)s[x][y][z][11].insert(str[1][3]);
    if(c12)s[x][y][z][12].insert(str[1][3]);
}
inline void calc3(int x,int y,int z)
{
    calc3_up(x,y,z);
    calc3_right(x,y,z);
}
inline void calc4_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    for(int i=x,j=y-1;j&gt;0;j--)
    {
        if(Height[i][j]&gt;=z+y-j)return;
        if(z+y-j&gt;=100)break;
    }
    s[x][y][z][5].insert(str[2][1]);
    s[x][y][z][6].insert(str[2][1]);
    s[x][y][z][7].insert(str[2][1]);
    s[x][y][z][8].insert(str[2][1]);
}
inline void calc4(int x,int y,int z)
{
    calc4_up(x,y,z);
}
inline void calc5_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    s[x][y][z][5].insert(str[2][2]);
    s[x][y][z][6].insert(str[2][2]);
    s[x][y][z][7].insert(str[2][2]);
    s[x][y][z][8].insert(str[2][2]);
}
inline void calc5(int x,int y,int z)
{
    calc5_up(x,y,z);
}
inline void calc6_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    for(int i=x,j=y+1;j&lt;=m;j++)
    {
        if(Height[i][j]&gt;=z+j-y)return;
        if(z+j-y&gt;=100)break;
    }
    s[x][y][z][5].insert(str[2][3]);
    s[x][y][z][6].insert(str[2][3]);
    s[x][y][z][7].insert(str[2][3]);
    s[x][y][z][8].insert(str[2][3]);
}
inline void calc6_right(int x,int y,int z)
{
    for(int i=x,j=y+1;j&lt;=m;j++)
    {
        if(Height[i][j]&gt;=z+j-y-1)return;
        if(z+j-y&gt;100)break;
    }
    s[x][y][z][9].insert(str[2][3]);
    s[x][y][z][10].insert(str[2][3]);
    s[x][y][z][11].insert(str[2][3]);
    s[x][y][z][12].insert(str[2][3]);
}
inline void calc6(int x,int y,int z)
{
    calc6_up(x,y,z);
    calc6_right(x,y,z);
}
inline void calc7_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    int c5=1,c6=1,c7=1,c8=1;
    for(int i=x+1,j=y-1;i&lt;=n+1&amp;&amp;j&gt;=0;i++,j--)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i-1][j]&gt;=z+i-x){c5=0;c6=0;}
        if(Height[i][j+1]&gt;=z+i-x){c7=0;c8=0;}
        if((c5|c7)==0)return;
        if(z+i-x&gt;=100)break;
    }
    if(c5)s[x][y][z][5].insert(str[3][1]);
    if(c6)s[x][y][z][6].insert(str[3][1]);
    if(c7)s[x][y][z][7].insert(str[3][1]);
    if(c8)s[x][y][z][8].insert(str[3][1]);
}
inline void calc7_forward(int x,int y,int z)
{
    if(Height[x+1][y]&gt;=z)return;

    int c1=1,c2=1,c3=1,c4=1;
    for(int i=x+1,j=y-1;i&lt;=n&amp;&amp;j&gt;0;i++,j--)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i+1][j]&gt;=z+i-x)return;
        if(Height[i][j]==z+i-x-1){c2=0;c3=0;}
        if(z+i-x&gt;100)break;
    }
    if(c1)s[x][y][z][1].insert(str[3][1]);
    if(c2)s[x][y][z][2].insert(str[3][1]);
    if(c3)s[x][y][z][3].insert(str[3][1]);
    if(c4)s[x][y][z][4].insert(str[3][1]);
}
inline void calc7(int x,int y,int z)
{
    calc7_up(x,y,z);
    calc7_forward(x,y,z);
}
inline void calc8_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    for(int i=x+1,j=y;i&lt;=n;i++)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(z+i-x&gt;=100)break;
    }
    s[x][y][z][5].insert(str[3][2]);
    s[x][y][z][6].insert(str[3][2]);
    s[x][y][z][7].insert(str[3][2]);
    s[x][y][z][8].insert(str[3][2]);
}
inline void calc8_forward(int x,int y,int z)
{
    for(int i=x+1,j=y;i&lt;=n;i++)
    {
        if(Height[i][j]&gt;=z+i-x-1)return;
        if(z+i-x&gt;100)break;
    }
    s[x][y][z][1].insert(str[3][2]);
    s[x][y][z][2].insert(str[3][2]);
    s[x][y][z][3].insert(str[3][2]);
    s[x][y][z][4].insert(str[3][2]);
}
inline void calc8(int x,int y,int z)
{
    calc8_up(x,y,z);
    calc8_forward(x,y,z);
}
inline void calc9_up(int x,int y,int z)
{
    if(z&lt;Height[x][y])return;

    int c5=1,c6=1,c7=1,c8=1;
    for(int i=x+1,j=y+1;i&lt;=n+1&amp;&amp;j&lt;=m+1;i++,j++)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i-1][j]&gt;=z+i-x){c5=0;c8=0;}
        if(Height[i][j-1]&gt;=z+i-x){c6=0;c7=0;}
        if((c5|c6)==0)return;
        if(z+i-x&gt;=100)break;
    }
    if(c5)s[x][y][z][5].insert(str[3][3]);
    if(c6)s[x][y][z][6].insert(str[3][3]);
    if(c7)s[x][y][z][7].insert(str[3][3]);
    if(c8)s[x][y][z][8].insert(str[3][3]);
}
inline void calc9_right(int x,int y,int z)
{
    if(Height[x][y+1]&gt;=z)return;

    int c9=1,c10=1,c11=1,c12=1;
    for(int i=x+1,j=y+1;i&lt;=n&amp;&amp;j&lt;=m;i++,j++)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i][j+1]&gt;=z+i-x)return;
        if(Height[i][j]==z+i-x-1){c10=0;c11=0;}
        if(z+i-x&gt;100)break;
    }
    if(c9)s[x][y][z][9].insert(str[3][3]);
    if(c10)s[x][y][z][10].insert(str[3][3]);
    if(c11)s[x][y][z][11].insert(str[3][3]);
    if(c12)s[x][y][z][12].insert(str[3][3]);
}
inline void calc9_forward(int x,int y,int z)
{
    if(Height[x+1][y]&gt;=z)return;

    int c1=1,c2=1,c3=1,c4=1;
    for(int i=x+1,j=y+1;i&lt;=n&amp;&amp;j&lt;=m;i++,j++)
    {
        if(Height[i][j]&gt;=z+i-x)return;
        if(Height[i+1][j]&gt;=z+i-x)return;
        if(Height[i][j]==z+i-x-1){c3=0;c4=0;}
        if(z+i-x&gt;100)break;
    }
    if(c1)s[x][y][z][1].insert(str[3][3]);
    if(c2)s[x][y][z][2].insert(str[3][3]);
    if(c3)s[x][y][z][3].insert(str[3][3]);
    if(c4)s[x][y][z][4].insert(str[3][3]);
}
inline void calc9(int x,int y,int z)
{
    calc9_up(x,y,z);
    calc9_right(x,y,z);
    calc9_forward(x,y,z);
}
inline void calc(int x,int y,int z)
{
    if(str[1][1]!='*')calc1(x,y,z);
    if(str[1][2]!='*')calc2(x,y,z);
    if(str[1][3]!='*')calc3(x,y,z);
    if(str[2][1]!='*')calc4(x,y,z);
    if(str[2][2]!='*')calc5(x,y,z);
    if(str[2][3]!='*')calc6(x,y,z);
    if(str[3][1]!='*')calc7(x,y,z);
    if(str[3][2]!='*')calc8(x,y,z);
    if(str[3][3]!='*')calc9(x,y,z);
}

inline char calc_color(set&lt;char&gt;S)
{
    if(S.empty())return 'K';
    int temp=0;
    for(set&lt;char&gt;::iterator it=S.begin();it!=S.end();it++)
        if(*it=='R')
            temp|=4;
        else
            if(*it=='G')
                temp|=2;
            else
                temp|=1;
    if(temp==1)return 'B';
    if(temp==2)return 'G';
    if(temp==3)return 'C';
    if(temp==4)return 'R';
    if(temp==5)return 'P';
    if(temp==6)return 'Y';
    return 'W';
}

inline void set_square(int x,int y,int z)
{
    int X=0,Y=0;
    X+=(z-1)*8;
    X+=(n-1)*4;Y+=(n-1)*4;
    X-=(x-1)*4;Y-=(x-1)*4;
    Y+=(y-1)*8;
    MaxX=Max(MaxX,X+12);
    MaxY=Max(MaxY,Y+12);
    Str[X][Y]='+';Str[X][Y+8]='+';Str[X+4][Y+12]='+';
    Str[X+8][Y]='+';Str[X+8][Y+8]='+';Str[X+12][Y+4]='+';Str[X+12][Y+12]='+';

    for(int i=1;i&lt;=7;i++)
    {
        Str[X+i][Y]='|';
        Str[X+i][Y+8]='|';
        Str[X+i+4][Y+12]='|';
    }
    for(int i=1;i&lt;=7;i++)
    {
        Str[X][Y+i]='-';
        Str[X+8][Y+i]='-';
        Str[X+12][Y+i+4]='-';
    }
    for(int i=1;i&lt;=3;i++)
    {
        Str[X+8+i][Y+i]='/';
        Str[X+8+i][Y+8+i]='/';
        Str[X+i][Y+8+i]='/';
    }

    for(int i=1;i&lt;=7;i++)
    {
        Str[X+i][Y+i]='/';
        Str[X+8-i][Y+i]='\\';
    }
    Str[X+4][Y+4]='X';

    Str[X+9][Y+2]='.';Str[X+10][Y+5]='.';
    Str[X+11][Y+5]='\\';Str[X+10][Y+6]='*';Str[X+9][Y+7]='\\';
    Str[X+10][Y+7]='\'';Str[X+11][Y+10]='\'';

    Str[X+3][Y+9]='/';Str[X+4][Y+10]='\'';Str[X+5][Y+10]=':';
    Str[X+9][Y+11]='/';Str[X+8][Y+10]='.';Str[X+7][Y+10]=':';
    Str[X+7][Y+9]='\\';Str[X+6][Y+10]='*';Str[X+5][Y+11]='\\';

    char c1=calc_color(s[x][y][z][1]);
    for(int i=1;i&lt;=3;i++)
        for(int j=1;j&lt;=7-i*2;j++)
            Str[X+8-i][Y+i+j]=c1;
    char c2=calc_color(s[x][y][z][2]);
    for(int i=1;i&lt;=3;i++)
        for(int j=1;j&lt;=7-i*2;j++)
            Str[X+i+j][Y+i]=c2;
    char c3=calc_color(s[x][y][z][3]);
    for(int i=1;i&lt;=3;i++)
        for(int j=1;j&lt;=7-i*2;j++)
            Str[X+i][Y+i+j]=c3;
    char c4=calc_color(s[x][y][z][4]);
    for(int i=1;i&lt;=3;i++)
        for(int j=1;j&lt;=7-i*2;j++)
            Str[X+i+j][Y+8-i]=c4;
    char c5=calc_color(s[x][y][z][5]);
    for(int i=1;i&lt;=4;i++)
        Str[X+11][Y+5+i]=c5;
    char c6=calc_color(s[x][y][z][6]);
    Str[X+11][Y+4]=c6;Str[X+10][Y+3]=c6;Str[X+10][Y+4]=c6;
    char c7=calc_color(s[x][y][z][7]);
    for(int i=1;i&lt;=4;i++)
        Str[X+9][Y+2+i]=c7;
    char c8=calc_color(s[x][y][z][8]);
    Str[X+9][Y+8]=c8;Str[X+10][Y+8]=c8;Str[X+10][Y+9]=c8;
    char c9=calc_color(s[x][y][z][9]);
    for(int i=1;i&lt;=3;i++)
        Str[X+7+i][Y+8+i]=c9;
    char c10=calc_color(s[x][y][z][10]);
    for(int i=1;i&lt;=3;i++)
        Str[X+3+i][Y+9]=c10;
    char c11=calc_color(s[x][y][z][11]);
    for(int i=1;i&lt;=3;i++)
        Str[X+1+i][Y+8+i]=c11;
    char c12=calc_color(s[x][y][z][12]);
    for(int i=1;i&lt;=3;i++)
        Str[X+5+i][Y+11]=c12;
}

inline void print()
{
    for(int i=MaxX;i&gt;=0;i--)
    {
        for(int j=0;j&lt;=MaxY;j++)
            if(Str[i][j]==0)
                printf(" ");
            else
                printf("%c",Str[i][j]);
        printf("\n");
    }
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf("%d",&amp;Height[i][j]);

    int n1=1,n2=1;
    for(n1=1;n1&lt;=n;n1++)
    {
        bool flag=false;
        for(int i=1;i&lt;=m;i++)
            if(Height[n-n1+1][i])
            {
                flag=true;
                break;
            }
        if(flag)break;
    }
    if(n1&gt;n)return 0;
    n=n-n1+1;
    for(n2=1;n1&lt;=m;n2++)
    {
        bool flag=false;
        for(int i=1;i&lt;=n;i++)
            if(Height[i][n2])
            {
                flag=true;
                break;
            }
        if(flag)break;
    }
    if(n2&gt;m)return 0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m-n2+1;j++)
            Height[i][j]=Height[i][j+n2-1];
    m=m-n2+1;

    scanf("%s",str[1]+1);
    scanf("%s",str[2]+1);
    scanf("%s",str[3]+1);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            for(int k=1;k&lt;=Height[i][j];k++)
                if(Height[i+1][j]&lt;k||Height[i][j+1]&lt;k||k==Height[i][j])
                    calc(i,j,k);

    for(int k=1;k&lt;=100;k++)
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
                if(k&lt;=Height[i][j])
                    if(Height[i+1][j]&lt;k||Height[i][j+1]&lt;k||k==Height[i][j])
                        set_square(i,j,k);

    print();

    return 0;
}
</pre><pre></pre><h2>Problem4103</h2><pre>#include&lt;cstdio&gt;

using namespace std;

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int n,m,siz;
int Num[32];
int num[1010][32];
int Rt1[1010],Rt2[1010];
int root[300010];
int ls[10000000],rs[10000000],val[10000000];
inline void modify(int&amp;y,int x,int p)
{
    y=++siz;
    ls[y]=ls[x];rs[y]=rs[x];
    val[y]=val[x]+1;
    if(p==31)return;
    if(Num[p]==0)
        modify(ls[y],ls[x],p+1);
    else
        modify(rs[y],rs[x],p+1);
}
inline int query(int l,int r,int K)
{
    int ans=0;
    for(int i=0;i&lt;31;i++)
    {
        int temp=0;
        for(int j=l;j&lt;=r;j++)
            if(num[j][i]==0)
                temp+=val[rs[Rt1[j]]]-val[rs[Rt2[j]]];
            else
                temp+=val[ls[Rt1[j]]]-val[ls[Rt2[j]]];
        if(K&lt;=temp)
        {
            ans+=(1&lt;&lt;(30-i));
            for(int j=l;j&lt;=r;j++)
                if(num[j][i]==0)
                {
                    Rt1[j]=rs[Rt1[j]];
                    Rt2[j]=rs[Rt2[j]];
                }
                else
                {
                    Rt1[j]=ls[Rt1[j]];
                    Rt2[j]=ls[Rt2[j]];
                }
        }
        else
        {
            K-=temp;
            for(int j=l;j&lt;=r;j++)
                if(num[j][i]==0)
                {
                    Rt1[j]=ls[Rt1[j]];
                    Rt2[j]=ls[Rt2[j]];
                }
                else
                {
                    Rt1[j]=rs[Rt1[j]];
                    Rt2[j]=rs[Rt2[j]];
                }
        }
    }
    return ans;
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=n;i++)
    {
        int x=read();
        for(int j=30;j&gt;=0;j--)
        {
            num[i][j]=x&amp;1;
            x&gt;&gt;=1;
        }
    }
    for(int i=1;i&lt;=m;i++)
    {
        int x=read();
        for(int j=30;j&gt;=0;j--)
        {
            Num[j]=x&amp;1;
            x&gt;&gt;=1;
        }
        modify(root[i],root[i-1],0);
    }
    for(int q=read();q;q--)
    {
        int lx=read(),rx,ly,ry,k;
        rx=read();ly=read();ry=read();k=read();
        for(int i=lx;i&lt;=rx;i++)
        {
            Rt1[i]=root[ry];
            Rt2[i]=root[ly-1];
        }
        printf("%d\n",query(lx,rx,k));
    }
    return 0;
}
</pre><pre></pre><h2>Problem4106</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;

using namespace std;

int p,a,b,c,d,n;

int main()
{
    while(scanf("%d%d%d%d%d%d",&amp;p,&amp;a,&amp;b,&amp;c,&amp;d,&amp;n)!=EOF)
    {
        double Max=(double)p*(sin(a+b)+cos(c+d)+2.0);
        double ans=0.0;
        for(int i=2;i&lt;=n;i++)
        {
            double temp=(double)p*(sin(a*i+b)+cos(c*i+d)+2.0);
            ans=max(ans,Max-temp);
            Max=max(Max,temp);
        }
        printf("%.6lf\n",ans);
    }
    return 0;
}
</pre><pre></pre><h2>Problem4128</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

using namespace std;

int n,P,line;
int c[110],c1[110];
int a[110][110],b[110][110];
int a1[110][110],a2[110][110],a3[110][110];

inline bool Check(int p)
{
	p--;
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		{
			a1[i][j]=a[i][j];
			a2[i][j]=a[i][j];
		}
	while(p)
	{
		if(p&amp;1)
		{
			memset(a3,0,sizeof(a3));
			for(int i=1;i&lt;=n;i++)
				for(int j=1;j&lt;=n;j++)
					for(int k=1;k&lt;=n;k++)
						a3[i][j]=(a3[i][j]+a1[i][k]*a2[k][j])%P;
			for(int i=1;i&lt;=n;i++)
				for(int j=1;j&lt;=n;j++)
					a1[i][j]=a3[i][j];
		}
		memset(a3,0,sizeof(a3));
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				for(int k=1;k&lt;=n;k++)
					a3[i][j]=(a3[i][j]+a2[i][k]*a2[k][j])%P;
		for(int i=1;i&lt;=n;i++)
			for(int j=1;j&lt;=n;j++)
				a2[i][j]=a3[i][j];
		p&gt;&gt;=1;
	}
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			if(b[i][j]!=a1[i][j])
				return false;
	return true;
}

inline bool check(int p)
{
	for(int i=1;i&lt;=n;i++)
		if(c[i]!=b[line][i])
			return false;
	return Check(p);
}

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}

int main()
{
	n=read();P=read();
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			a[i][j]=read();
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			b[i][j]=read();
	line=rand()%n+1;
	for(int i=1;i&lt;=n;i++)
		c[i]=a[line][i];
	
	for(int p=1;p&lt;=P;p++)
	{
		if(check(p))
		{
			printf("%d\n",p);
			return 0;
		}
		for(int i=1;i&lt;=n;i++)
		{
			c1[i]=0;
			for(int j=1;j&lt;=n;j++)
				c1[i]=(c1[i]+a[j][i]*c[j])%P;
		}
		for(int i=1;i&lt;=n;i++)
			c[i]=c1[i];
	}
	return 0;
}</pre><pre></pre><h2>Problem4143</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n,m;
int ma[25],mai[25];
int mi[25],mii[25];

inline int read()
{
    int c=getchar(),temp=0;
    while(c&lt;48||c&gt;57)c=getchar();
    while(c&gt;47&amp;&amp;c&lt;58)
    {
        temp=temp*10+c-48;
        c=getchar();
    }
    return temp;
}

int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=n;i++)
    {
        int a=read(),b,d;b=read();d=read();
        if(a&gt;ma[d]||ma[d]==0)
        {
            ma[d]=a;
            mai[d]=i;
        }
        if(b&lt;mi[d]||mi[d]==0)
        {
            mi[d]=b;
            mii[d]=i;
        }
    }
    for(int i=1;i&lt;=m;i++)
    {
        if(mi[i]&lt;ma[i]&amp;&amp;mai[i]&amp;&amp;mii[i]&amp;&amp;mii[i]!=mai[i])
            printf("TAK %d %d\n",mii[i],mai[i]);
        else
            printf("NIE\n");
    }
    return 0;
}
</pre><pre></pre><h2>Problem4145</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

int n,m,M;
int f[100010],g[100010],temp[100010],log[100010];
int c[20];

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}
inline int Min(int a,int b)
{
	return a&lt;b?a:b;
}
inline int lowbit(int x)
{
	return x&amp;-x;
}

int main()
{
	n=read();m=read();M=1&lt;&lt;m;
	for(int i=1,j=1;j&lt;=16;i&lt;&lt;=1,j++)
		log[i]=j;

	memset(f,127,sizeof(f));
	f[0]=0;
	for(int i=1;i&lt;=n;i++)
	{
		int dist=read();
		for(int j=1;j&lt;=m;j++)
			c[j]=read();
		
		memset(temp,127,sizeof(temp));
		temp[0]=dist;
		for(int j=1;j&lt;M;j++)
		{
			temp[j]=temp[j-lowbit(j)]+c[log[lowbit(j)]];
			if(temp[j]&lt;f[j])
				f[j]=temp[j];
		}
	}
	for(int i=1;i&lt;M;i++)
	{
		g[i]=f[i];
		for(int j=(i-1)&amp;i;j;j=(j-1)&amp;i)
			g[i]=Min(g[i],f[j]+g[i^j]);
	}
	printf("%d\n",g[M-1]);
	
	return 0;
}</pre><pre></pre><h2>Problem4146</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n;
int a[2000010],cnt[2000010];
long long ans,Ans[2000010];

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}

inline bool cmp(const int&amp;a,const int&amp;b)
{
	return a&gt;b;
}

int main()
{
	n=read();
	for(int i=1;i&lt;=n;i++)a[i]=read();
	sort(a+1,a+n+1,cmp);

	for(int i=1;i&lt;=n;i++)
	{
		if(a[i]==a[i-1])
			Ans[i]=Ans[i-1];
		else
			for(int j=1;a[i]*j&lt;=a[1];j++)
				Ans[i]+=cnt[a[i]*j];

		ans+=Ans[i];
		cnt[a[i]]++;
	}
	for(int i=a[n];i&lt;=a[1];i++)
		if(cnt[i])
			ans+=(long long)cnt[i]*(cnt[i]-1);
	
	printf("%lld\n",ans);	   
			
	return 0;
}</pre><pre></pre><h2>Problem4151</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int INF=1000000000;

int n,m;
int a[300010],b[300010],d[300010];
int fa[300010];
int dist[300010];
int dep[300010];

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}

int cnt,g[300010];
struct edge
{
	int t,next;
}e[600010];
inline void add_edge(int x,int y)
{
	e[++cnt].t=y;
	e[cnt].next=g[x];
	g[x]=cnt;
}

inline void dfs(int x)
{
	for(int i=g[x];i;i=e[i].next)
		if(e[i].t!=fa[x])
		{
			dep[e[i].t]=dep[x]+1;
			fa[e[i].t]=x;
			dfs(e[i].t);
		}
}

inline void dfs1(int x,int f)
{
	for(int i=g[x];i;i=e[i].next)
		if(e[i].t!=f)
		{
			dist[e[i].t]=dist[x]+1;
			dfs1(e[i].t,x);
		}
}
inline bool judge(int x)
{
	dist[x]=0;
	dfs1(x,x);
	for(int i=1;i&lt;=m;i++)
		if(dist[a[i]]+dist[b[i]]&gt;d[i])
			return false;
	return true;
}

int main()
{
	for(int T=read();T;T--)
	{
		n=read();m=read();
		memset(g,0,sizeof(g));
		cnt=0;
		for(int i=1;i&lt;n;i++)
		{
			int x=read(),y;y=read();
			add_edge(x,y);
			add_edge(y,x);
		}
		fa[1]=0;
		dfs(1);

		int D=-INF,id=0;
		for(int i=1;i&lt;=m;i++)
		{
			a[i]=read();b[i]=read();d[i]=read();
			if((dep[a[i]]+dep[b[i]]-d[i]+1)/2&gt;D)
			{
				D=(dep[a[i]]+dep[b[i]]-d[i]+1)/2;
				id=i;
			}
		}

		int ans=a[id];
		while(ans!=1&amp;&amp;dep[ans]&gt;D)ans=fa[ans];

		if(judge(ans))
			printf("TAK %d\n",ans);
		else
			printf("NIE\n");
	}
	return 0;
}</pre><pre></pre><h2>Problem4152</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m;
int cnt,siz;
int g[200010];
bool v[200010];
long long key[200010];
int num[200010],pl[200010];

struct edge
{
    int t,c,next;
}e[800010];
inline void add_edge(int x,int y,int z)
{
    e[++cnt].t=y;
    e[cnt].c=z;
    e[cnt].next=g[x];
    g[x]=cnt;
}
struct dot
{
	int x,y,id;
}d[200010];
inline bool cmp1(const dot&amp;a,const dot&amp;b)
{
	return a.x&lt;b.x;
}
inline bool cmp2(const dot&amp;a,const dot&amp;b)
{
	return a.y&lt;b.y;
}

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}

inline void Swap(int&amp;x,int&amp;y)
{
    x^=y^=x^=y;
}
inline void Swap(long long&amp;x,long long&amp;y)
{
    x^=y^=x^=y;
}


inline void up(int p)
{
    while(p&gt;&gt;1)
    {
        int x=p&gt;&gt;1;
        if(key[p]&gt;=key[x])return;
        Swap(key[x],key[p]);
        Swap(num[x],num[p]);
        Swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void down(int p)
{
    while((p&lt;&lt;1)&lt;=siz)
    {
        int x=p&lt;&lt;1;
        if(x&lt;siz&amp;&amp;key[x|1]&lt;key[x])x|=1;
        if(key[p]&lt;=key[x])return;
        Swap(key[x],key[p]);
        Swap(num[x],num[p]);
        Swap(pl[num[x]],pl[num[p]]);
        p=x;
    }
}
inline void ins(int p,long long v)
{
    key[++siz]=v;
    num[siz]=p;
    pl[p]=siz;
    up(siz);
}
inline void del(int p)
{
    key[p]=key[siz];
    num[p]=num[siz];
    pl[num[p]]=p;
    siz--;
    down(p);
}

inline long long dijkstra(int x)
{
    siz=1;
    key[1]=0;
    num[1]=x;
    pl[x]=1;

    while(siz)
    {
        int x=num[1];
        long long dist=key[1];
        if(x==1)return dist;
        v[x]=true;
        del(1);

        for(int i=g[x];i;i=e[i].next)
            if(!v[e[i].t])
                if(!pl[e[i].t])
                    ins(e[i].t,dist+e[i].c);
                else
                    if(dist+e[i].c&lt;key[pl[e[i].t]])
                    {
                        key[pl[e[i].t]]=dist+e[i].c;
                        up(pl[e[i].t]);
                    }
    }
}

int main()
{
	n=read();
	for(int i=1;i&lt;=n;i++)
	{
		d[i].x=read();d[i].y=read();
		d[i].id=i;
	}
	
	sort(d+1,d+n+1,cmp1);
	for(int i=2;i&lt;=n;i++)
	{
		add_edge(d[i-1].id,d[i].id,d[i].x-d[i-1].x);
		add_edge(d[i].id,d[i-1].id,d[i].x-d[i-1].x);
	}
	sort(d+1,d+n+1,cmp2);
	for(int i=2;i&lt;=n;i++)
	{
		add_edge(d[i-1].id,d[i].id,d[i].y-d[i-1].y);
		add_edge(d[i].id,d[i-1].id,d[i].y-d[i-1].y);
	}

	printf("%lld\n",dijkstra(n));
	return 0;
}
</pre><pre></pre><h2>Problem4177</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int inf=1000000000;

int n,m,K,cnt;
long long ans;

int g[10010];
int S,T;
int vh[10010],his[10010],di[10010],pre[10010],dis[10010];
struct edge
{
	int t,c,next;
}e[100010];
inline void add_edge(int x,int y,int z)
{
	e[++cnt].t=y;
	e[cnt].c=z;
	e[cnt].next=g[x];
	g[x]=cnt;
}

inline int read()
{
	int c=getchar(),temp=0;
	while(c&lt;48||c&gt;57)c=getchar();
	while(c&gt;47&amp;&amp;c&lt;58)
	{
		temp=temp*10+c-48;
		c=getchar();
	}
	return temp;
}
inline int Min(int a,int b)
{
	return a&lt;b?a:b;
}

inline long long isap()
{
	vh[0]=T;
	for(int i=1;i&lt;=T;i++)
		di[i]=g[i];
	int x=S,aug=inf;
	long long flow=0;
	
	while(dis[S]&lt;T)
	{
		bool flag=false;
		his[x]=aug;
		for(int i=di[x];i;i=e[i].next)
			if(e[i].c&amp;&amp;dis[e[i].t]+1==dis[x])
			{
				flag=true;
				di[x]=i;
				aug=Min(aug,e[i].c);
				pre[e[i].t]=i^1;
				x=e[i].t;
				
				if(x==T)
				{
					flow+=(long long)aug;
					while(x!=S)
					{
						e[pre[x]].c+=aug;
						e[pre[x]^1].c-=aug;
						x=e[pre[x]].t;
					}
					aug=inf;
				}
				break;
			}
		if(flag)continue;
		
		vh[dis[x]]--;
		if(vh[dis[x]]==0)break;
		
		int mi=T,mii;
		for(int i=g[x];i;i=e[i].next)
			if(e[i].c&amp;&amp;dis[e[i].t]&lt;mi)
			{
				mi=dis[e[i].t];
				mii=i;
			}
		dis[x]=mi+1;
		vh[dis[x]]++;
		di[x]=mii;
		
		if(x!=S)
		{
			x=e[pre[x]].t;
			aug=his[x];
		}
	}
	return flow;
}

int main()
{
	n=read();m=read();K=read();
	
	S=n+K+1;T=S+1;
	cnt=1;
	
	for(int i=1;i&lt;=n;i++)
	{
		int x=read();
		add_edge(S,i,x);
		add_edge(i,S,0);
		ans+=(long long)x;
	}
	for(int i=1;i&lt;=n;i++)
	{
		int x=read();
		add_edge(i,T,x);
		add_edge(T,i,0);
		ans+=(long long)x;
	}
	for(int i=1;i&lt;=m;i++)
	{
		int x=read(),y,z;y=read();z=read();
		add_edge(x,y,z);
		add_edge(y,x,z);
	}
	for(int i=1;i&lt;=K;i++)
	{
		int sum=read(),a,b;a=read();b=read();
		ans+=(long long)b;
		if(a==0)
		{
			add_edge(S,i+n,b);
			add_edge(i+n,S,0);
			for(;sum;sum--)
			{
				int temp=read();
				add_edge(i+n,temp,inf);
				add_edge(temp,i+n,0);
			}
		}
		else
		{
			add_edge(i+n,T,b);
			add_edge(T,i+n,0);
			for(;sum;sum--)
			{
				int temp=read();
				add_edge(temp,i+n,inf);
				add_edge(i+n,temp,0);
			}
		}
	}
	
	printf("%lld\n",ans-isap());
	
	return 0;
}</pre><pre></pre><h2>Problem4192</h2><pre>#include&lt;cstdio&gt;

using namespace std;

int n;
double x;
long double ans;

int main()
{
	scanf("%d%lf",&amp;n,&amp;x);
	
	if(n&lt;=3)
		printf("-1\n");
	else
	{
		ans=(long double)x;
		ans=(long double)ans*(n-1)/(n-3);
		printf("%.10lf\n",(double)ans);
	}
	return 0;
}
		</pre><pre></pre><h2>Problem4194</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,m,N;
long long A[200010];
struct Seg
{
	long long k,b;
	inline friend bool operator&lt;(const Seg&amp;a,const Seg&amp;b)
		{
			return a.k&lt;b.k||a.k==b.k&amp;&amp;a.b&gt;b.b;
		}
}seg[200010],line[200010],stck[200010];

inline bool judge(Seg a,Seg b,Seg c)
{
	return (long double)((long double)b.b-(long double)a.b)*((long double)a.k-(long double)c.k)
		 &gt;=(long double)((long double)c.b-(long double)a.b)*((long double)a.k-(long double)b.k);
}

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		scanf("%lld",A+i);
	
	seg[1].k=0;
	seg[1].b=0;
	for(int i=2;i&lt;=m;i++)
	{
		int K,B;
		scanf("%d%d",&amp;K,&amp;B);
		seg[i].k=(long long)seg[i-1].k-K;
		seg[i].b=(long long)seg[i-1].b-B;
	}
	
	sort(seg+1,seg+m+1);
	
	line[N=1]=seg[1];
	for(int i=2;i&lt;=m;i++)
		if(seg[i].k!=seg[i-1].k)
			line[++N]=seg[i];
	
	int h=0;
	for(int i=1;i&lt;=N;i++)
	{
		while(h&gt;1&amp;&amp;judge(stck[h-1],stck[h],line[i]))
			h--;
		stck[++h]=line[i];
	}
	
	int H=1;
	for(int i=1;i&lt;=n;i++)
	{
		while(H&lt;h&amp;&amp;(stck[H+1].b-stck[H].b)&gt;(long long)i*(stck[H].k-stck[H+1].k))
			H++;
		
		long long ans=(long long)stck[H].k*i+stck[H].b;
		ans=(long long)A[i]-ans;
		printf("%lld\n",ans);
	}
		
	return 0;
}</pre><pre></pre><h2>Problem4195</h2><pre>#include&lt;cstdio&gt;

using namespace std;

const int MAXSIZE=20000020;
const int P=5000011;

int bufpos=0;
char buf[MAXSIZE];
inline void init()
{
    buf[fread(buf,1,MAXSIZE,stdin)]='\0';
}
inline int read()
{
    int val=0;
    for(;buf[bufpos]&lt;48||buf[bufpos]&gt;57;bufpos++);
    for(;buf[bufpos]&gt;47&amp;&amp;buf[bufpos]&lt;58;bufpos++)
        val=val*10+buf[bufpos]-48;
    return val;
}

int n,cnt,N;
int fa[200010],rnk[200010];
struct Query
{
    int x,y,e,x1,y1;
}q[100010];
int g[6000010];
struct Hash
{
    int val,id,next;
}e[300010];

inline int Find(int x)
{
    int X=x%P;
    for(int i=g[X];i;i=e[i].next)
        if(e[i].val==x)
            return e[i].id;

    e[++cnt].val=x;
    e[cnt].id=++N;
    e[cnt].next=g[X];
    g[X]=cnt;

    return N;
}

inline int find(int x)
{
    return x==fa[x]?x:fa[x]=find(fa[x]);
}
inline void unio(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(rnk[fx]&lt;rnk[fy])
        fa[fx]=fy;
    else
    {
        fa[fy]=fx;
        if(rnk[fx]==rnk[fy])rnk[fx]++;
    }
}

int main()
{
    init();

    for(int T=read();T;T--)
    {
        n=read();cnt=0;N=0;
        for(int i=1;i&lt;=n;i++)
        {
            q[i].x=read();q[i].y=read();q[i].e=read();

            q[i].x1=Find(q[i].x);q[i].y1=Find(q[i].y);
        }

        for(int i=1;i&lt;=N;i++)
        {
            fa[i]=i;rnk[i]=0;
        }
        for(int i=1;i&lt;=n;i++)
            if(q[i].e==1)
                if(find(q[i].x1)!=find(q[i].y1))
                    unio(q[i].x1,q[i].y1);
        bool flag=true;
        for(int i=1;i&lt;=n;i++)
            if(q[i].e==0)
                if(find(q[i].x1)==find(q[i].y1))
                {
                    flag=false;
                    break;
                }

        for(int i=1;i&lt;=n;i++)
        {
            g[q[i].x%P]=0;
            g[q[i].y%P]=0;
        }

        if(flag)
            printf("YES\n");
        else
            printf("NO\n");
    }

    return 0;
}
</pre><pre></pre><h2>Problem4196</h2><pre>#include&lt;cstdio&gt;

int n,cnt;
int g[100010],fa[100010];
int siz[100010],Ma[100010],dep[100010];
int idx;
int S[100010],T[100010],root[100010];
struct edge
{
    int t,next;
}e[100010];
inline void add_edge(int x,int y)
{
    e[++cnt].t=y;
    e[cnt].next=g[x];
    g[x]=cnt;
}

const int MAXSIZE=5000020;
int bufpos=0;
char buf[MAXSIZE];
inline void init()
{
    buf[fread(buf,1,MAXSIZE,stdin)]='\0';
}
inline int read()
{
    int temp=0;
    for(;buf[bufpos]&lt;48||buf[bufpos]&gt;57;bufpos++);
    for(;buf[bufpos]&gt;47&amp;&amp;buf[bufpos]&lt;58;bufpos++)
        temp=temp*10+buf[bufpos]-48;
    return temp;
}
inline char read_s()
{
    for(;buf[bufpos]!='i'&amp;&amp;buf[bufpos]!='u';bufpos++);
    return buf[bufpos++];
}

inline void dfs(int x)
{
    siz[x]=1;Ma[x]=0;
    for(int i=g[x];i;i=e[i].next)
    {
        dep[e[i].t]=dep[x]+1;
        dfs(e[i].t);
        siz[x]+=siz[e[i].t];
        if(siz[e[i].t]&gt;siz[Ma[x]])
            Ma[x]=e[i].t;
    }
}
inline void dfs1(int x,int Rt)
{
    root[x]=Rt;
    S[x]=++idx;
    if(Ma[x])dfs1(Ma[x],Rt);
    for(int i=g[x];i;i=e[i].next)
        if(e[i].t!=Ma[x])
            dfs1(e[i].t,e[i].t);
    T[x]=idx;
}

struct seg
{
    int l,r,sum;
    int tag,num;
}seg[800010];
inline void build(int p,int l,int r)
{
    seg[p].l=l;seg[p].r=r;seg[p].num=r-l+1;
    if(l==r)return;
    int mid=(l+r)&gt;&gt;1;
    build(p&lt;&lt;1,l,mid);
    build(p&lt;&lt;1|1,mid+1,r);
}
inline void push_down(int p)
{
    if(seg[p].tag==2)
    {
        seg[p&lt;&lt;1].sum=seg[p&lt;&lt;1].num;
        seg[p&lt;&lt;1|1].sum=seg[p&lt;&lt;1|1].num;
        seg[p&lt;&lt;1].tag=2;
        seg[p&lt;&lt;1|1].tag=2;
        seg[p].tag=0;
    }
    else
        if(seg[p].tag==1)
        {
            seg[p&lt;&lt;1].sum=0;
            seg[p&lt;&lt;1|1].sum=0;
            seg[p&lt;&lt;1].tag=1;
            seg[p&lt;&lt;1|1].tag=1;
            seg[p].tag=0;
        }
}
inline int modify(int p,int l,int r,int val)
{
    if(val==1&amp;&amp;seg[p].sum==0)return 0;
    if(val==2&amp;&amp;seg[p].sum==seg[p].num)return r-l+1;
    if(l&lt;=seg[p].l&amp;&amp;seg[p].r&lt;=r)
    {
        int temp=seg[p].sum;
        if(val==2)
        {
            seg[p].sum=seg[p].num;
            seg[p].tag=2;
        }
        else
        {
            seg[p].sum=0;
            seg[p].tag=1;
        }
        return temp;
    }

    push_down(p);

    int mid=(seg[p].l+seg[p].r)&gt;&gt;1,temp=0;
    if(r&lt;=mid)
        temp=modify(p&lt;&lt;1,l,r,val);
    else
        if(l&gt;mid)
            temp=modify(p&lt;&lt;1|1,l,r,val);
        else
            temp=modify(p&lt;&lt;1,l,mid,val)+modify(p&lt;&lt;1|1,mid+1,r,val);
    seg[p].sum=seg[p&lt;&lt;1].sum+seg[p&lt;&lt;1|1].sum;

    return temp;
}

inline int Modify1(int x)
{
    int temp=0;
    while(x)
    {
        temp+=modify(1,S[root[x]],S[x],2);
        x=fa[root[x]];
    }
    return temp;
}
inline int Modify2(int x)
{
    return modify(1,S[x],T[x],1);
}

int main()
{
    init();
    n=read();
    for(int i=2;i&lt;=n;i++)
    {
        fa[i]=read()+1;
        add_edge(fa[i],i);
    }

    fa[1]=0;
    dep[1]=1;
    dfs(1);
    dfs1(1,1);
    build(1,1,idx);

    for(int q=read();q;q--)
    {
        char opt=read_s();
        int x=read()+1;

        if(opt=='i')
            printf("%d\n",dep[x]-Modify1(x));
        else
            printf("%d\n",Modify2(x));
    }

    return 0;
}
</pre><pre></pre><h2>Problem4197</h2><pre>#include&lt;cstdio&gt;
#include&lt;string&gt;

using namespace std;

const string a[510]={"","","3","9","21","63","111","333","693","1521","2577","7731","13491","40473","67833","119241","239481","718443","1340523","4021569","7494849","13356657","22271409","66814227","130266387","268286823","447212583","896472063","1684872063","5054616189","9566769789","28700309367","57402497367","103063130487","171773991927","326921556519","651050119719","1953150359157","3255261517557","5854273719957","11544594999957","34633784999871","68043362779071","204130088337213","385476702206013","765666552801213","1276111212062013","3828333636186039","7653813600858039","15426112303997307","30751409618045307","55348756823292507","104542969320463707","313628907961391121","627190710994376721","1215877099424885793","2403676629782722593","4326543501175774593","7210905862371022593","21632717587113067779","43224392237632210179","129673176712896630537","216121961431863635337","429725067784738403337","859450136228858507337","1667732363766383170617","3284766789617304130617","9854300368851912391851","18613652037848930695851","33504525481916674061451","66797515486053275251851","200392546458159825755553","400784170134523662376353","1202352510403570987129059","2003920850707597156556259","4007345123381801950316259","7569428075550831946412259","15001439281183154039611923","29548006591226959948603923","88644019773680879845811769","177278536337272251180467769","354557076250730087921981769","590928460418619368770397769","1772785381255858106311193307","3542848189889414705095193307","6877144893403869981205952907","11461908155677062278648672907","20631433819144528611561800907","41102168262042930001655240907","123306504786128790004965722721","246609193203124991914418522721","489249510372185967717815318481","924137953907975347903777238481","1663448297790056032640173982481","2772413829650154013728774206481","5381712202540906626385699462401","10763424206815520235919958662401","32290272620446560707759875987203","64567840118673676609554561427203","128884127769710482099251358147203","257767148957780900852380103107203","773301446873342702557140309321609","1523169007537728496130428982601609","4569507022613185488391286947804827","9103549529870072403342070614364827","18205335100958587172789165455708827","30342225168264322936003388047228827","91026675504792968808010164141686481","182053350799621564482841634733686481","546160052398864693448524904201059443","1091253780734211479556856529877859443","1964256804856300205395248837806635443","3928328224604364829554394951583275443","11784984673813094488663184854749826329","23212846840709458127737815162425986329","45060215702845864150098050572173849129","85113740766566115182955032355518169129","169896202489178999178907537636530441129","283160337481965000348980153993221161129","561951889840797938220852709735190364729","1123903498112724422757085712005910364729","2248903514741926652840256399360165788901","3748172524569877761280421625528892988901","6746710544111565234392571929004605972901","12743786583190909482570347937231826772901","25487573972420878895185616161825823599101","50974524368546959789751461876163615599101","152923573105640879369254385628490846797303","305847146211281758836726613294252819197303","550524863177272503697423120276885223637303","1099976342118144449833570020962268494037303","3299929026354433349500710062886805482111909","6595030973817753101201894612313754479231909","13088524404796188554638440347337364591423989","21814207341326980925013008684677681117183989","43628411738159804553496386057874589245183989","86918605862851604976763375142877595856383989","260755817588554814930290125428632787569151967","513609941332647158249979696062444752292351967","1540829823997941474749939088187334256877055901","3081649988560951172513273797611322009837055901","5546969979407156412417597580332182950720055901","9244949965678594020714425185022326806510455901","18474138153333713295794524653724411338404118957","36948276306638714675664049250184854675108118957","71723123685538161977521466559842250266712676557","119538539475896936629266367278649648264387876557","239076709652273128555301307908444207903544676557","451589340454267243169601998228435679674280676557","1354768021362801729508805994685307039022842029671","2709536018664505244020615656629253157453562029671","8128608055993515732061846969887759472360686089013","16194203063294657021285371688180080814039502089013","32325393077894943697632050238517934623091882489013","64638867838204291637872577038186507605666986489013","125475448882906380824317517329943540838790685573013","250889589098348948395439186415210926882256413573013","752668767295046845186317559245632780646769240719039","1254447945491744741977207940967190592312417872719039","2258006301885124646568722733211793011598472335559039","4516012592494067282751928879877472823864089743559039","8962544894078443215782986235581094634501026004388239","17925089788156678787290260559762763084339851476388239","53775269364470036361870781679288289253019554429164717","101575508799554314136944231029796121867163738829164717","203132392915489389886796134014114487594101346611564717","338553988192482316477993780322547148826405024427564717","1015661964577446949433981340967641446479215073282694151","2031323533054112521989963396194971824540625541122694151","4063142919074962524830020657045087818736762375122635163","8118365467188148189755021234648943793582921632722635163","16205141926242357087599636710770141475781813396455835163","30609712527346668188106270678472411302754045593175835163","91829137582040004564318812035417233908262136779527505489","180875574017688664075618913339993178630474412921607505489","361751113289911114230387884473981715039626312642902004689","723469055053604914958146199778718071773859057656022004689","1302244299096488701212054201481178319082329547715511004689","2170407165160814502020090362018662177580689906150831004689","6511221495482443506060271086055986532742069718452493014067","13022442989165115784598975482573641305122420526516493014067","39067328967495347353796926447720923915367261579549479042201","78120349569598421365210498105562633551050453277612839042201","140616629225277152390288235298620382234927910604425046042201","280143206748907761548305032892895910115433013301480374042201","543807401305433425817127500940087873353556898328091587199801","1071135790444204275479680271198827931740890476325116867199801","2141177674201115457132327711979474596139002924611474606087433","4044446717935440264018004709842733256090502682623759646087433","8088893247370729958194179109720164521863465534728668654087433","16162018668776570664786508366162235526565643631498200558087433","48486056006329711994359525098486706579696930894494601674262299","96972112012659422756575383505553823630763448555152642506262299","290916336037978268269726150516661470892290345665457927518786897","484860560063297113782876917552707983825109284851578603590786897","969632346444064202832200230533374088383786874756921294918786897","1939264670449841386492827386399969138077846394816233768518786897","5817794011349524159478482159199907414233539184448701305556360691","11635454399754079225731501246131157096270029570508459446996360691","34906363199262237677194503738393471288810088711525378340989082073","69812726397888509044101622273949701269392218087601880049789082073","125662907516199316191401534272703632854046542040378893046606082073","209438179193665526985669223788578691984438056000784106377190082073","415654230266388087619819513544883057014980118135328941097082812873","831105588708584650580890462463638688209771007508232427356282812873","1613322613369604294604075093291167855672270690200900233005756112873","2688871022282673824340125155487793047995910658775793428570916112873","5367279511017925065799937152132383731163133960215441129030470112873","10734067652228602241522585638580917021366087125611433205225670112873","21457540427229785796981805427847397398665815957031942825355186416793","42915080726371155497001029849338254660123391062425382102411186416793","128745242179113466491003089548014763980370173187276146307233559250379","243185457449436547805583075637299489267791855643681100971985159250379","437733823408985786029026188665891105469022556014990974563451488250379","729556372348309643381710314443199741926931865894739827613691208250379","1416197663968766873979465462282943933765424701583961067738044529982379","2832395327937533747745190382071607310705430125979070757288482929982379","5621215335162381849156472858623943805168474632893530578823093178183579","9368692225270636415260788097706735854869111908046574996003114578183579","16863646005487145547208611756887385267993257305937346744175020681183579","33727195048946571321655505637716389215892732474847556123432569481183579","67444615303362850754367783412744510448352420222225804514739790271893963","132845454385405240388147566174278651052082044453473392837602484671893963","398536363156215721164442698522835953156246133360420178512807454015681889","797072725689957624178695362157840175411451422710374296898543313215681889","1594145451379397018930867036391180307453089825962324021709112974335681889","2656909085632328364884778393985303725710757182090888376783463502135681889","7970727256896985094654335181955911177132271546272665130350390506407045667","15937564386045256625367316894982112149365019565091051024239799530407045667","47812693158135769876101950684946336448095058695273153072719398591221137001","95532184184897184622360190555873074143627429611072963862850668223221137001","191064094314044777207994854163227645880158357996418148931433525362421137001","380647071614495540792088182071784461537879476182766855902372039054421137001","1141941214843486622376264546215353384613638428548300567707116117163263411003","2283856272950230011266661739643457466736703922818914051158759447723263411003","4433368059256034075912804073328212736346411058671987470909755781098451215003","8374139667483619921166676857167172051909279367101788194519358721244451215003","15073451401470515858096191188706314060395021163382692862125685077053548215003","30145062850875447088923445027601450761863581661369610779839246980157548215003","90435188552626341266770335082804352285590744984108832339517740940472644645009","180870377105244327068600033117310505100636235266827278487030631759032644645009","542611131315732981205800099351931515301908705800481835461091895277097933935027","1085221484880205730108730292493852901512338423583594345802025713420323533935027","2170442969760411460217462628440760698285086293935250752441470030041660216435027","4099725609547443869299344291198062936211062477506911740771115257513862216435027","8199451218318673945394156423169307205774682190542572422505414649222620137875027","16150434217900392585762436806937706335685476683453353830997645542856156137875027","32296741671728649301158566912098115986001951221559000414774310898136390863473123","64343121004775674890656096411091590536870128580777623081670794747567732463473123","115817617808596214803176404679551164369266120234868522214921026529850196333473123","231635235617189992886980363622332259568969185288964584008102037076343021933473123","694905706851569978660941090866996778706907555866893752024306111229029065800419369","1389811413638948996983670831116764629645482978737225810733710962372135953480419369","2778265922013946419095547105963220119595063408246942842543136750771929169901813241","4630443203356577365159245176605366866356013483954534410003886727132023434741813241","9260603793247780683398183820604455922824040966641738555555452938009387965941813241","18521207586495561366796367641208911846736463066425533232930043269495029068041813241","55563622759486684100389102923626735540209389199276599698790129808485087204125439723","109443499374746459205026705260219029008174476091367625271108043593127943754525439723","217203252600510576674816235323739991386140037670497324373891346181862237110224553723","434405261158020526703023493549764436904087769068957873387136545217130518249424553723","867120229470820244253325597664103421734201575038620389105555983742989380384524553723","1445200382451367073755542662773505702898317332708408804855485247745793765532124553723","4335601147354101221266627988320517108694951998125226414566455743237381296596373661169","8671200737861730324399227678898586674799895935871486490261914698262945599956373661169","16832330844084519039976847029379113172656175394160197118839358934628546922954332425169","33662607171111269422533369838064285199270430966336659735800880722256572942794332425169","60592692908000284960560015640279014308259457991894129104524426097698709515516762425169","114452864381778316036613307042195296478552314566495555503533673741275641783560762425169","343358593145334948109839921126585889435656943699486666510601021223826925350682287275507","686717186290669433670482919086482729153212898188976796194271229047658660032282287275507","2060151558872008301011448757259448187459638694566930388582813687142975980096846861826521","4120240247615564139848272580538379368706443413711212245202187817550101996573438861826521","8240468701408191471923458021076456665661115705373594141020608871885448031060478861826521","13734114502346985786539096701794094442769817109342500571296559096889840187461082461826521","27468226540046695540378334053564991862757656224017115281071654001162365796824476835346521","54923047398251780652358080042682545781065228756632564873806770709346675331380636835346521","164769142194755341957074240128047637343195686269897694621420312128040025994141910506039563","274615236991258903261790400213412728905333886013654941666142746033769303787621024506039563","548161932204302956070825753803915144247215438225188786287383701619025894530772098606039563","1096323864405382004550734219964754600123813884454455510591000703208213647705402498606039563","3288971593216146013652202659894263800371441653363366531773002109624640943116207495818118689","6478277380577257224891781681641578275814400382783544084234272626420543811692217735818118689","19434832141731771674675345044924734827443201148350632252702817879261631435076653207454356067","36710238489937790941053429029019690619604499854157381072342299253499570289130380747454356067","73418236479912017959440677697326299356424048858760775121213178138460377749597773976254356067","146836361327707700205468144917634708735709156097626525736794584336340025747616702616254356067","291413701711504696658867275402756731619786824722360045861917559925347214147777090882181898067","582827403423009393317734541700054059999632470785367669892835827942260368774923965762181898067","1165663699957489164020629910822082854438155181207953205707868578013310391026744072900600702183","2329055150987164402747185323563196449729054021371938512862870156266867646947386366660600702183","4192299271776895924944933568588259486796381371846892137003191938054710889485506693979250702183","7918787513356358969340430058583805803164598189842133829789285989124985730678851789351250702183","23756362540069076908021290175751417409493794569526401489367857967374957192036555368053752106549","47512725080101766975028400023090328833266204318296404593065113343231252295092240590453752106549","92230583979021075634242337093844322080992605659744945981352721807720554867298394104807792182549","183746202190759674859607409443172524602330133389870764729579826540307920473703582917487792182549","367492396152219810070745312074916458280251613751626135733701405262044949793559629022790592182549","612487326920366350117908853458194097133752707941170550078717304045852885877334623524076592182549","1224824719455903815523586939637212293483714790545213392369681677104682135864042733115091669150917","2449649438911807605092210975489605437636394706986202500272033991409872648110402059835091669150917","4861611963377088707496834374014779558450313582551135157801059031429744084336188305061079332928917","8102686605628481179161390623357965930750522706342281578476764852810696218376665116740609332928917","14584835890131266122490503118998009376169009388884018340589874942839440275240992192539324182928917","29169226698904739815554738995153318971689725548664434949959498459422814791992691328391884182928917","56622616533168024106370027094110857851359453938143738212117441937490337186565577731805616358820917","113243937104910515467551381972061315559672764171010737735393428313224050985373717982941616358820917","339731811314731546402654145916183946679018292513032213206180284939672152956121153948824849076462751","679463615028704411987363503779270005981259535615242999347480883335180933673053868064716049076462751","1223034507051667941577254306714519236459037748686241137069816997010802895251179101614853596926462751","2443684931243583181137549898633356742037655528576900301877679144641629415126742416929279452926462751","7331054793730749543412649695900070226112966585730700905633037433924888245380227250787838358779388253","14662106963255643378389084257089983360612823924768770100981702661852158689919538526342736278779388253","43986320889766930135167252771269950081838471774306310302945107985556476069758615579028208836338164759","73310534816278216891945421285449916803064119633126052919343622503606836320532340053901307942338164759","146621069632542159694284009707669312459827584090031472469691104209917540059046245827218403366338164759","276950909305912968311425351667240428282827137509502499730763425910424783609417865571051539946338164759","830852727917738904934276055001721284848481412528507499192290277731274350828253596713154619839014494277","1636528100444031176218392351043796067250195143814617273444954014880088889484771919454258440639014494277","3271459569866097140480813580334439217642044602832241886388668896606716251953081324397517005148317734549","6542919139732194276472422159702374820257100793422884382543522482260451902875017862054698824028317734549","11777254451517949697650359887399586966161415998654241760384424710173458028616841249451996277927567734549","23553071423697884036557299417167347101464990662528746013593068676663609632008432061297355730087567734549","47105513935537998681018533606941305092178266613132301288098372902374742586486030468393102318285407055333","94211027871075997362037067212984740460190210855597045492987727457004470442103034900179977607885407055333","188422038888144238506025158343701760204411704301395108544108394617648603864121361934262657214783421695333","314036731480240397510041930572836267007352840503052612798004552925344046757178451165754011860241421695333","565266116664432715518075475029909402909792297263266495246250526647691633661677782770154771982238171695333","1126150325447744540905874187580745433299563437323484751381709516971042928279499004902102589193350171695333","2234975261273165664197306393653937021866392913305028896649218817766434959968925987028327383886896765213333","4469950510013048747326212025674162789768974348423258695715007868098838666016041334293895339240496765213333","13409851530039146241978636077022488369306923045269776087145023604296515998048124002881686017721490295639999","25329719556740609568181868145472841775270360405088993629502239725006788923602993849430414821917886295639999","50560879893416065818137059585593682091986286465692299355970201386051540834005336673882794309718290795639999","84268133155693443030228432642656136819977144109500501837801115527179671832651459851804469473221844795639999","163579317302228448224199756972483786992357792122793330680020305908795451418100634495294008176582218234715999","327158634604452879670481694967340807599551034062346375438810333844581322273661486479209366427180618234715999","981475903813358639011445084902022422798653102187039126316431001533743966820984459437628099281541854704147997","1962951719835490076037995382590830765750231611207322375312579822863125739977104213366142864572975134704147997","3533313095703882136868391688662985882631333633030151115601008199136541513361334362848104609763477508954147997","7066605972762471284974858701549236418597297295947656927236720727631731793466963816263624633658034180954147997","14126317676052486996427075086464824638635285497030814543876245740460336997071834582309779746707186695187567437","28252527575692087571160347718413990037195677429567379244582469162727606058030731625253316100709393415187567437","56505055151384277794764870628532293209958092770017286970700279185592980768945809217484614572266131315121362437","112572086619424458996113479059230476555459241542824812691393833392250945845548904423833579552412085131121362437","225137302801284612151510153155013549329168270089625344763928997668416650099688682006337454146083352971121362437","375228838002141020252516921925022582215280450149376516546079064145913109240141770642474336807532642925121362437","1125686514006423060757550765775067746645841350448129549638237192437739327720425311927423010422597928775364087311","2250823644643403249922794419212216974527800737445149943262686703022812453183077247656974588168841512775364087311","6752470933930209749768383257636650923583402212335449829788060109068437359549231742970923764506524538326092261933","13504941867860326686373209708954372739920373323491646546834263082207985595771330987522420378078903162326092261933","27009883131863584077910329461072413609019330788561162264429334330768925385140120241834261850662632051676092261933","54019766225810954040996068181443292223272795575785234894529133230941251519408508213213939514313848109916092261933","162059298677432862122988204544329876669818386727355704683587399692823754558225524639641818542941544329748276785799","319207709516155637514727791784111902664949175505760815358398644318739559615181613257964332403971727241748276785799","619638494943125649290566265430571961080602885862465044412953258081870613226720880134219448249413326268350750685799","1170428268225904004215514056924411076975948770767565529401786736195945538816573212243243088920174402839210750685799","2340853187757991742576784974875118024988933760204856099333936169750745804384388686442219834998086002124970750685799","3901421979596652904294641624791863374981556267008093681696612175032244624306466580255588325396996457308300750685799","11704265938789958712883924874375590124944668801024281045089836525096733872919399740766764976190989371924902252057397","23408531877579917425696318437964764479093710844799934824876670618488253497195155868843158036601274468884902252057397","46817153051411537715404088736238199356782086964524431252297870807077252362789125068530899468432980317360966600231681","78028588419019229525673481227063665594636811607540719851740949113129693580471034713484859412366249146744116600231681","156057176783270820310085328118574485870535279765572651705750955447173155993482506301547777168563272804351416600231681","312114350077603609493775669813018826084009371809387330285862772506009754230780493721135582919297988093951416600231681","605869032503583477251846850917627361136105266859075277632333956195722756413967676410409870254008737827993800877931681","1193378397355543212768644569695077995243363045364558586667214783314737887815566635915823123372417314032793800877931681","3580135192066629638305933709085233985730089136093675760001644349944213663446699907747469370117251942098381402633795043","7160161130404020704666030666922122155482704934650519263536139501800043629845000415816708491977418245675847402633795043","14292461711662500214391880575669346411889271713321163724503262574005758051736572710560043328957624697124247269133795043","28557062874179459233820487288772100903008734926017408194629251325309090129452256148899679939083548245882263269133795043","56674786319525342471024622764082742547289169290550577164875055094972951190870374064300181843002592057295127640392695043","113321912909209301024250139345896474246633871190645061507665523557793482310333134167668151302445437246701847640392695043","339965738727627903072750418037689422739901613571935184522996570673380446930999402503004453907336311740105542921178085129","679930990999245336229822463663677708953432693584919729014349041204949024674027474277668513493190055927182150921178085129","1359861981998490672459110743113901575961622021133276607080531613634783396950079720034184139993837020971867553321178085129","2709182398245055011769202187329753501099287781797205277587214693872290842739132389775535720539537979938458592321178085129","5417703506191685424080047765504197894011017557998377126453974037368372909670428718829950128870233417172429359121435116409","10835407012383366179234171488744844135461099214831766131249032518385648392813214618769332481700184570059336239121435116409","32506221037150098537702514466234532406383297644495298393747097555156945178439643856307997445100553710178008717364305349227","65012256072664798045916649740205389410974312149287123194888646851877427209453626484970271405864381992985558669364305349227","117022060930796636482649969532369700038519157717472069445470229211171068228298356324593751636405242016247522686356055349227","195036768217994394137749949220616166730865262862453449078371972077672378274069749646567679534744538132705127513706055349227","585110304653983182413249847661848500192595788587360347235115916233017134822209248939703038604233614398115382541118166047681","1170220609307966364826499695323696984593808449463663154590941773691772859381844308820350138431050151350846457101118166047681","2340441218411086810744585422374244021687390655044128752085233610315477653040981701549656255212001795266600909756674466847681","3900735364018478017907642370623740036145651091740214586824252009045857104871563461347525139268599179683910307333424466847681","7786292769422098127048274975953126365773150856444294116719539052716214214237146735466497737395245255924115859204046966847681","14707441897797296462202297176800349784298865447889215539211531475972585068729091518759407171085255117185043557301546966847681","44122325693391889386606891530401049352896596343667646617634594427917755206187274556278221513255765351555130671904640900543043","88244651140012621388186047373442718503162180217659602718402449859977767871441233767353898253072347463775413551904640900543043","176487892679288728221527457678326435544287028803372963791261380791403441988371737279000419080576765406225098051495019648724979","352975785358577418823847303988096643447519234156797810085467006360190397929252817668235453068360958115422636249895019648724979","635356413645439353882925147178573957785945071256274852887889090530149067419859795176789577969702510572367761035624490898724979","1058927356075732256471541911964289929643241785427124754813449128605859066160948252003093194908569631529521721113713240898724979","2055564867676421439032952113800048057724482648655293699708652294156546117118685717997536858847929728540377342047995875276024979","4111129735172940402615969044868555816191092818904868804133142452860804389896229504595217340871511132615407978182395875276024979","12333389205518821207847907134605667448573278456714606412399427358582413169688688513785652022614533397846223934547187625828074937","20555648675864702013079845224342779080955464094524344020667335744004176777421155437419641650514386250412016803188491375828074937","41111238541618483672518542601593658714173047780947223504016242748495145189985310638496418335053693652108844917759967855828074937","82222477083236967345035949807262466904280110160726294209834743437447267704436100626747612695381860856272991867417567855828074937","246667431249710902035107849421787400712840330482178882629504230312341803113308301880242838086145582568818975602252703567484224811","485860091855491170675211972128631555020105774832468946915415230730846820872864404726336703970207994490003771520588703567484224811","971601593119523379014774587294046126639279275978003056221966244778455552952937009700601147726570395305251777574717542723874404059","1835247453670210827027907553777642683572410974995259005219827704558605015513392611202238601824807669916855298895715905223874404059","3670494907340421654055791530375272858147337928351275196505606818010424749986064797265168458639842750021382515490598048903874404059","7340541810904345007694628222879180858800939733335823550191467256992468758627585537548826484404248164941470877825830048903874404059","14673922117283229965141171599118094096483879283455225666777639567255844171456456325239304202576653661370731364220914487691050308011","29347838986477041335913158701074704734964350903380902072657145993364302352811167527900686757901315775928579660054514487691050308011","88043516959431124007739476103224114204893052710142706217971437980092907058433502583702060273703947327785738980163543463073150924033","175915409129467645409653530015814560309856524406291548016317764985877183890744501633299449072402536465953430992520765863073150924033","316647736433041761737376354028466208554268695324650462677758342972408316648087517443998816121663153719542292766519690174539400924033","598112391040189994392822002053769505043087948815071859761091469821527831054376311206697806550609480266361324416175017072039400924033","1187023052987453973866866526410549159633381092365618965892020837998675311388227457045764982171590447177370472259559355530746577504033","2374037049766474853797921354766685483398526024159847539706646552533249209061130585353862766758713453851875633393921160330746577504033","4608424861311392363254782568420773027941611134320175462966857332523254332146127800264554893299610233404136495253996800072736188004033","9216849716177219998167119609268994141277904636262386412982413039681830674354464435431202202203725743859311966894219344472736188004033","16590329489118995996700815296684189454251601982475387057212111810857956355465079823569408353099105610782689695266982818781699938004033","33180635245232148293590672568102619382903801314558751052161966600640359915045472548812552228557090747055063310980004422621699938004033","99541905735696444880772017704307858148711403943676253156485899801921079745136417646437656685671272241165189932940013267865099814012099","199083811471392888390537411529538660480059492441182826513162588747507023230881670639219553576838246590531941708280639187865099814012099","597251434414178665171612234588615981440178477323548479539487766242521069692645011917658660730514739771595825124841917563595299442036297","995419057356964441952687057647693302400297462205914132565812963127799185563166700794459073822495350344446198986128964130335549442036297","1986964888809816181652912138519811132292805954844271282706306549668151852641997951447806570700308795512750427102783298195354736942036297","3958526949024207431112072589224782327209904995546520876105351325369934085666089433663664593318472628998753359765003954474279736942036297","7917053190189353588870694900480627354284080924142348586181577286429435721361949517364484910265145619412138707240562602189622863212036297","15594195677645696462927125857696676125550934262301148254091251443475383142168508083554750645083403915953991144160692311860022863212036297","30948480652558382112183193416701586560918372663979903253571310879010796308899600117301358192319031013667597069107273435552918010385536297","58458241232610277323012698675991885726167026371722531081472777754541072896771624049767505960345312964212807654106988929755850510385536297","116916482423698706010767208855299593890269934964182747771090053066650110573868355990133245713640605819085169948912036184402314510385536297","233605057474251800504522927715032643254458725522549852639992569149584754379987063631073311944197463739639781881603607620495754510385536297","700815172422755401513568783145097929763376176567649557919977707448754263139961190893219935832592391218919345644810822861487263531156608891","1401630344845510803027137566290195859526410235606264029538870891108182009835152064013763568483278048628660258220140016091823263531156608891","4204891034536532409081412698870587578579230706818792088616612673324546029505456192041290705449834145885980774660420048275469790593469826673","8409268839359408626939273718988271206192231802044748889226333170359471165445059424318587183249984025357968212367877469890368990593469826673","16818024449005161077199971936954646440755260281460418184587189524504896520131949141118749237567746172425753733489578297654741316993469826673","31767379514787526479155502547580998832537066326733765001010444793834297360728706864834663964651428645900310330601039812366925079493469826673","63534615125556981893570360424358292140608760567078728105296048738096949426826951755889213706497518556978563299549434359310883178583589909121","125143938883672843123699193940979523193598080198488553598056165451252342183039494922042628093129388905384879764474889565261961578583589909121","375431816651018529371097581822938569580794240595465660794168496353757026549118484766127884279388166716154639293424668695785884735750769727363","750863633299980781655420072013797286426838963657110822182096687386417040194167358263924312214484661468992517239239874401538133055750769727363","1501727266599961562011601726735761772735556167096254554569094461166652313200834936411614897822018646640667667166945735401186905349750769727363","3003454398408430381249339307346779613015843586227130375406610065951493459069033513303873223601085021877945215305601476033739701509750769727363","9010363195225291143748017922040338839047530758681391126219830197854480377207100539911619670803255065633835645916804428101219104529252309182089","18016328946236145491887280057621672935307288565143296340114473062966538610926555983762402117943508720173690606989244849188034950929252309182089","34972873836811341248957660627253855752917112211177800513394714175620603467599017744341265426920183014698989615431890075696010605330776010682089","58288123061352235414929434378756426254861853685296334188991190293030737073014393362419558682287578928226747469730251047871550630394526010682089","104918621510434023746872981881761567258751071546290181565794432058774391323279407745495569172481290323627328522377958622513416882948517260682089","209837243020868047403096155203720075080330085960227733822526792517565815321710152131625905843447376538547898280798760717666959161348517260682089","629511729062604142209288465611160225240990257880683201467580377552697445965130456394877717530342129615643694842396282153000877484045551782046267","1259023458125208284418576914741137436131335341489273482515805770910983601054299840334859644795524482103051015791192053098930093484045551782046267","2516818600678083651604617856768944340358150469656784970473864390495361895017653488849631572938271803132362583580744162865258573589496885804304747","4753990690169713564142055951674672642898725217339283085477895812405658379355015975543871623630585407702891285469764214068481772891379385804304747","8557183242305484415455700713014410757217698572651256881757922938005057576177067076971364012371401109095996423701236348849519917530133292054304747","14261972070509140692426167855024017928696164287752094802929871563347174874689963853026977031944416383378984155772715110324411942680205042054304747","28523944138526333853829093491453285048946794669440610796971166230591350059436031194274010860484409836233198095994496082141634030252564444038304747","57047878075973660314300296551186375451878292139415623061147674387471472414083020979286703889198109830337990982007418238374321724895764444038304747","171143634227920980942900889653559126355634876418246869183443023162414417242249062937860111667594329491013972946022254715122965174687293332114914241","285239390379868301571501482755931877259391460697078115305738371937389835152784844577041979251027813507780824563418029436921876132924052082114914241","570478768008378336769981317120424079865783008366171496974970568080815301453426986045800493626917034969330332191440339236659253288507400332114914241","1140956447915546947860889337891905581261971551637228258255443780685050608467826037989870448771651143865783855025023751128027018272315400332114914241","3422869343746640843582668013675716743785914654911684774766331342055151825403478113969611346314953431597351565075071253384081054816946200996344742723","6845738687488587637768842155482603184137385525862813256483690636113015385170613038331132358283270859656350779692596298192202374240946200996344742723","20537216062465762913306526466447809552412156577588439769451071908339046155511839114993397074849812578969052339077788894576607122722838602989034228169","41073805397961709393299204025214063580320593526717117596475829008392250531470189561432142783140967613557513897073173108292228665183833352989034228169","82145104002794285244773443808158398092176576111969906098419242310453669552176051424246047683340146873152501859969789960327655782212457992989034228169","136908506671323808741289073013597330153627626853283176830698737184090613537866161451234364936716901294780012861931399402250106058541385074239034228169","410725520013971426223867219040791990460882880559849530492096211552271840613598484353703094810150703884340038585794198206750318175624155222717102684507","821451039992071143760211096398265725682642205203068408026153930150879147537803366048662419823694868605236140342615421522334869608635355222717102684507","1630264371676571962147806023157475719533632468838600600748299156815099500994777760822897429837639593396226626120148201771885215981829993900231267784507","3257350840094515129046791442380097979985485328797663187366479696513537496059771534292686173639879063610766307058062776250658591539011433900231267784507","5863231512170127232284224596284176363973873491879020208641532791035257272264203066493478180856600229051326252386671131658768117106330299810575017784507","11681011617269168206940520225943590236359446318471402730120959388228672110154962247948599044296715041047442740440140276517765133610337650885575017784507","23350627125635461062841887500178185564440176051215019317036128857888053964450985361984549914086574998391524684220170218355412636657109353425465193079307","45993659489888029366203717800969772238663921381052752162679469013745420630918408869955935200172962932019177145370579550012947875452537193425465193079307","91987310755419808543444923215834206670654964668974101515900694316662950331465954978373782062680915462110311997368539443099816223521785657653268623079307","183974619454749788064922977534360008187018395368538347519710557607812282762310197524458437206576728633343897665990826029657711188251969337653268623079307","367233384359091989405752865636166983661684236375089844300749370089049629315865311495710484549028907627650033202929141805806774025348188055865456123079307","612055640598486649009588109393611639436140393958483073834582283481749466249244895904059930426421036472962436325979947868872814278001389990671706123079307","1836166921795459947028764328180834918308421181875449221503746850445248398747734687712179791279263109418887308977939843606618442834004169972015118369237921","3672333843590919894057528655715146454104511419220186592693192673813675102663735218700243902101778391335111174320878048380933762017282249972015118369237921","7343771339976560209943516086931748272008953828058694737805324240251039868843150534677228133409013585406142349306979586937369071960434563442020998626485521","12239618899960933683239193478219580453348256380097824563008873733751733615192980366066024034174031961919189355848117093705868746178108908299302248626485521","24479226127315374362973214989868427329038177471578964617448685259377263768607983585201192303299724562289004117094431260668099018998252669735142248626485521","48958452254622339195991227523521793963256152205028407663184819137857661687664114305553217482541873834904740245033908562314692739879185269795142248626485521","95036995553090423145159441656302105213164184103703628984224302767565834238648169294686702366233755055741287682440241093443428891356479972869715512785785521","190073991106180846290318883312604210426328367893094020413246281346439821996992106318833412503107901554917992245791134610777935681170643838469715512785785521","570221973318542538870956649937812631278985103679282061239738844039319465990976318956500237509323704664753976737373403832333807043511931515409146538357356563","1136023621262522732479034015541138657608707594487342303738815398226298048296458827519684136793043670126498689932167949291045043919463679852581021538357356563","2044842518272540918462261227974049583695673669355494385101548722101296472849632593917171678085949766980378771100549236265179329949628316240172046819607356563","4089685036545081836897515686980798088764112342308063681368813605286079063730411830057176384214128073371437820905632356930541862943257632950572046819607356563","12269055109635245510692547060942394266292337026924191044106440815858237191191235490171529152642384220114313462716897070791625588829772898851716140458822069689","24532122393448310184261082667109047632610485452975146243809375840169058839806459309951318097767905459910006130563123766967038081750457862282116140458822069689","49063870187974023699796834644329415336034937940260719970015526234725404675143792496016058900989421033362917840709237359975552070025421650248342059073085952809","98127735988211199246992171316851463142549024211657539869811504378755258578872291732284174842088314376483528624301668653043421061839311802993814059073085952809","196255471976405569984347952559000465414871748990536979801428849958404899311853165655914631818164279336803564059894890634863784653973798864609020459073085952809","392504954893883797470972044942362072438027448208969862102032250676602289102604823502798278398053422924256331872668186580696107505042892165897921709073085952809","778971372020169382670702011458374898244652169332656807793872339413963970580279671709744459364642308854003677241069254315121437188107309836835632308332991452809","1534337550948818481018049416506393153009911381092985027281149159280093704708269863946439825693767737485129980585231661759848094368049071653821232308332991452809","4603012652846455443054148249519179459029734143278955081843447477840281114124809591839319477081303212455389941755694985279544283104147214961463696924998974358427","9206025305692910886108296498935461298419507575523479064243214105827250130962696120009359420734781081933515339282104360848256545206583551446700688924998974358427"};

int n,P,ans;

int main()
{
    scanf("%d%d",&amp;n,&amp;P);
    int len=a[n].length();
    for(int i=0;i&lt;len;i++)
        ans=(long long)((long long)ans*10+a[n][i]-48)%P;
    printf("%d\n",ans);

    return 0;
}
</pre><pre>﻿








</pre><br><a href="http://www.lydsy.com/JudgeOnline/"></a><span class="red">HOME</span><a href="javascript:history.go(-1)"></a><span class="red">Back</span><hr><center>
	
</center><div class="footer">
			&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		
			
		
	</div><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=ko">한국어</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=cn">中文</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=fa">فارسی</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=en">English</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=th">ไทย</a><br><div>版权所有 ©2008-2012 大视野在线测评 |  | 
</div><a href="http://www.miitbeian.gov.cn/">湘ICP备13009380号</a><script src="./bzoj_source_files/stat.php" language="JavaScript"></script><script src="./bzoj_source_files/core.php" charset="utf-8" type="text/javascript"></script><a href="http://www.cnzz.com/stat/website.php?web_id=2982771" target="_blank" title="站长统计">站长统计</a><div>Based on opensource project .</div><a href="http://hustoj.googlecode.com/">hustoj</a></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></body></html>
